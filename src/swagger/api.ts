/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * ThingsBoard REST API
 * For instructions how to authorize requests please visit <a href='http://thingsboard.io/docs/reference/rest-api/'>REST API documentation page</a>.
 *
 * OpenAPI spec version: 2.0
 * Contact: info@thingsboard.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://uat-obumngt.hyvasmart.com:443".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AdminSettings
 */
export interface AdminSettings {
    /**
     * 
     * @type {number}
     * @memberof AdminSettings
     */
    createdTime?: number;
    /**
     * 
     * @type {AdminSettingsId}
     * @memberof AdminSettings
     */
    id?: AdminSettingsId;
    /**
     * 
     * @type {string}
     * @memberof AdminSettings
     */
    jsonValue?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminSettings
     */
    key?: string;
}

/**
 * 
 * @export
 * @interface AdminSettingsId
 */
export interface AdminSettingsId {
    /**
     * 
     * @type {string}
     * @memberof AdminSettingsId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface Alarm
 */
export interface Alarm {
    /**
     * 
     * @type {number}
     * @memberof Alarm
     */
    ackTs?: number;
    /**
     * 
     * @type {number}
     * @memberof Alarm
     */
    clearTs?: number;
    /**
     * 
     * @type {number}
     * @memberof Alarm
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Alarm
     */
    details?: string;
    /**
     * 
     * @type {number}
     * @memberof Alarm
     */
    endTs?: number;
    /**
     * 
     * @type {AlarmId}
     * @memberof Alarm
     */
    id?: AlarmId;
    /**
     * 
     * @type {string}
     * @memberof Alarm
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof Alarm
     */
    originator?: EntityId;
    /**
     * 
     * @type {boolean}
     * @memberof Alarm
     */
    propagate?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Alarm
     */
    propagateRelationTypes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Alarm
     */
    severity?: Alarm.SeverityEnum;
    /**
     * 
     * @type {number}
     * @memberof Alarm
     */
    startTs?: number;
    /**
     * 
     * @type {string}
     * @memberof Alarm
     */
    status?: Alarm.StatusEnum;
    /**
     * 
     * @type {TenantId}
     * @memberof Alarm
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Alarm
     */
    type?: string;
}

/**
 * @export
 * @namespace Alarm
 */
export namespace Alarm {
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        CRITICAL = <any> 'CRITICAL',
        MAJOR = <any> 'MAJOR',
        MINOR = <any> 'MINOR',
        WARNING = <any> 'WARNING',
        INDETERMINATE = <any> 'INDETERMINATE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVEUNACK = <any> 'ACTIVE_UNACK',
        ACTIVEACK = <any> 'ACTIVE_ACK',
        CLEAREDUNACK = <any> 'CLEARED_UNACK',
        CLEAREDACK = <any> 'CLEARED_ACK'
    }
}

/**
 * 
 * @export
 * @interface AlarmCondition
 */
export interface AlarmCondition {
    /**
     * 
     * @type {Array<AlarmConditionFilter>}
     * @memberof AlarmCondition
     */
    condition?: Array<AlarmConditionFilter>;
    /**
     * 
     * @type {AlarmConditionSpec}
     * @memberof AlarmCondition
     */
    spec?: AlarmConditionSpec;
}

/**
 * 
 * @export
 * @interface AlarmConditionFilter
 */
export interface AlarmConditionFilter {
    /**
     * 
     * @type {AlarmConditionFilterKey}
     * @memberof AlarmConditionFilter
     */
    key?: AlarmConditionFilterKey;
    /**
     * 
     * @type {KeyFilterPredicate}
     * @memberof AlarmConditionFilter
     */
    predicate?: KeyFilterPredicate;
    /**
     * 
     * @type {any}
     * @memberof AlarmConditionFilter
     */
    value?: any;
    /**
     * 
     * @type {string}
     * @memberof AlarmConditionFilter
     */
    valueType?: AlarmConditionFilter.ValueTypeEnum;
}

/**
 * @export
 * @namespace AlarmConditionFilter
 */
export namespace AlarmConditionFilter {
    /**
     * @export
     * @enum {string}
     */
    export enum ValueTypeEnum {
        STRING = <any> 'STRING',
        NUMERIC = <any> 'NUMERIC',
        BOOLEAN = <any> 'BOOLEAN',
        DATETIME = <any> 'DATE_TIME'
    }
}

/**
 * 
 * @export
 * @interface AlarmConditionFilterKey
 */
export interface AlarmConditionFilterKey {
    /**
     * 
     * @type {string}
     * @memberof AlarmConditionFilterKey
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof AlarmConditionFilterKey
     */
    type?: AlarmConditionFilterKey.TypeEnum;
}

/**
 * @export
 * @namespace AlarmConditionFilterKey
 */
export namespace AlarmConditionFilterKey {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ATTRIBUTE = <any> 'ATTRIBUTE',
        TIMESERIES = <any> 'TIME_SERIES',
        ENTITYFIELD = <any> 'ENTITY_FIELD',
        CONSTANT = <any> 'CONSTANT'
    }
}

/**
 * 
 * @export
 * @interface AlarmConditionSpec
 */
export interface AlarmConditionSpec {
}

/**
 * 
 * @export
 * @interface AlarmData
 */
export interface AlarmData {
    /**
     * 
     * @type {number}
     * @memberof AlarmData
     */
    ackTs?: number;
    /**
     * 
     * @type {number}
     * @memberof AlarmData
     */
    clearTs?: number;
    /**
     * 
     * @type {number}
     * @memberof AlarmData
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof AlarmData
     */
    details?: string;
    /**
     * 
     * @type {number}
     * @memberof AlarmData
     */
    endTs?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof AlarmData
     */
    entityId?: EntityId;
    /**
     * 
     * @type {AlarmId}
     * @memberof AlarmData
     */
    id?: AlarmId;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: TsValue; }; }}
     * @memberof AlarmData
     */
    latest?: { [key: string]: { [key: string]: TsValue; }; };
    /**
     * 
     * @type {string}
     * @memberof AlarmData
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof AlarmData
     */
    originator?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof AlarmData
     */
    originatorName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AlarmData
     */
    propagate?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlarmData
     */
    propagateRelationTypes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AlarmData
     */
    severity?: AlarmData.SeverityEnum;
    /**
     * 
     * @type {number}
     * @memberof AlarmData
     */
    startTs?: number;
    /**
     * 
     * @type {string}
     * @memberof AlarmData
     */
    status?: AlarmData.StatusEnum;
    /**
     * 
     * @type {TenantId}
     * @memberof AlarmData
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof AlarmData
     */
    type?: string;
}

/**
 * @export
 * @namespace AlarmData
 */
export namespace AlarmData {
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        CRITICAL = <any> 'CRITICAL',
        MAJOR = <any> 'MAJOR',
        MINOR = <any> 'MINOR',
        WARNING = <any> 'WARNING',
        INDETERMINATE = <any> 'INDETERMINATE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVEUNACK = <any> 'ACTIVE_UNACK',
        ACTIVEACK = <any> 'ACTIVE_ACK',
        CLEAREDUNACK = <any> 'CLEARED_UNACK',
        CLEAREDACK = <any> 'CLEARED_ACK'
    }
}

/**
 * 
 * @export
 * @interface AlarmDataPageLink
 */
export interface AlarmDataPageLink {
    /**
     * 
     * @type {boolean}
     * @memberof AlarmDataPageLink
     */
    dynamic?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AlarmDataPageLink
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof AlarmDataPageLink
     */
    pageSize?: number;
    /**
     * 
     * @type {EntityDataSortOrder}
     * @memberof AlarmDataPageLink
     */
    sortOrder?: EntityDataSortOrder;
    /**
     * 
     * @type {number}
     * @memberof AlarmDataPageLink
     */
    startTs: number;
    /**
     * 
     * @type {string}
     * @memberof AlarmDataPageLink
     */
    textSearch?: string;
    /**
     * 
     * @type {number}
     * @memberof AlarmDataPageLink
     */
    endTs: number;
    /**
     * 
     * @type {number}
     * @memberof AlarmDataPageLink
     */
    timeWindow: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlarmDataPageLink
     */
    typeList: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlarmDataPageLink
     */
    statusList: Array<AlarmDataPageLink.StatusListEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlarmDataPageLink
     */
    severityList: Array<AlarmDataPageLink.SeverityListEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof AlarmDataPageLink
     */
    searchPropagatedAlarms: boolean;
}

/**
 * @export
 * @namespace AlarmDataPageLink
 */
export namespace AlarmDataPageLink {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusListEnum {
        ANY = <any> 'ANY',
        ACTIVE = <any> 'ACTIVE',
        CLEARED = <any> 'CLEARED',
        ACK = <any> 'ACK',
        UNACK = <any> 'UNACK'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityListEnum {
        CRITICAL = <any> 'CRITICAL',
        MAJOR = <any> 'MAJOR',
        MINOR = <any> 'MINOR',
        WARNING = <any> 'WARNING',
        INDETERMINATE = <any> 'INDETERMINATE'
    }
}

/**
 * 
 * @export
 * @interface AlarmDataQuery
 */
export interface AlarmDataQuery {
    /**
     * 
     * @type {Array<EntityKey>}
     * @memberof AlarmDataQuery
     */
    alarmFields?: Array<EntityKey>;
    /**
     * 
     * @type {Array<EntityKey>}
     * @memberof AlarmDataQuery
     */
    entityFields?: Array<EntityKey>;
    /**
     * 
     * @type {EntityFilter}
     * @memberof AlarmDataQuery
     */
    entityFilter?: EntityFilter;
    /**
     * 
     * @type {Array<KeyFilter>}
     * @memberof AlarmDataQuery
     */
    keyFilters?: Array<KeyFilter>;
    /**
     * 
     * @type {Array<EntityKey>}
     * @memberof AlarmDataQuery
     */
    latestValues?: Array<EntityKey>;
    /**
     * 
     * @type {AlarmDataPageLink}
     * @memberof AlarmDataQuery
     */
    pageLink?: AlarmDataPageLink;
}

/**
 * 
 * @export
 * @interface AlarmId
 */
export interface AlarmId {
    /**
     * 
     * @type {string}
     * @memberof AlarmId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface AlarmInfo
 */
export interface AlarmInfo {
    /**
     * 
     * @type {number}
     * @memberof AlarmInfo
     */
    ackTs?: number;
    /**
     * 
     * @type {number}
     * @memberof AlarmInfo
     */
    clearTs?: number;
    /**
     * 
     * @type {number}
     * @memberof AlarmInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof AlarmInfo
     */
    details?: string;
    /**
     * 
     * @type {number}
     * @memberof AlarmInfo
     */
    endTs?: number;
    /**
     * 
     * @type {AlarmId}
     * @memberof AlarmInfo
     */
    id?: AlarmId;
    /**
     * 
     * @type {string}
     * @memberof AlarmInfo
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof AlarmInfo
     */
    originator?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof AlarmInfo
     */
    originatorName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AlarmInfo
     */
    propagate?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlarmInfo
     */
    propagateRelationTypes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AlarmInfo
     */
    severity?: AlarmInfo.SeverityEnum;
    /**
     * 
     * @type {number}
     * @memberof AlarmInfo
     */
    startTs?: number;
    /**
     * 
     * @type {string}
     * @memberof AlarmInfo
     */
    status?: AlarmInfo.StatusEnum;
    /**
     * 
     * @type {TenantId}
     * @memberof AlarmInfo
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof AlarmInfo
     */
    type?: string;
}

/**
 * @export
 * @namespace AlarmInfo
 */
export namespace AlarmInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        CRITICAL = <any> 'CRITICAL',
        MAJOR = <any> 'MAJOR',
        MINOR = <any> 'MINOR',
        WARNING = <any> 'WARNING',
        INDETERMINATE = <any> 'INDETERMINATE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVEUNACK = <any> 'ACTIVE_UNACK',
        ACTIVEACK = <any> 'ACTIVE_ACK',
        CLEAREDUNACK = <any> 'CLEARED_UNACK',
        CLEAREDACK = <any> 'CLEARED_ACK'
    }
}

/**
 * 
 * @export
 * @interface AlarmRule
 */
export interface AlarmRule {
    /**
     * 
     * @type {string}
     * @memberof AlarmRule
     */
    alarmDetails?: string;
    /**
     * 
     * @type {AlarmCondition}
     * @memberof AlarmRule
     */
    condition?: AlarmCondition;
    /**
     * 
     * @type {AlarmSchedule}
     * @memberof AlarmRule
     */
    schedule?: AlarmSchedule;
}

/**
 * 
 * @export
 * @interface AlarmSchedule
 */
export interface AlarmSchedule {
    /**
     * 
     * @type {string}
     * @memberof AlarmSchedule
     */
    type?: AlarmSchedule.TypeEnum;
}

/**
 * @export
 * @namespace AlarmSchedule
 */
export namespace AlarmSchedule {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ANYTIME = <any> 'ANY_TIME',
        SPECIFICTIME = <any> 'SPECIFIC_TIME',
        CUSTOM = <any> 'CUSTOM'
    }
}

/**
 * 
 * @export
 * @interface AllowedPermissionsInfo
 */
export interface AllowedPermissionsInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof AllowedPermissionsInfo
     */
    allowedForGroupOwnerOnlyGroupOperations?: Array<AllowedPermissionsInfo.AllowedForGroupOwnerOnlyGroupOperationsEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllowedPermissionsInfo
     */
    allowedForGroupOwnerOnlyOperations?: Array<AllowedPermissionsInfo.AllowedForGroupOwnerOnlyOperationsEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllowedPermissionsInfo
     */
    allowedForGroupRoleOperations?: Array<AllowedPermissionsInfo.AllowedForGroupRoleOperationsEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllowedPermissionsInfo
     */
    allowedResources?: Array<AllowedPermissionsInfo.AllowedResourcesEnum>;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AllowedPermissionsInfo
     */
    operationsByResource?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {EntityId}
     * @memberof AllowedPermissionsInfo
     */
    userOwnerId?: EntityId;
    /**
     * 
     * @type {MergedUserPermissions}
     * @memberof AllowedPermissionsInfo
     */
    userPermissions?: MergedUserPermissions;
}

/**
 * @export
 * @namespace AllowedPermissionsInfo
 */
export namespace AllowedPermissionsInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum AllowedForGroupOwnerOnlyGroupOperationsEnum {
        ALL = <any> 'ALL',
        CREATE = <any> 'CREATE',
        READ = <any> 'READ',
        WRITE = <any> 'WRITE',
        DELETE = <any> 'DELETE',
        RPCCALL = <any> 'RPC_CALL',
        READCREDENTIALS = <any> 'READ_CREDENTIALS',
        WRITECREDENTIALS = <any> 'WRITE_CREDENTIALS',
        READATTRIBUTES = <any> 'READ_ATTRIBUTES',
        WRITEATTRIBUTES = <any> 'WRITE_ATTRIBUTES',
        READTELEMETRY = <any> 'READ_TELEMETRY',
        WRITETELEMETRY = <any> 'WRITE_TELEMETRY',
        ADDTOGROUP = <any> 'ADD_TO_GROUP',
        REMOVEFROMGROUP = <any> 'REMOVE_FROM_GROUP',
        CHANGEOWNER = <any> 'CHANGE_OWNER',
        IMPERSONATE = <any> 'IMPERSONATE',
        CLAIMDEVICES = <any> 'CLAIM_DEVICES',
        SHAREGROUP = <any> 'SHARE_GROUP',
        ASSIGNTOTENANT = <any> 'ASSIGN_TO_TENANT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AllowedForGroupOwnerOnlyOperationsEnum {
        ALL = <any> 'ALL',
        CREATE = <any> 'CREATE',
        READ = <any> 'READ',
        WRITE = <any> 'WRITE',
        DELETE = <any> 'DELETE',
        RPCCALL = <any> 'RPC_CALL',
        READCREDENTIALS = <any> 'READ_CREDENTIALS',
        WRITECREDENTIALS = <any> 'WRITE_CREDENTIALS',
        READATTRIBUTES = <any> 'READ_ATTRIBUTES',
        WRITEATTRIBUTES = <any> 'WRITE_ATTRIBUTES',
        READTELEMETRY = <any> 'READ_TELEMETRY',
        WRITETELEMETRY = <any> 'WRITE_TELEMETRY',
        ADDTOGROUP = <any> 'ADD_TO_GROUP',
        REMOVEFROMGROUP = <any> 'REMOVE_FROM_GROUP',
        CHANGEOWNER = <any> 'CHANGE_OWNER',
        IMPERSONATE = <any> 'IMPERSONATE',
        CLAIMDEVICES = <any> 'CLAIM_DEVICES',
        SHAREGROUP = <any> 'SHARE_GROUP',
        ASSIGNTOTENANT = <any> 'ASSIGN_TO_TENANT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AllowedForGroupRoleOperationsEnum {
        ALL = <any> 'ALL',
        CREATE = <any> 'CREATE',
        READ = <any> 'READ',
        WRITE = <any> 'WRITE',
        DELETE = <any> 'DELETE',
        RPCCALL = <any> 'RPC_CALL',
        READCREDENTIALS = <any> 'READ_CREDENTIALS',
        WRITECREDENTIALS = <any> 'WRITE_CREDENTIALS',
        READATTRIBUTES = <any> 'READ_ATTRIBUTES',
        WRITEATTRIBUTES = <any> 'WRITE_ATTRIBUTES',
        READTELEMETRY = <any> 'READ_TELEMETRY',
        WRITETELEMETRY = <any> 'WRITE_TELEMETRY',
        ADDTOGROUP = <any> 'ADD_TO_GROUP',
        REMOVEFROMGROUP = <any> 'REMOVE_FROM_GROUP',
        CHANGEOWNER = <any> 'CHANGE_OWNER',
        IMPERSONATE = <any> 'IMPERSONATE',
        CLAIMDEVICES = <any> 'CLAIM_DEVICES',
        SHAREGROUP = <any> 'SHARE_GROUP',
        ASSIGNTOTENANT = <any> 'ASSIGN_TO_TENANT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AllowedResourcesEnum {
        ALL = <any> 'ALL',
        PROFILE = <any> 'PROFILE',
        ADMINSETTINGS = <any> 'ADMIN_SETTINGS',
        ALARM = <any> 'ALARM',
        DEVICE = <any> 'DEVICE',
        ASSET = <any> 'ASSET',
        CUSTOMER = <any> 'CUSTOMER',
        DASHBOARD = <any> 'DASHBOARD',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        TENANT = <any> 'TENANT',
        RULECHAIN = <any> 'RULE_CHAIN',
        USER = <any> 'USER',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        OAUTH2CONFIGURATIONINFO = <any> 'OAUTH2_CONFIGURATION_INFO',
        OAUTH2CONFIGURATIONTEMPLATE = <any> 'OAUTH2_CONFIGURATION_TEMPLATE',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        CUSTOMERGROUP = <any> 'CUSTOMER_GROUP',
        DEVICEGROUP = <any> 'DEVICE_GROUP',
        ASSETGROUP = <any> 'ASSET_GROUP',
        USERGROUP = <any> 'USER_GROUP',
        ENTITYVIEWGROUP = <any> 'ENTITY_VIEW_GROUP',
        DASHBOARDGROUP = <any> 'DASHBOARD_GROUP',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        WHITELABELING = <any> 'WHITE_LABELING',
        AUDITLOG = <any> 'AUDIT_LOG',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OperationsByResourceEnum {
        ALL = <any> 'ALL',
        CREATE = <any> 'CREATE',
        READ = <any> 'READ',
        WRITE = <any> 'WRITE',
        DELETE = <any> 'DELETE',
        RPCCALL = <any> 'RPC_CALL',
        READCREDENTIALS = <any> 'READ_CREDENTIALS',
        WRITECREDENTIALS = <any> 'WRITE_CREDENTIALS',
        READATTRIBUTES = <any> 'READ_ATTRIBUTES',
        WRITEATTRIBUTES = <any> 'WRITE_ATTRIBUTES',
        READTELEMETRY = <any> 'READ_TELEMETRY',
        WRITETELEMETRY = <any> 'WRITE_TELEMETRY',
        ADDTOGROUP = <any> 'ADD_TO_GROUP',
        REMOVEFROMGROUP = <any> 'REMOVE_FROM_GROUP',
        CHANGEOWNER = <any> 'CHANGE_OWNER',
        IMPERSONATE = <any> 'IMPERSONATE',
        CLAIMDEVICES = <any> 'CLAIM_DEVICES',
        SHAREGROUP = <any> 'SHARE_GROUP',
        ASSIGNTOTENANT = <any> 'ASSIGN_TO_TENANT'
    }
}

/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    additionalInfo?: string;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof Asset
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {AssetId}
     * @memberof Asset
     */
    id?: AssetId;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof Asset
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {TenantId}
     * @memberof Asset
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface AssetId
 */
export interface AssetId {
    /**
     * 
     * @type {string}
     * @memberof AssetId
     */
    id: string;
}

/**
 * 
 * @export
 * @interface AssetSearchQuery
 */
export interface AssetSearchQuery {
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetSearchQuery
     */
    assetTypes?: Array<string>;
    /**
     * 
     * @type {RelationsSearchParameters}
     * @memberof AssetSearchQuery
     */
    parameters?: RelationsSearchParameters;
    /**
     * 
     * @type {string}
     * @memberof AssetSearchQuery
     */
    relationType?: string;
}

/**
 * 
 * @export
 * @interface AttributesEntityView
 */
export interface AttributesEntityView {
    /**
     * 
     * @type {Array<string>}
     * @memberof AttributesEntityView
     */
    cs?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttributesEntityView
     */
    sh?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttributesEntityView
     */
    ss?: Array<string>;
}

/**
 * 
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    actionData?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    actionFailureDetails?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    actionStatus?: AuditLog.ActionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    actionType?: AuditLog.ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AuditLog
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof AuditLog
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {EntityId}
     * @memberof AuditLog
     */
    entityId?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    entityName?: string;
    /**
     * 
     * @type {AuditLogId}
     * @memberof AuditLog
     */
    id?: AuditLogId;
    /**
     * 
     * @type {TenantId}
     * @memberof AuditLog
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {UserId}
     * @memberof AuditLog
     */
    userId?: UserId;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    userName?: string;
}

/**
 * @export
 * @namespace AuditLog
 */
export namespace AuditLog {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionStatusEnum {
        SUCCESS = <any> 'SUCCESS',
        FAILURE = <any> 'FAILURE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ActionTypeEnum {
        ADDED = <any> 'ADDED',
        DELETED = <any> 'DELETED',
        UPDATED = <any> 'UPDATED',
        ATTRIBUTESUPDATED = <any> 'ATTRIBUTES_UPDATED',
        ATTRIBUTESDELETED = <any> 'ATTRIBUTES_DELETED',
        TIMESERIESUPDATED = <any> 'TIMESERIES_UPDATED',
        TIMESERIESDELETED = <any> 'TIMESERIES_DELETED',
        RPCCALL = <any> 'RPC_CALL',
        CREDENTIALSUPDATED = <any> 'CREDENTIALS_UPDATED',
        ASSIGNEDTOCUSTOMER = <any> 'ASSIGNED_TO_CUSTOMER',
        UNASSIGNEDFROMCUSTOMER = <any> 'UNASSIGNED_FROM_CUSTOMER',
        CHANGEOWNER = <any> 'CHANGE_OWNER',
        ACTIVATED = <any> 'ACTIVATED',
        SUSPENDED = <any> 'SUSPENDED',
        CREDENTIALSREAD = <any> 'CREDENTIALS_READ',
        ATTRIBUTESREAD = <any> 'ATTRIBUTES_READ',
        RELATIONADDORUPDATE = <any> 'RELATION_ADD_OR_UPDATE',
        RELATIONDELETED = <any> 'RELATION_DELETED',
        RELATIONSDELETED = <any> 'RELATIONS_DELETED',
        ALARMACK = <any> 'ALARM_ACK',
        ALARMCLEAR = <any> 'ALARM_CLEAR',
        ADDEDTOENTITYGROUP = <any> 'ADDED_TO_ENTITY_GROUP',
        REMOVEDFROMENTITYGROUP = <any> 'REMOVED_FROM_ENTITY_GROUP',
        RESTAPIRULEENGINECALL = <any> 'REST_API_RULE_ENGINE_CALL',
        MADEPUBLIC = <any> 'MADE_PUBLIC',
        MADEPRIVATE = <any> 'MADE_PRIVATE',
        LOGIN = <any> 'LOGIN',
        LOGOUT = <any> 'LOGOUT',
        LOCKOUT = <any> 'LOCKOUT',
        ASSIGNEDFROMTENANT = <any> 'ASSIGNED_FROM_TENANT',
        ASSIGNEDTOTENANT = <any> 'ASSIGNED_TO_TENANT',
        PROVISIONSUCCESS = <any> 'PROVISION_SUCCESS',
        PROVISIONFAILURE = <any> 'PROVISION_FAILURE'
    }
}

/**
 * 
 * @export
 * @interface AuditLogId
 */
export interface AuditLogId {
    /**
     * 
     * @type {string}
     * @memberof AuditLogId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface BlobEntityId
 */
export interface BlobEntityId {
    /**
     * 
     * @type {string}
     * @memberof BlobEntityId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface BlobEntityInfo
 */
export interface BlobEntityInfo {
    /**
     * 
     * @type {string}
     * @memberof BlobEntityInfo
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof BlobEntityInfo
     */
    contentType?: string;
    /**
     * 
     * @type {number}
     * @memberof BlobEntityInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof BlobEntityInfo
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {BlobEntityId}
     * @memberof BlobEntityInfo
     */
    id?: BlobEntityId;
    /**
     * 
     * @type {string}
     * @memberof BlobEntityInfo
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof BlobEntityInfo
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {TenantId}
     * @memberof BlobEntityInfo
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof BlobEntityInfo
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface BlobEntityWithCustomerInfo
 */
export interface BlobEntityWithCustomerInfo {
    /**
     * 
     * @type {string}
     * @memberof BlobEntityWithCustomerInfo
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof BlobEntityWithCustomerInfo
     */
    contentType?: string;
    /**
     * 
     * @type {number}
     * @memberof BlobEntityWithCustomerInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof BlobEntityWithCustomerInfo
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {boolean}
     * @memberof BlobEntityWithCustomerInfo
     */
    customerIsPublic?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BlobEntityWithCustomerInfo
     */
    customerTitle?: string;
    /**
     * 
     * @type {BlobEntityId}
     * @memberof BlobEntityWithCustomerInfo
     */
    id?: BlobEntityId;
    /**
     * 
     * @type {string}
     * @memberof BlobEntityWithCustomerInfo
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof BlobEntityWithCustomerInfo
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {TenantId}
     * @memberof BlobEntityWithCustomerInfo
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof BlobEntityWithCustomerInfo
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface ClaimRequest
 */
export interface ClaimRequest {
    /**
     * 
     * @type {string}
     * @memberof ClaimRequest
     */
    secretKey: string;
}

/**
 * 
 * @export
 * @interface ClientRegistrationDto
 */
export interface ClientRegistrationDto {
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    accessTokenUri?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    authorizationUri?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    clientAuthenticationMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    clientSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    jwkSetUri?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    loginButtonIcon?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    loginButtonLabel?: string;
    /**
     * 
     * @type {OAuth2MapperConfig}
     * @memberof ClientRegistrationDto
     */
    mapperConfig?: OAuth2MapperConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientRegistrationDto
     */
    scope?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    userInfoUri?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientRegistrationDto
     */
    userNameAttributeName?: string;
}

/**
 * 
 * @export
 * @interface ComponentDescriptor
 */
export interface ComponentDescriptor {
    /**
     * 
     * @type {string}
     * @memberof ComponentDescriptor
     */
    actions?: string;
    /**
     * 
     * @type {string}
     * @memberof ComponentDescriptor
     */
    clazz?: string;
    /**
     * 
     * @type {string}
     * @memberof ComponentDescriptor
     */
    configurationDescriptor?: string;
    /**
     * 
     * @type {number}
     * @memberof ComponentDescriptor
     */
    createdTime?: number;
    /**
     * 
     * @type {ComponentDescriptorId}
     * @memberof ComponentDescriptor
     */
    id?: ComponentDescriptorId;
    /**
     * 
     * @type {string}
     * @memberof ComponentDescriptor
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ComponentDescriptor
     */
    scope?: ComponentDescriptor.ScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof ComponentDescriptor
     */
    type?: ComponentDescriptor.TypeEnum;
}

/**
 * @export
 * @namespace ComponentDescriptor
 */
export namespace ComponentDescriptor {
    /**
     * @export
     * @enum {string}
     */
    export enum ScopeEnum {
        SYSTEM = <any> 'SYSTEM',
        TENANT = <any> 'TENANT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ENRICHMENT = <any> 'ENRICHMENT',
        FILTER = <any> 'FILTER',
        TRANSFORMATION = <any> 'TRANSFORMATION',
        ACTION = <any> 'ACTION',
        ANALYTICS = <any> 'ANALYTICS',
        EXTERNAL = <any> 'EXTERNAL'
    }
}

/**
 * 
 * @export
 * @interface ComponentDescriptorId
 */
export interface ComponentDescriptorId {
    /**
     * 
     * @type {string}
     * @memberof ComponentDescriptorId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface ContactBasedobject
 */
export interface ContactBasedobject {
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof ContactBasedobject
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    email?: string;
    /**
     * 
     * @type {any}
     * @memberof ContactBasedobject
     */
    id?: any;
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactBasedobject
     */
    zip?: string;
}

/**
 * 
 * @export
 * @interface Converter
 */
export interface Converter {
    /**
     * 
     * @type {string}
     * @memberof Converter
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof Converter
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof Converter
     */
    createdTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Converter
     */
    debugMode?: boolean;
    /**
     * 
     * @type {ConverterId}
     * @memberof Converter
     */
    id?: ConverterId;
    /**
     * 
     * @type {string}
     * @memberof Converter
     */
    name?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof Converter
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Converter
     */
    type?: Converter.TypeEnum;
}

/**
 * @export
 * @namespace Converter
 */
export namespace Converter {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        UPLINK = <any> 'UPLINK',
        DOWNLINK = <any> 'DOWNLINK'
    }
}

/**
 * 
 * @export
 * @interface ConverterId
 */
export interface ConverterId {
    /**
     * 
     * @type {string}
     * @memberof ConverterId
     */
    id: string;
}

/**
 * 
 * @export
 * @interface CustomMenu
 */
export interface CustomMenu {
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomMenu
     */
    disabledMenuItems?: Array<string>;
    /**
     * 
     * @type {Array<CustomMenuItem>}
     * @memberof CustomMenu
     */
    menuItems?: Array<CustomMenuItem>;
}

/**
 * 
 * @export
 * @interface CustomMenuItem
 */
export interface CustomMenuItem {
    /**
     * 
     * @type {Array<CustomMenuItem>}
     * @memberof CustomMenuItem
     */
    childMenuItems?: Array<CustomMenuItem>;
    /**
     * 
     * @type {string}
     * @memberof CustomMenuItem
     */
    dashboardId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomMenuItem
     */
    hideDashboardToolbar?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomMenuItem
     */
    iconUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomMenuItem
     */
    iframeUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomMenuItem
     */
    materialIcon?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomMenuItem
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomMenuItem
     */
    setAccessToken?: boolean;
}

/**
 * 
 * @export
 * @interface CustomTranslation
 */
export interface CustomTranslation {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CustomTranslation
     */
    translationMap?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof Customer
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof Customer
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    email?: string;
    /**
     * 
     * @type {CustomerId}
     * @memberof Customer
     */
    id?: CustomerId;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof Customer
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {CustomerId}
     * @memberof Customer
     */
    parentCustomerId?: CustomerId;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    state?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof Customer
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    zip?: string;
}

/**
 * 
 * @export
 * @interface CustomerId
 */
export interface CustomerId {
    /**
     * 
     * @type {string}
     * @memberof CustomerId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
    /**
     * 
     * @type {Array<ShortCustomerInfo>}
     * @memberof Dashboard
     */
    assignedCustomers?: Array<ShortCustomerInfo>;
    /**
     * 
     * @type {string}
     * @memberof Dashboard
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof Dashboard
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof Dashboard
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {DashboardId}
     * @memberof Dashboard
     */
    id?: DashboardId;
    /**
     * 
     * @type {string}
     * @memberof Dashboard
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof Dashboard
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {TenantId}
     * @memberof Dashboard
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Dashboard
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface DashboardId
 */
export interface DashboardId {
    /**
     * 
     * @type {string}
     * @memberof DashboardId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface DashboardInfo
 */
export interface DashboardInfo {
    /**
     * 
     * @type {Array<ShortCustomerInfo>}
     * @memberof DashboardInfo
     */
    assignedCustomers?: Array<ShortCustomerInfo>;
    /**
     * 
     * @type {number}
     * @memberof DashboardInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof DashboardInfo
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {string}
     * @memberof DashboardInfo
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof DashboardInfo
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {TenantId}
     * @memberof DashboardInfo
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof DashboardInfo
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface DefaultRuleChainCreateRequest
 */
export interface DefaultRuleChainCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultRuleChainCreateRequest
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface DeferredResultResponseEntity
 */
export interface DeferredResultResponseEntity {
    /**
     * 
     * @type {any}
     * @memberof DeferredResultResponseEntity
     */
    result?: any;
    /**
     * 
     * @type {boolean}
     * @memberof DeferredResultResponseEntity
     */
    setOrExpired?: boolean;
}

/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    additionalInfo?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof Device
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {DeviceData}
     * @memberof Device
     */
    deviceData?: DeviceData;
    /**
     * 
     * @type {DeviceProfileId}
     * @memberof Device
     */
    deviceProfileId?: DeviceProfileId;
    /**
     * 
     * @type {DeviceId}
     * @memberof Device
     */
    id?: DeviceId;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof Device
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {TenantId}
     * @memberof Device
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface DeviceConfiguration
 */
export interface DeviceConfiguration {
}

/**
 * 
 * @export
 * @interface DeviceCredentials
 */
export interface DeviceCredentials {
    /**
     * 
     * @type {number}
     * @memberof DeviceCredentials
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceCredentials
     */
    credentialsId?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCredentials
     */
    credentialsType?: DeviceCredentials.CredentialsTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceCredentials
     */
    credentialsValue?: string;
    /**
     * 
     * @type {DeviceId}
     * @memberof DeviceCredentials
     */
    deviceId?: DeviceId;
    /**
     * 
     * @type {DeviceCredentialsId}
     * @memberof DeviceCredentials
     */
    id?: DeviceCredentialsId;
}

/**
 * @export
 * @namespace DeviceCredentials
 */
export namespace DeviceCredentials {
    /**
     * @export
     * @enum {string}
     */
    export enum CredentialsTypeEnum {
        ACCESSTOKEN = <any> 'ACCESS_TOKEN',
        X509CERTIFICATE = <any> 'X509_CERTIFICATE',
        MQTTBASIC = <any> 'MQTT_BASIC'
    }
}

/**
 * 
 * @export
 * @interface DeviceCredentialsId
 */
export interface DeviceCredentialsId {
    /**
     * 
     * @type {string}
     * @memberof DeviceCredentialsId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface DeviceData
 */
export interface DeviceData {
    /**
     * 
     * @type {DeviceConfiguration}
     * @memberof DeviceData
     */
    configuration?: DeviceConfiguration;
    /**
     * 
     * @type {DeviceTransportConfiguration}
     * @memberof DeviceData
     */
    transportConfiguration?: DeviceTransportConfiguration;
}

/**
 * 
 * @export
 * @interface DeviceId
 */
export interface DeviceId {
    /**
     * 
     * @type {string}
     * @memberof DeviceId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface DeviceProfile
 */
export interface DeviceProfile {
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    createdTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    _default?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    defaultQueueName?: string;
    /**
     * 
     * @type {RuleChainId}
     * @memberof DeviceProfile
     */
    defaultRuleChainId?: RuleChainId;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    description?: string;
    /**
     * 
     * @type {DeviceProfileId}
     * @memberof DeviceProfile
     */
    id?: DeviceProfileId;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    name?: string;
    /**
     * 
     * @type {DeviceProfileData}
     * @memberof DeviceProfile
     */
    profileData?: DeviceProfileData;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    provisionDeviceKey?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    provisionType?: DeviceProfile.ProvisionTypeEnum;
    /**
     * 
     * @type {TenantId}
     * @memberof DeviceProfile
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    transportType?: DeviceProfile.TransportTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    type?: DeviceProfile.TypeEnum;
}

/**
 * @export
 * @namespace DeviceProfile
 */
export namespace DeviceProfile {
    /**
     * @export
     * @enum {string}
     */
    export enum ProvisionTypeEnum {
        DISABLED = <any> 'DISABLED',
        ALLOWCREATENEWDEVICES = <any> 'ALLOW_CREATE_NEW_DEVICES',
        CHECKPREPROVISIONEDDEVICES = <any> 'CHECK_PRE_PROVISIONED_DEVICES'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TransportTypeEnum {
        DEFAULT = <any> 'DEFAULT',
        MQTT = <any> 'MQTT',
        LWM2M = <any> 'LWM2M',
        COAP = <any> 'COAP'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        DEFAULT = <any> 'DEFAULT'
    }
}

/**
 * 
 * @export
 * @interface DeviceProfileAlarm
 */
export interface DeviceProfileAlarm {
    /**
     * 
     * @type {string}
     * @memberof DeviceProfileAlarm
     */
    alarmType?: string;
    /**
     * 
     * @type {AlarmRule}
     * @memberof DeviceProfileAlarm
     */
    clearRule?: AlarmRule;
    /**
     * 
     * @type {{ [key: string]: AlarmRule; }}
     * @memberof DeviceProfileAlarm
     */
    createRules?: { [key: string]: AlarmRule; };
    /**
     * 
     * @type {string}
     * @memberof DeviceProfileAlarm
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfileAlarm
     */
    propagate?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceProfileAlarm
     */
    propagateRelationTypes?: Array<string>;
}

/**
 * 
 * @export
 * @interface DeviceProfileConfiguration
 */
export interface DeviceProfileConfiguration {
}

/**
 * 
 * @export
 * @interface DeviceProfileData
 */
export interface DeviceProfileData {
    /**
     * 
     * @type {Array<DeviceProfileAlarm>}
     * @memberof DeviceProfileData
     */
    alarms?: Array<DeviceProfileAlarm>;
    /**
     * 
     * @type {DeviceProfileConfiguration}
     * @memberof DeviceProfileData
     */
    configuration?: DeviceProfileConfiguration;
    /**
     * 
     * @type {DeviceProfileProvisionConfiguration}
     * @memberof DeviceProfileData
     */
    provisionConfiguration?: DeviceProfileProvisionConfiguration;
    /**
     * 
     * @type {DeviceProfileTransportConfiguration}
     * @memberof DeviceProfileData
     */
    transportConfiguration?: DeviceProfileTransportConfiguration;
}

/**
 * 
 * @export
 * @interface DeviceProfileId
 */
export interface DeviceProfileId {
    /**
     * 
     * @type {string}
     * @memberof DeviceProfileId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface DeviceProfileInfo
 */
export interface DeviceProfileInfo {
    /**
     * 
     * @type {EntityId}
     * @memberof DeviceProfileInfo
     */
    id?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfileInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfileInfo
     */
    transportType?: DeviceProfileInfo.TransportTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfileInfo
     */
    type?: DeviceProfileInfo.TypeEnum;
}

/**
 * @export
 * @namespace DeviceProfileInfo
 */
export namespace DeviceProfileInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum TransportTypeEnum {
        DEFAULT = <any> 'DEFAULT',
        MQTT = <any> 'MQTT',
        LWM2M = <any> 'LWM2M',
        COAP = <any> 'COAP'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        DEFAULT = <any> 'DEFAULT'
    }
}

/**
 * 
 * @export
 * @interface DeviceProfileProvisionConfiguration
 */
export interface DeviceProfileProvisionConfiguration {
    /**
     * 
     * @type {string}
     * @memberof DeviceProfileProvisionConfiguration
     */
    provisionDeviceSecret?: string;
}

/**
 * 
 * @export
 * @interface DeviceProfileTransportConfiguration
 */
export interface DeviceProfileTransportConfiguration {
}

/**
 * 
 * @export
 * @interface DeviceSearchQuery
 */
export interface DeviceSearchQuery {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceSearchQuery
     */
    deviceTypes?: Array<string>;
    /**
     * 
     * @type {RelationsSearchParameters}
     * @memberof DeviceSearchQuery
     */
    parameters?: RelationsSearchParameters;
    /**
     * 
     * @type {string}
     * @memberof DeviceSearchQuery
     */
    relationType?: string;
}

/**
 * 
 * @export
 * @interface DeviceTransportConfiguration
 */
export interface DeviceTransportConfiguration {
}

/**
 * 
 * @export
 * @interface DomainInfo
 */
export interface DomainInfo {
    /**
     * 
     * @type {string}
     * @memberof DomainInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInfo
     */
    scheme?: DomainInfo.SchemeEnum;
}

/**
 * @export
 * @namespace DomainInfo
 */
export namespace DomainInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum SchemeEnum {
        HTTP = <any> 'HTTP',
        HTTPS = <any> 'HTTPS',
        MIXED = <any> 'MIXED'
    }
}

/**
 * 
 * @export
 * @interface EntityCountQuery
 */
export interface EntityCountQuery {
    /**
     * 
     * @type {EntityFilter}
     * @memberof EntityCountQuery
     */
    entityFilter?: EntityFilter;
    /**
     * 
     * @type {Array<KeyFilter>}
     * @memberof EntityCountQuery
     */
    keyFilters?: Array<KeyFilter>;
}

/**
 * 
 * @export
 * @interface EntityData
 */
export interface EntityData {
    /**
     * 
     * @type {EntityId}
     * @memberof EntityData
     */
    entityId?: EntityId;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: TsValue; }; }}
     * @memberof EntityData
     */
    latest?: { [key: string]: { [key: string]: TsValue; }; };
    /**
     * 
     * @type {boolean}
     * @memberof EntityData
     */
    readAttrs?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityData
     */
    readTs?: boolean;
    /**
     * 
     * @type {{ [key: string]: Array<TsValue>; }}
     * @memberof EntityData
     */
    timeseries?: { [key: string]: Array<TsValue>; };
}

/**
 * 
 * @export
 * @interface EntityDataPageLink
 */
export interface EntityDataPageLink {
    /**
     * 
     * @type {number}
     * @memberof EntityDataPageLink
     */
    pageSize: number;
    /**
     * 
     * @type {number}
     * @memberof EntityDataPageLink
     */
    page: number;
    /**
     * 
     * @type {string}
     * @memberof EntityDataPageLink
     */
    textSearch: string;
    /**
     * 
     * @type {EntityDataSortOrder}
     * @memberof EntityDataPageLink
     */
    sortOrder: EntityDataSortOrder;
    /**
     * 
     * @type {boolean}
     * @memberof EntityDataPageLink
     */
    dynamic: boolean;
}

/**
 * 
 * @export
 * @interface EntityDataQuery
 */
export interface EntityDataQuery {
    /**
     * 
     * @type {Array<EntityKey>}
     * @memberof EntityDataQuery
     */
    entityFields?: Array<EntityKey>;
    /**
     * 
     * @type {EntityFilter}
     * @memberof EntityDataQuery
     */
    entityFilter?: EntityFilter;
    /**
     * 
     * @type {Array<KeyFilter>}
     * @memberof EntityDataQuery
     */
    keyFilters?: Array<KeyFilter>;
    /**
     * 
     * @type {Array<EntityKey>}
     * @memberof EntityDataQuery
     */
    latestValues?: Array<EntityKey>;
    /**
     * 
     * @type {EntityDataPageLink}
     * @memberof EntityDataQuery
     */
    pageLink?: EntityDataPageLink;
}

/**
 * 
 * @export
 * @interface EntityDataSortOrder
 */
export interface EntityDataSortOrder {
    /**
     * 
     * @type {string}
     * @memberof EntityDataSortOrder
     */
    direction?: EntityDataSortOrder.DirectionEnum;
    /**
     * 
     * @type {EntityKey}
     * @memberof EntityDataSortOrder
     */
    key?: EntityKey;
}

/**
 * @export
 * @namespace EntityDataSortOrder
 */
export namespace EntityDataSortOrder {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        ASC = <any> 'ASC',
        DESC = <any> 'DESC'
    }
}

/**
 * 
 * @export
 * @interface EntityFilter
 */
export interface EntityFilter {
}

/**
 * 
 * @export
 * @interface EntityGroup
 */
export interface EntityGroup {
    /**
     * 
     * @type {string}
     * @memberof EntityGroup
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityGroup
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityGroup
     */
    createdTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EntityGroup
     */
    groupAll?: boolean;
    /**
     * 
     * @type {EntityGroupId}
     * @memberof EntityGroup
     */
    id?: EntityGroupId;
    /**
     * 
     * @type {string}
     * @memberof EntityGroup
     */
    name: string;
    /**
     * 
     * @type {EntityId}
     * @memberof EntityGroup
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof EntityGroup
     */
    type: EntityGroup.TypeEnum;
}

/**
 * @export
 * @namespace EntityGroup
 */
export namespace EntityGroup {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CUSTOMER = <any> 'CUSTOMER',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        USER = <any> 'USER',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        DASHBOARD = <any> 'DASHBOARD'
    }
}

/**
 * 
 * @export
 * @interface EntityGroupId
 */
export interface EntityGroupId {
    /**
     * 
     * @type {string}
     * @memberof EntityGroupId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface EntityGroupInfo
 */
export interface EntityGroupInfo {
    /**
     * 
     * @type {string}
     * @memberof EntityGroupInfo
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityGroupInfo
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityGroupInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EntityGroupInfo
     */
    groupAll?: boolean;
    /**
     * 
     * @type {EntityGroupId}
     * @memberof EntityGroupInfo
     */
    id?: EntityGroupId;
    /**
     * 
     * @type {string}
     * @memberof EntityGroupInfo
     */
    name: string;
    /**
     * 
     * @type {EntityId}
     * @memberof EntityGroupInfo
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {Array<EntityId>}
     * @memberof EntityGroupInfo
     */
    ownerIds?: Array<EntityId>;
    /**
     * 
     * @type {string}
     * @memberof EntityGroupInfo
     */
    type: EntityGroupInfo.TypeEnum;
}

/**
 * @export
 * @namespace EntityGroupInfo
 */
export namespace EntityGroupInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CUSTOMER = <any> 'CUSTOMER',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        USER = <any> 'USER',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        DASHBOARD = <any> 'DASHBOARD'
    }
}

/**
 * 
 * @export
 * @interface EntityId
 */
export interface EntityId {
    /**
     * 
     * @type {string}
     * @memberof EntityId
     */
    entityType?: EntityId.EntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityId
     */
    id?: string;
}

/**
 * @export
 * @namespace EntityId
 */
export namespace EntityId {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityTypeEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
}

/**
 * 
 * @export
 * @interface EntityInfo
 */
export interface EntityInfo {
    /**
     * 
     * @type {EntityId}
     * @memberof EntityInfo
     */
    id?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof EntityInfo
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface EntityKey
 */
export interface EntityKey {
    /**
     * 
     * @type {string}
     * @memberof EntityKey
     */
    type: EntityKey.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityKey
     */
    key: string;
}

/**
 * @export
 * @namespace EntityKey
 */
export namespace EntityKey {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ATTRIBUTE = <any> 'ATTRIBUTE',
        CLIENTATTRIBUTE = <any> 'CLIENT_ATTRIBUTE',
        SHAREDATTRIBUTE = <any> 'SHARED_ATTRIBUTE',
        SERVERATTRIBUTE = <any> 'SERVER_ATTRIBUTE',
        TIMESERIES = <any> 'TIME_SERIES',
        ENTITYFIELD = <any> 'ENTITY_FIELD',
        ALARMFIELD = <any> 'ALARM_FIELD'
    }
}

/**
 * 
 * @export
 * @interface EntityRelation
 */
export interface EntityRelation {
    /**
     * 
     * @type {string}
     * @memberof EntityRelation
     */
    additionalInfo?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof EntityRelation
     */
    from?: EntityId;
    /**
     * 
     * @type {EntityId}
     * @memberof EntityRelation
     */
    to?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof EntityRelation
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityRelation
     */
    typeGroup?: EntityRelation.TypeGroupEnum;
}

/**
 * @export
 * @namespace EntityRelation
 */
export namespace EntityRelation {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeGroupEnum {
        COMMON = <any> 'COMMON',
        ALARM = <any> 'ALARM',
        DASHBOARD = <any> 'DASHBOARD',
        TOENTITYGROUP = <any> 'TO_ENTITY_GROUP',
        FROMENTITYGROUP = <any> 'FROM_ENTITY_GROUP',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE'
    }
}

/**
 * 
 * @export
 * @interface EntityRelationInfo
 */
export interface EntityRelationInfo {
    /**
     * 
     * @type {string}
     * @memberof EntityRelationInfo
     */
    additionalInfo?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof EntityRelationInfo
     */
    from?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof EntityRelationInfo
     */
    fromName?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof EntityRelationInfo
     */
    to?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof EntityRelationInfo
     */
    toName?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityRelationInfo
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityRelationInfo
     */
    typeGroup?: EntityRelationInfo.TypeGroupEnum;
}

/**
 * @export
 * @namespace EntityRelationInfo
 */
export namespace EntityRelationInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeGroupEnum {
        COMMON = <any> 'COMMON',
        ALARM = <any> 'ALARM',
        DASHBOARD = <any> 'DASHBOARD',
        TOENTITYGROUP = <any> 'TO_ENTITY_GROUP',
        FROMENTITYGROUP = <any> 'FROM_ENTITY_GROUP',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE'
    }
}

/**
 * 
 * @export
 * @interface EntityRelationsQuery
 */
export interface EntityRelationsQuery {
    /**
     * 
     * @type {Array<RelationEntityTypeFilter>}
     * @memberof EntityRelationsQuery
     */
    filters?: Array<RelationEntityTypeFilter>;
    /**
     * 
     * @type {RelationsSearchParameters}
     * @memberof EntityRelationsQuery
     */
    parameters?: RelationsSearchParameters;
}

/**
 * 
 * @export
 * @interface EntitySubtype
 */
export interface EntitySubtype {
    /**
     * 
     * @type {string}
     * @memberof EntitySubtype
     */
    entityType?: EntitySubtype.EntityTypeEnum;
    /**
     * 
     * @type {TenantId}
     * @memberof EntitySubtype
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof EntitySubtype
     */
    type?: string;
}

/**
 * @export
 * @namespace EntitySubtype
 */
export namespace EntitySubtype {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityTypeEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
}

/**
 * 
 * @export
 * @interface EntityView
 */
export interface EntityView {
    /**
     * 
     * @type {string}
     * @memberof EntityView
     */
    additionalInfo?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityView
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof EntityView
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {number}
     * @memberof EntityView
     */
    endTimeMs?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof EntityView
     */
    entityId?: EntityId;
    /**
     * 
     * @type {EntityViewId}
     * @memberof EntityView
     */
    id?: EntityViewId;
    /**
     * 
     * @type {TelemetryEntityView}
     * @memberof EntityView
     */
    keys?: TelemetryEntityView;
    /**
     * 
     * @type {string}
     * @memberof EntityView
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof EntityView
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {number}
     * @memberof EntityView
     */
    startTimeMs?: number;
    /**
     * 
     * @type {TenantId}
     * @memberof EntityView
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof EntityView
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface EntityViewId
 */
export interface EntityViewId {
    /**
     * 
     * @type {string}
     * @memberof EntityViewId
     */
    entityType?: EntityViewId.EntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityViewId
     */
    id: string;
}

/**
 * @export
 * @namespace EntityViewId
 */
export namespace EntityViewId {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityTypeEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
}

/**
 * 
 * @export
 * @interface EntityViewSearchQuery
 */
export interface EntityViewSearchQuery {
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityViewSearchQuery
     */
    entityViewTypes?: Array<string>;
    /**
     * 
     * @type {RelationsSearchParameters}
     * @memberof EntityViewSearchQuery
     */
    parameters?: RelationsSearchParameters;
    /**
     * 
     * @type {string}
     * @memberof EntityViewSearchQuery
     */
    relationType?: string;
}

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    body?: string;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    createdTime?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof Event
     */
    entityId?: EntityId;
    /**
     * 
     * @type {EventId}
     * @memberof Event
     */
    id?: EventId;
    /**
     * 
     * @type {TenantId}
     * @memberof Event
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    uid?: string;
}

/**
 * 
 * @export
 * @interface EventId
 */
export interface EventId {
    /**
     * 
     * @type {string}
     * @memberof EventId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface Favicon
 */
export interface Favicon {
    /**
     * 
     * @type {string}
     * @memberof Favicon
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Favicon
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface GroupPermission
 */
export interface GroupPermission {
    /**
     * 
     * @type {number}
     * @memberof GroupPermission
     */
    createdTime?: number;
    /**
     * 
     * @type {EntityGroupId}
     * @memberof GroupPermission
     */
    entityGroupId?: EntityGroupId;
    /**
     * 
     * @type {string}
     * @memberof GroupPermission
     */
    entityGroupType?: GroupPermission.EntityGroupTypeEnum;
    /**
     * 
     * @type {GroupPermissionId}
     * @memberof GroupPermission
     */
    id?: GroupPermissionId;
    /**
     * 
     * @type {string}
     * @memberof GroupPermission
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupPermission
     */
    _public?: boolean;
    /**
     * 
     * @type {RoleId}
     * @memberof GroupPermission
     */
    roleId?: RoleId;
    /**
     * 
     * @type {TenantId}
     * @memberof GroupPermission
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {EntityGroupId}
     * @memberof GroupPermission
     */
    userGroupId?: EntityGroupId;
    /**
     * 
     * @type {boolean}
     * @memberof GroupPermission
     */
    isPublic: boolean;
}

/**
 * @export
 * @namespace GroupPermission
 */
export namespace GroupPermission {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityGroupTypeEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
}

/**
 * 
 * @export
 * @interface GroupPermissionId
 */
export interface GroupPermissionId {
    /**
     * 
     * @type {string}
     * @memberof GroupPermissionId
     */
    entityType?: GroupPermissionId.EntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GroupPermissionId
     */
    id?: string;
}

/**
 * @export
 * @namespace GroupPermissionId
 */
export namespace GroupPermissionId {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityTypeEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
}

/**
 * 
 * @export
 * @interface GroupPermissionInfo
 */
export interface GroupPermissionInfo {
    /**
     * 
     * @type {number}
     * @memberof GroupPermissionInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {EntityGroupId}
     * @memberof GroupPermissionInfo
     */
    entityGroupId?: EntityGroupId;
    /**
     * 
     * @type {string}
     * @memberof GroupPermissionInfo
     */
    entityGroupName?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof GroupPermissionInfo
     */
    entityGroupOwnerId?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof GroupPermissionInfo
     */
    entityGroupOwnerName?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPermissionInfo
     */
    entityGroupType?: GroupPermissionInfo.EntityGroupTypeEnum;
    /**
     * 
     * @type {GroupPermissionId}
     * @memberof GroupPermissionInfo
     */
    id?: GroupPermissionId;
    /**
     * 
     * @type {string}
     * @memberof GroupPermissionInfo
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupPermissionInfo
     */
    _public?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GroupPermissionInfo
     */
    readOnly?: boolean;
    /**
     * 
     * @type {Role}
     * @memberof GroupPermissionInfo
     */
    role?: Role;
    /**
     * 
     * @type {RoleId}
     * @memberof GroupPermissionInfo
     */
    roleId?: RoleId;
    /**
     * 
     * @type {TenantId}
     * @memberof GroupPermissionInfo
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {EntityGroupId}
     * @memberof GroupPermissionInfo
     */
    userGroupId?: EntityGroupId;
    /**
     * 
     * @type {string}
     * @memberof GroupPermissionInfo
     */
    userGroupName?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof GroupPermissionInfo
     */
    userGroupOwnerId?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof GroupPermissionInfo
     */
    userGroupOwnerName?: string;
}

/**
 * @export
 * @namespace GroupPermissionInfo
 */
export namespace GroupPermissionInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityGroupTypeEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
}

/**
 * 
 * @export
 * @interface HomeDashboard
 */
export interface HomeDashboard {
    /**
     * 
     * @type {Array<ShortCustomerInfo>}
     * @memberof HomeDashboard
     */
    assignedCustomers?: Array<ShortCustomerInfo>;
    /**
     * 
     * @type {string}
     * @memberof HomeDashboard
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof HomeDashboard
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof HomeDashboard
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {boolean}
     * @memberof HomeDashboard
     */
    hideDashboardToolbar?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HomeDashboard
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof HomeDashboard
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {TenantId}
     * @memberof HomeDashboard
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof HomeDashboard
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface HomeDashboardInfo
 */
export interface HomeDashboardInfo {
    /**
     * 
     * @type {DashboardId}
     * @memberof HomeDashboardInfo
     */
    dashboardId?: DashboardId;
    /**
     * 
     * @type {boolean}
     * @memberof HomeDashboardInfo
     */
    hideDashboardToolbar?: boolean;
}

/**
 * 
 * @export
 * @interface InputStream
 */
export interface InputStream {
}

/**
 * 
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    additionalInfo?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Integration
     */
    allowCreateDevicesOrAssets?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof Integration
     */
    createdTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Integration
     */
    debugMode?: boolean;
    /**
     * 
     * @type {ConverterId}
     * @memberof Integration
     */
    defaultConverterId?: ConverterId;
    /**
     * 
     * @type {ConverterId}
     * @memberof Integration
     */
    downlinkConverterId?: ConverterId;
    /**
     * 
     * @type {boolean}
     * @memberof Integration
     */
    enabled?: boolean;
    /**
     * 
     * @type {IntegrationId}
     * @memberof Integration
     */
    id?: IntegrationId;
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Integration
     */
    remote?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    routingKey?: string;
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    secret?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof Integration
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    type?: Integration.TypeEnum;
}

/**
 * @export
 * @namespace Integration
 */
export namespace Integration {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        OCEANCONNECT = <any> 'OCEANCONNECT',
        SIGFOX = <any> 'SIGFOX',
        THINGPARK = <any> 'THINGPARK',
        TPE = <any> 'TPE',
        CHIRPSTACK = <any> 'CHIRPSTACK',
        TMOBILEIOTCDP = <any> 'TMOBILE_IOT_CDP',
        HTTP = <any> 'HTTP',
        MQTT = <any> 'MQTT',
        PUBSUB = <any> 'PUB_SUB',
        AWSIOT = <any> 'AWS_IOT',
        AWSSQS = <any> 'AWS_SQS',
        AWSKINESIS = <any> 'AWS_KINESIS',
        IBMWATSONIOT = <any> 'IBM_WATSON_IOT',
        TTN = <any> 'TTN',
        TTI = <any> 'TTI',
        AZUREEVENTHUB = <any> 'AZURE_EVENT_HUB',
        OPCUA = <any> 'OPC_UA',
        CUSTOM = <any> 'CUSTOM',
        UDP = <any> 'UDP',
        TCP = <any> 'TCP',
        KAFKA = <any> 'KAFKA',
        AZUREIOTHUB = <any> 'AZURE_IOT_HUB',
        APACHEPULSAR = <any> 'APACHE_PULSAR',
        RABBITMQ = <any> 'RABBITMQ',
        LORIOT = <any> 'LORIOT'
    }
}

/**
 * 
 * @export
 * @interface IntegrationId
 */
export interface IntegrationId {
    /**
     * 
     * @type {string}
     * @memberof IntegrationId
     */
    id: string;
}

/**
 * 
 * @export
 * @interface KeyFilter
 */
export interface KeyFilter {
    /**
     * 
     * @type {EntityKey}
     * @memberof KeyFilter
     */
    key?: EntityKey;
    /**
     * 
     * @type {KeyFilterPredicate}
     * @memberof KeyFilter
     */
    predicate?: KeyFilterPredicate;
    /**
     * 
     * @type {string}
     * @memberof KeyFilter
     */
    valueType?: KeyFilter.ValueTypeEnum;
}

/**
 * @export
 * @namespace KeyFilter
 */
export namespace KeyFilter {
    /**
     * @export
     * @enum {string}
     */
    export enum ValueTypeEnum {
        STRING = <any> 'STRING',
        NUMERIC = <any> 'NUMERIC',
        BOOLEAN = <any> 'BOOLEAN',
        DATETIME = <any> 'DATE_TIME'
    }
}

/**
 * 
 * @export
 * @interface KeyFilterPredicate
 */
export interface KeyFilterPredicate {
}

/**
 * 
 * @export
 * @interface LoginWhiteLabelingParams
 */
export interface LoginWhiteLabelingParams {
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    adminSettingsId?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    appTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    baseUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    customCss?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginWhiteLabelingParams
     */
    darkForeground?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    domainName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginWhiteLabelingParams
     */
    enableHelpLinks?: boolean;
    /**
     * 
     * @type {Favicon}
     * @memberof LoginWhiteLabelingParams
     */
    favicon?: Favicon;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    faviconChecksum?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    helpLinkBaseUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    logoImageChecksum?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginWhiteLabelingParams
     */
    logoImageHeight?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    logoImageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    pageBackgroundColor?: string;
    /**
     * 
     * @type {PaletteSettings}
     * @memberof LoginWhiteLabelingParams
     */
    paletteSettings?: PaletteSettings;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    platformName?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginWhiteLabelingParams
     */
    platformVersion?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginWhiteLabelingParams
     */
    prohibitDifferentUrl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoginWhiteLabelingParams
     */
    showNameBottom?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoginWhiteLabelingParams
     */
    showNameVersion?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoginWhiteLabelingParams
     */
    whiteLabelingEnabled?: boolean;
}

/**
 * 
 * @export
 * @interface MapstringTsValue
 */
export interface MapstringTsValue {
    [key: string]: TsValue;

}

/**
 * 
 * @export
 * @interface MergedGroupPermissionInfo
 */
export interface MergedGroupPermissionInfo {
    /**
     * 
     * @type {string}
     * @memberof MergedGroupPermissionInfo
     */
    entityType?: MergedGroupPermissionInfo.EntityTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof MergedGroupPermissionInfo
     */
    operations?: Array<MergedGroupPermissionInfo.OperationsEnum>;
}

/**
 * @export
 * @namespace MergedGroupPermissionInfo
 */
export namespace MergedGroupPermissionInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityTypeEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OperationsEnum {
        ALL = <any> 'ALL',
        CREATE = <any> 'CREATE',
        READ = <any> 'READ',
        WRITE = <any> 'WRITE',
        DELETE = <any> 'DELETE',
        RPCCALL = <any> 'RPC_CALL',
        READCREDENTIALS = <any> 'READ_CREDENTIALS',
        WRITECREDENTIALS = <any> 'WRITE_CREDENTIALS',
        READATTRIBUTES = <any> 'READ_ATTRIBUTES',
        WRITEATTRIBUTES = <any> 'WRITE_ATTRIBUTES',
        READTELEMETRY = <any> 'READ_TELEMETRY',
        WRITETELEMETRY = <any> 'WRITE_TELEMETRY',
        ADDTOGROUP = <any> 'ADD_TO_GROUP',
        REMOVEFROMGROUP = <any> 'REMOVE_FROM_GROUP',
        CHANGEOWNER = <any> 'CHANGE_OWNER',
        IMPERSONATE = <any> 'IMPERSONATE',
        CLAIMDEVICES = <any> 'CLAIM_DEVICES',
        SHAREGROUP = <any> 'SHARE_GROUP',
        ASSIGNTOTENANT = <any> 'ASSIGN_TO_TENANT'
    }
}

/**
 * 
 * @export
 * @interface MergedGroupTypePermissionInfo
 */
export interface MergedGroupTypePermissionInfo {
    /**
     * 
     * @type {Array<EntityGroupId>}
     * @memberof MergedGroupTypePermissionInfo
     */
    entityGroupIds?: Array<EntityGroupId>;
    /**
     * 
     * @type {boolean}
     * @memberof MergedGroupTypePermissionInfo
     */
    hasGenericRead?: boolean;
}

/**
 * 
 * @export
 * @interface MergedUserPermissions
 */
export interface MergedUserPermissions {
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof MergedUserPermissions
     */
    genericPermissions?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {{ [key: string]: MergedGroupPermissionInfo; }}
     * @memberof MergedUserPermissions
     */
    groupPermissions?: { [key: string]: MergedGroupPermissionInfo; };
    /**
     * 
     * @type {{ [key: string]: MergedGroupTypePermissionInfo; }}
     * @memberof MergedUserPermissions
     */
    readAttrPermissions?: { [key: string]: MergedGroupTypePermissionInfo; };
    /**
     * 
     * @type {{ [key: string]: MergedGroupTypePermissionInfo; }}
     * @memberof MergedUserPermissions
     */
    readEntityPermissions?: { [key: string]: MergedGroupTypePermissionInfo; };
    /**
     * 
     * @type {{ [key: string]: MergedGroupTypePermissionInfo; }}
     * @memberof MergedUserPermissions
     */
    readGroupPermissions?: { [key: string]: MergedGroupTypePermissionInfo; };
    /**
     * 
     * @type {{ [key: string]: MergedGroupTypePermissionInfo; }}
     * @memberof MergedUserPermissions
     */
    readTsPermissions?: { [key: string]: MergedGroupTypePermissionInfo; };
}

/**
 * @export
 * @namespace MergedUserPermissions
 */
export namespace MergedUserPermissions {
    /**
     * @export
     * @enum {string}
     */
    export enum GenericPermissionsEnum {
        ALL = <any> 'ALL',
        CREATE = <any> 'CREATE',
        READ = <any> 'READ',
        WRITE = <any> 'WRITE',
        DELETE = <any> 'DELETE',
        RPCCALL = <any> 'RPC_CALL',
        READCREDENTIALS = <any> 'READ_CREDENTIALS',
        WRITECREDENTIALS = <any> 'WRITE_CREDENTIALS',
        READATTRIBUTES = <any> 'READ_ATTRIBUTES',
        WRITEATTRIBUTES = <any> 'WRITE_ATTRIBUTES',
        READTELEMETRY = <any> 'READ_TELEMETRY',
        WRITETELEMETRY = <any> 'WRITE_TELEMETRY',
        ADDTOGROUP = <any> 'ADD_TO_GROUP',
        REMOVEFROMGROUP = <any> 'REMOVE_FROM_GROUP',
        CHANGEOWNER = <any> 'CHANGE_OWNER',
        IMPERSONATE = <any> 'IMPERSONATE',
        CLAIMDEVICES = <any> 'CLAIM_DEVICES',
        SHAREGROUP = <any> 'SHARE_GROUP',
        ASSIGNTOTENANT = <any> 'ASSIGN_TO_TENANT'
    }
}

/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    absolute?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ModelFile
     */
    absoluteFile?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    absolutePath?: string;
    /**
     * 
     * @type {any}
     * @memberof ModelFile
     */
    canonicalFile?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    canonicalPath?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    directory?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    file?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    freeSpace?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    hidden?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    parent?: string;
    /**
     * 
     * @type {any}
     * @memberof ModelFile
     */
    parentFile?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    path?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    totalSpace?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    usableSpace?: number;
}

/**
 * 
 * @export
 * @interface NodeConnectionInfo
 */
export interface NodeConnectionInfo {
    /**
     * 
     * @type {number}
     * @memberof NodeConnectionInfo
     */
    fromIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeConnectionInfo
     */
    toIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof NodeConnectionInfo
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface OAuth2BasicMapperConfig
 */
export interface OAuth2BasicMapperConfig {
    /**
     * 
     * @type {boolean}
     * @memberof OAuth2BasicMapperConfig
     */
    alwaysFullScreen?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuth2BasicMapperConfig
     */
    customerNamePattern?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2BasicMapperConfig
     */
    defaultDashboardName?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2BasicMapperConfig
     */
    emailAttributeKey?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2BasicMapperConfig
     */
    firstNameAttributeKey?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2BasicMapperConfig
     */
    lastNameAttributeKey?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2BasicMapperConfig
     */
    parentCustomerNamePattern?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2BasicMapperConfig
     */
    tenantNamePattern?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2BasicMapperConfig
     */
    tenantNameStrategy?: OAuth2BasicMapperConfig.TenantNameStrategyEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof OAuth2BasicMapperConfig
     */
    userGroupsNamePattern?: Array<string>;
}

/**
 * @export
 * @namespace OAuth2BasicMapperConfig
 */
export namespace OAuth2BasicMapperConfig {
    /**
     * @export
     * @enum {string}
     */
    export enum TenantNameStrategyEnum {
        DOMAIN = <any> 'DOMAIN',
        EMAIL = <any> 'EMAIL',
        CUSTOM = <any> 'CUSTOM'
    }
}

/**
 * 
 * @export
 * @interface OAuth2ClientInfo
 */
export interface OAuth2ClientInfo {
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientInfo
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface OAuth2ClientRegistrationTemplate
 */
export interface OAuth2ClientRegistrationTemplate {
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    accessTokenUri?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    authorizationUri?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    clientAuthenticationMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    helpLink?: string;
    /**
     * 
     * @type {OAuth2ClientRegistrationTemplateId}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    id?: OAuth2ClientRegistrationTemplateId;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    jwkSetUri?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    loginButtonIcon?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    loginButtonLabel?: string;
    /**
     * 
     * @type {OAuth2MapperConfig}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    mapperConfig?: OAuth2MapperConfig;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    providerId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    scope?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    userInfoUri?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplate
     */
    userNameAttributeName?: string;
}

/**
 * 
 * @export
 * @interface OAuth2ClientRegistrationTemplateId
 */
export interface OAuth2ClientRegistrationTemplateId {
    /**
     * 
     * @type {string}
     * @memberof OAuth2ClientRegistrationTemplateId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface OAuth2ClientsDomainParams
 */
export interface OAuth2ClientsDomainParams {
    /**
     * 
     * @type {Array<ClientRegistrationDto>}
     * @memberof OAuth2ClientsDomainParams
     */
    clientRegistrations?: Array<ClientRegistrationDto>;
    /**
     * 
     * @type {Array<DomainInfo>}
     * @memberof OAuth2ClientsDomainParams
     */
    domainInfos?: Array<DomainInfo>;
}

/**
 * 
 * @export
 * @interface OAuth2ClientsParams
 */
export interface OAuth2ClientsParams {
    /**
     * 
     * @type {Array<OAuth2ClientsDomainParams>}
     * @memberof OAuth2ClientsParams
     */
    domainsParams?: Array<OAuth2ClientsDomainParams>;
    /**
     * 
     * @type {boolean}
     * @memberof OAuth2ClientsParams
     */
    enabled?: boolean;
}

/**
 * 
 * @export
 * @interface OAuth2CustomMapperConfig
 */
export interface OAuth2CustomMapperConfig {
    /**
     * 
     * @type {string}
     * @memberof OAuth2CustomMapperConfig
     */
    password?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuth2CustomMapperConfig
     */
    sendToken?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuth2CustomMapperConfig
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2CustomMapperConfig
     */
    username?: string;
}

/**
 * 
 * @export
 * @interface OAuth2MapperConfig
 */
export interface OAuth2MapperConfig {
    /**
     * 
     * @type {boolean}
     * @memberof OAuth2MapperConfig
     */
    activateUser?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OAuth2MapperConfig
     */
    allowUserCreation?: boolean;
    /**
     * 
     * @type {OAuth2BasicMapperConfig}
     * @memberof OAuth2MapperConfig
     */
    basic?: OAuth2BasicMapperConfig;
    /**
     * 
     * @type {OAuth2CustomMapperConfig}
     * @memberof OAuth2MapperConfig
     */
    custom?: OAuth2CustomMapperConfig;
    /**
     * 
     * @type {string}
     * @memberof OAuth2MapperConfig
     */
    type?: OAuth2MapperConfig.TypeEnum;
}

/**
 * @export
 * @namespace OAuth2MapperConfig
 */
export namespace OAuth2MapperConfig {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        BASIC = <any> 'BASIC',
        CUSTOM = <any> 'CUSTOM',
        GITHUB = <any> 'GITHUB'
    }
}

/**
 * 
 * @export
 * @interface PageDataAlarmData
 */
export interface PageDataAlarmData {
    /**
     * 
     * @type {Array<AlarmData>}
     * @memberof PageDataAlarmData
     */
    data?: Array<AlarmData>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataAlarmData
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataAlarmData
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataAlarmData
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataAlarmInfo
 */
export interface PageDataAlarmInfo {
    /**
     * 
     * @type {Array<AlarmInfo>}
     * @memberof PageDataAlarmInfo
     */
    data?: Array<AlarmInfo>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataAlarmInfo
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataAlarmInfo
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataAlarmInfo
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataAsset
 */
export interface PageDataAsset {
    /**
     * 
     * @type {Array<Asset>}
     * @memberof PageDataAsset
     */
    data?: Array<Asset>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataAsset
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataAsset
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataAsset
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataAuditLog
 */
export interface PageDataAuditLog {
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof PageDataAuditLog
     */
    data?: Array<AuditLog>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataAuditLog
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataAuditLog
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataAuditLog
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataBlobEntityWithCustomerInfo
 */
export interface PageDataBlobEntityWithCustomerInfo {
    /**
     * 
     * @type {Array<BlobEntityWithCustomerInfo>}
     * @memberof PageDataBlobEntityWithCustomerInfo
     */
    data?: Array<BlobEntityWithCustomerInfo>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataBlobEntityWithCustomerInfo
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataBlobEntityWithCustomerInfo
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataBlobEntityWithCustomerInfo
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataContactBasedobject
 */
export interface PageDataContactBasedobject {
    /**
     * 
     * @type {Array<ContactBasedobject>}
     * @memberof PageDataContactBasedobject
     */
    data?: Array<ContactBasedobject>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataContactBasedobject
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataContactBasedobject
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataContactBasedobject
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataConverter
 */
export interface PageDataConverter {
    /**
     * 
     * @type {Array<Converter>}
     * @memberof PageDataConverter
     */
    data?: Array<Converter>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataConverter
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataConverter
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataConverter
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataCustomer
 */
export interface PageDataCustomer {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof PageDataCustomer
     */
    data?: Array<Customer>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataCustomer
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataCustomer
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataCustomer
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataDashboardInfo
 */
export interface PageDataDashboardInfo {
    /**
     * 
     * @type {Array<DashboardInfo>}
     * @memberof PageDataDashboardInfo
     */
    data?: Array<DashboardInfo>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataDashboardInfo
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataDashboardInfo
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataDashboardInfo
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataDevice
 */
export interface PageDataDevice {
    /**
     * 
     * @type {Array<Device>}
     * @memberof PageDataDevice
     */
    data?: Array<Device>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataDevice
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataDevice
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataDevice
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataDeviceProfile
 */
export interface PageDataDeviceProfile {
    /**
     * 
     * @type {Array<DeviceProfile>}
     * @memberof PageDataDeviceProfile
     */
    data?: Array<DeviceProfile>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataDeviceProfile
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataDeviceProfile
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataDeviceProfile
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataDeviceProfileInfo
 */
export interface PageDataDeviceProfileInfo {
    /**
     * 
     * @type {Array<DeviceProfileInfo>}
     * @memberof PageDataDeviceProfileInfo
     */
    data?: Array<DeviceProfileInfo>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataDeviceProfileInfo
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataDeviceProfileInfo
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataDeviceProfileInfo
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataEntityData
 */
export interface PageDataEntityData {
    /**
     * 
     * @type {Array<EntityData>}
     * @memberof PageDataEntityData
     */
    data?: Array<EntityData>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataEntityData
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataEntityData
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataEntityData
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataEntityInfo
 */
export interface PageDataEntityInfo {
    /**
     * 
     * @type {Array<EntityInfo>}
     * @memberof PageDataEntityInfo
     */
    data?: Array<EntityInfo>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataEntityInfo
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataEntityInfo
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataEntityInfo
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataEntityView
 */
export interface PageDataEntityView {
    /**
     * 
     * @type {Array<EntityView>}
     * @memberof PageDataEntityView
     */
    data?: Array<EntityView>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataEntityView
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataEntityView
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataEntityView
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataEvent
 */
export interface PageDataEvent {
    /**
     * 
     * @type {Array<Event>}
     * @memberof PageDataEvent
     */
    data?: Array<Event>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataEvent
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataEvent
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataEvent
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataIntegration
 */
export interface PageDataIntegration {
    /**
     * 
     * @type {Array<Integration>}
     * @memberof PageDataIntegration
     */
    data?: Array<Integration>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataIntegration
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataIntegration
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataIntegration
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataRole
 */
export interface PageDataRole {
    /**
     * 
     * @type {Array<Role>}
     * @memberof PageDataRole
     */
    data?: Array<Role>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataRole
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataRole
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataRole
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataRuleChain
 */
export interface PageDataRuleChain {
    /**
     * 
     * @type {Array<RuleChain>}
     * @memberof PageDataRuleChain
     */
    data?: Array<RuleChain>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataRuleChain
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataRuleChain
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataRuleChain
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataShortEntityView
 */
export interface PageDataShortEntityView {
    /**
     * 
     * @type {Array<ShortEntityView>}
     * @memberof PageDataShortEntityView
     */
    data?: Array<ShortEntityView>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataShortEntityView
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataShortEntityView
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataShortEntityView
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataTenant
 */
export interface PageDataTenant {
    /**
     * 
     * @type {Array<Tenant>}
     * @memberof PageDataTenant
     */
    data?: Array<Tenant>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataTenant
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataTenant
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataTenant
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataTenantInfo
 */
export interface PageDataTenantInfo {
    /**
     * 
     * @type {Array<TenantInfo>}
     * @memberof PageDataTenantInfo
     */
    data?: Array<TenantInfo>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataTenantInfo
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataTenantInfo
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataTenantInfo
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataTenantProfile
 */
export interface PageDataTenantProfile {
    /**
     * 
     * @type {Array<TenantProfile>}
     * @memberof PageDataTenantProfile
     */
    data?: Array<TenantProfile>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataTenantProfile
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataTenantProfile
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataTenantProfile
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataUser
 */
export interface PageDataUser {
    /**
     * 
     * @type {Array<User>}
     * @memberof PageDataUser
     */
    data?: Array<User>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataUser
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataUser
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataUser
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageDataWidgetsBundle
 */
export interface PageDataWidgetsBundle {
    /**
     * 
     * @type {Array<WidgetsBundle>}
     * @memberof PageDataWidgetsBundle
     */
    data?: Array<WidgetsBundle>;
    /**
     * 
     * @type {boolean}
     * @memberof PageDataWidgetsBundle
     */
    hasNext?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDataWidgetsBundle
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDataWidgetsBundle
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface Palette
 */
export interface Palette {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Palette
     */
    colors?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Palette
     */
    _extends?: string;
    /**
     * 
     * @type {string}
     * @memberof Palette
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface PaletteSettings
 */
export interface PaletteSettings {
    /**
     * 
     * @type {Palette}
     * @memberof PaletteSettings
     */
    accentPalette?: Palette;
    /**
     * 
     * @type {Palette}
     * @memberof PaletteSettings
     */
    primaryPalette?: Palette;
}

/**
 * 
 * @export
 * @interface RelationEntityTypeFilter
 */
export interface RelationEntityTypeFilter {
    /**
     * 
     * @type {string}
     * @memberof RelationEntityTypeFilter
     */
    relationType: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RelationEntityTypeFilter
     */
    entityTypes: Array<RelationEntityTypeFilter.EntityTypesEnum>;
}

/**
 * @export
 * @namespace RelationEntityTypeFilter
 */
export namespace RelationEntityTypeFilter {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityTypesEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
}

/**
 * 
 * @export
 * @interface RelationsSearchParameters
 */
export interface RelationsSearchParameters {
    /**
     * 
     * @type {EntityId}
     * @memberof RelationsSearchParameters
     */
    entityId?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof RelationsSearchParameters
     */
    rootId: string;
    /**
     * 
     * @type {string}
     * @memberof RelationsSearchParameters
     */
    rootType: RelationsSearchParameters.RootTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RelationsSearchParameters
     */
    direction: RelationsSearchParameters.DirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof RelationsSearchParameters
     */
    relationTypeGroup: RelationsSearchParameters.RelationTypeGroupEnum;
    /**
     * 
     * @type {number}
     * @memberof RelationsSearchParameters
     */
    maxLevel: number;
    /**
     * 
     * @type {boolean}
     * @memberof RelationsSearchParameters
     */
    fetchLastLevelOnly: boolean;
}

/**
 * @export
 * @namespace RelationsSearchParameters
 */
export namespace RelationsSearchParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum RootTypeEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        FROM = <any> 'FROM',
        TO = <any> 'TO'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RelationTypeGroupEnum {
        COMMON = <any> 'COMMON',
        ALARM = <any> 'ALARM',
        DASHBOARD = <any> 'DASHBOARD',
        TOENTITYGROUP = <any> 'TO_ENTITY_GROUP',
        FROMENTITYGROUP = <any> 'FROM_ENTITY_GROUP',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE'
    }
}

/**
 * 
 * @export
 * @interface ReportConfig
 */
export interface ReportConfig {
    /**
     * 
     * @type {string}
     * @memberof ReportConfig
     */
    baseUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportConfig
     */
    dashboardId?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportConfig
     */
    namePattern?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportConfig
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportConfig
     */
    timewindow?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportConfig
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportConfig
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReportConfig
     */
    useCurrentUserCredentials?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReportConfig
     */
    useDashboardTimewindow?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ReportConfig
     */
    userId?: string;
}

/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof Resource
     */
    file?: any;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    filename?: string;
    /**
     * 
     * @type {InputStream}
     * @memberof Resource
     */
    inputStream?: InputStream;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    open?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    readable?: boolean;
    /**
     * 
     * @type {URI}
     * @memberof Resource
     */
    uri?: URI;
    /**
     * 
     * @type {URL}
     * @memberof Resource
     */
    url?: URL;
}

/**
 * 
 * @export
 * @interface ResponseEntity
 */
export interface ResponseEntity {
    /**
     * 
     * @type {any}
     * @memberof ResponseEntity
     */
    body?: any;
    /**
     * 
     * @type {string}
     * @memberof ResponseEntity
     */
    statusCode?: ResponseEntity.StatusCodeEnum;
    /**
     * 
     * @type {number}
     * @memberof ResponseEntity
     */
    statusCodeValue?: number;
}

/**
 * @export
 * @namespace ResponseEntity
 */
export namespace ResponseEntity {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusCodeEnum {
        _100CONTINUE = <any> '100 CONTINUE',
        _101SWITCHINGPROTOCOLS = <any> '101 SWITCHING_PROTOCOLS',
        _102PROCESSING = <any> '102 PROCESSING',
        _103CHECKPOINT = <any> '103 CHECKPOINT',
        _200OK = <any> '200 OK',
        _201CREATED = <any> '201 CREATED',
        _202ACCEPTED = <any> '202 ACCEPTED',
        _203NONAUTHORITATIVEINFORMATION = <any> '203 NON_AUTHORITATIVE_INFORMATION',
        _204NOCONTENT = <any> '204 NO_CONTENT',
        _205RESETCONTENT = <any> '205 RESET_CONTENT',
        _206PARTIALCONTENT = <any> '206 PARTIAL_CONTENT',
        _207MULTISTATUS = <any> '207 MULTI_STATUS',
        _208ALREADYREPORTED = <any> '208 ALREADY_REPORTED',
        _226IMUSED = <any> '226 IM_USED',
        _300MULTIPLECHOICES = <any> '300 MULTIPLE_CHOICES',
        _301MOVEDPERMANENTLY = <any> '301 MOVED_PERMANENTLY',
        _302FOUND = <any> '302 FOUND',
        _302MOVEDTEMPORARILY = <any> '302 MOVED_TEMPORARILY',
        _303SEEOTHER = <any> '303 SEE_OTHER',
        _304NOTMODIFIED = <any> '304 NOT_MODIFIED',
        _305USEPROXY = <any> '305 USE_PROXY',
        _307TEMPORARYREDIRECT = <any> '307 TEMPORARY_REDIRECT',
        _308PERMANENTREDIRECT = <any> '308 PERMANENT_REDIRECT',
        _400BADREQUEST = <any> '400 BAD_REQUEST',
        _401UNAUTHORIZED = <any> '401 UNAUTHORIZED',
        _402PAYMENTREQUIRED = <any> '402 PAYMENT_REQUIRED',
        _403FORBIDDEN = <any> '403 FORBIDDEN',
        _404NOTFOUND = <any> '404 NOT_FOUND',
        _405METHODNOTALLOWED = <any> '405 METHOD_NOT_ALLOWED',
        _406NOTACCEPTABLE = <any> '406 NOT_ACCEPTABLE',
        _407PROXYAUTHENTICATIONREQUIRED = <any> '407 PROXY_AUTHENTICATION_REQUIRED',
        _408REQUESTTIMEOUT = <any> '408 REQUEST_TIMEOUT',
        _409CONFLICT = <any> '409 CONFLICT',
        _410GONE = <any> '410 GONE',
        _411LENGTHREQUIRED = <any> '411 LENGTH_REQUIRED',
        _412PRECONDITIONFAILED = <any> '412 PRECONDITION_FAILED',
        _413PAYLOADTOOLARGE = <any> '413 PAYLOAD_TOO_LARGE',
        _413REQUESTENTITYTOOLARGE = <any> '413 REQUEST_ENTITY_TOO_LARGE',
        _414URITOOLONG = <any> '414 URI_TOO_LONG',
        _414REQUESTURITOOLONG = <any> '414 REQUEST_URI_TOO_LONG',
        _415UNSUPPORTEDMEDIATYPE = <any> '415 UNSUPPORTED_MEDIA_TYPE',
        _416REQUESTEDRANGENOTSATISFIABLE = <any> '416 REQUESTED_RANGE_NOT_SATISFIABLE',
        _417EXPECTATIONFAILED = <any> '417 EXPECTATION_FAILED',
        _418IAMATEAPOT = <any> '418 I_AM_A_TEAPOT',
        _419INSUFFICIENTSPACEONRESOURCE = <any> '419 INSUFFICIENT_SPACE_ON_RESOURCE',
        _420METHODFAILURE = <any> '420 METHOD_FAILURE',
        _421DESTINATIONLOCKED = <any> '421 DESTINATION_LOCKED',
        _422UNPROCESSABLEENTITY = <any> '422 UNPROCESSABLE_ENTITY',
        _423LOCKED = <any> '423 LOCKED',
        _424FAILEDDEPENDENCY = <any> '424 FAILED_DEPENDENCY',
        _425TOOEARLY = <any> '425 TOO_EARLY',
        _426UPGRADEREQUIRED = <any> '426 UPGRADE_REQUIRED',
        _428PRECONDITIONREQUIRED = <any> '428 PRECONDITION_REQUIRED',
        _429TOOMANYREQUESTS = <any> '429 TOO_MANY_REQUESTS',
        _431REQUESTHEADERFIELDSTOOLARGE = <any> '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
        _451UNAVAILABLEFORLEGALREASONS = <any> '451 UNAVAILABLE_FOR_LEGAL_REASONS',
        _500INTERNALSERVERERROR = <any> '500 INTERNAL_SERVER_ERROR',
        _501NOTIMPLEMENTED = <any> '501 NOT_IMPLEMENTED',
        _502BADGATEWAY = <any> '502 BAD_GATEWAY',
        _503SERVICEUNAVAILABLE = <any> '503 SERVICE_UNAVAILABLE',
        _504GATEWAYTIMEOUT = <any> '504 GATEWAY_TIMEOUT',
        _505HTTPVERSIONNOTSUPPORTED = <any> '505 HTTP_VERSION_NOT_SUPPORTED',
        _506VARIANTALSONEGOTIATES = <any> '506 VARIANT_ALSO_NEGOTIATES',
        _507INSUFFICIENTSTORAGE = <any> '507 INSUFFICIENT_STORAGE',
        _508LOOPDETECTED = <any> '508 LOOP_DETECTED',
        _509BANDWIDTHLIMITEXCEEDED = <any> '509 BANDWIDTH_LIMIT_EXCEEDED',
        _510NOTEXTENDED = <any> '510 NOT_EXTENDED',
        _511NETWORKAUTHENTICATIONREQUIRED = <any> '511 NETWORK_AUTHENTICATION_REQUIRED'
    }
}

/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    additionalInfo?: string;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof Role
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {RoleId}
     * @memberof Role
     */
    id?: RoleId;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof Role
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    permissions?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof Role
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    type?: Role.TypeEnum;
}

/**
 * @export
 * @namespace Role
 */
export namespace Role {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        GENERIC = <any> 'GENERIC',
        GROUP = <any> 'GROUP'
    }
}

/**
 * 
 * @export
 * @interface RoleId
 */
export interface RoleId {
    /**
     * 
     * @type {string}
     * @memberof RoleId
     */
    entityType?: RoleId.EntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RoleId
     */
    id?: string;
}

/**
 * @export
 * @namespace RoleId
 */
export namespace RoleId {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityTypeEnum {
        TENANT = <any> 'TENANT',
        CUSTOMER = <any> 'CUSTOMER',
        USER = <any> 'USER',
        DASHBOARD = <any> 'DASHBOARD',
        ASSET = <any> 'ASSET',
        DEVICE = <any> 'DEVICE',
        ALARM = <any> 'ALARM',
        ENTITYGROUP = <any> 'ENTITY_GROUP',
        CONVERTER = <any> 'CONVERTER',
        INTEGRATION = <any> 'INTEGRATION',
        RULECHAIN = <any> 'RULE_CHAIN',
        RULENODE = <any> 'RULE_NODE',
        SCHEDULEREVENT = <any> 'SCHEDULER_EVENT',
        BLOBENTITY = <any> 'BLOB_ENTITY',
        ENTITYVIEW = <any> 'ENTITY_VIEW',
        WIDGETSBUNDLE = <any> 'WIDGETS_BUNDLE',
        WIDGETTYPE = <any> 'WIDGET_TYPE',
        ROLE = <any> 'ROLE',
        GROUPPERMISSION = <any> 'GROUP_PERMISSION',
        TENANTPROFILE = <any> 'TENANT_PROFILE',
        DEVICEPROFILE = <any> 'DEVICE_PROFILE',
        APIUSAGESTATE = <any> 'API_USAGE_STATE'
    }
}

/**
 * 
 * @export
 * @interface RuleChain
 */
export interface RuleChain {
    /**
     * 
     * @type {string}
     * @memberof RuleChain
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleChain
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof RuleChain
     */
    createdTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RuleChain
     */
    debugMode?: boolean;
    /**
     * 
     * @type {RuleNodeId}
     * @memberof RuleChain
     */
    firstRuleNodeId?: RuleNodeId;
    /**
     * 
     * @type {RuleChainId}
     * @memberof RuleChain
     */
    id?: RuleChainId;
    /**
     * 
     * @type {string}
     * @memberof RuleChain
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RuleChain
     */
    root?: boolean;
    /**
     * 
     * @type {TenantId}
     * @memberof RuleChain
     */
    tenantId?: TenantId;
}

/**
 * 
 * @export
 * @interface RuleChainConnectionInfo
 */
export interface RuleChainConnectionInfo {
    /**
     * 
     * @type {string}
     * @memberof RuleChainConnectionInfo
     */
    additionalInfo?: string;
    /**
     * 
     * @type {number}
     * @memberof RuleChainConnectionInfo
     */
    fromIndex?: number;
    /**
     * 
     * @type {RuleChainId}
     * @memberof RuleChainConnectionInfo
     */
    targetRuleChainId?: RuleChainId;
    /**
     * 
     * @type {string}
     * @memberof RuleChainConnectionInfo
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface RuleChainData
 */
export interface RuleChainData {
    /**
     * 
     * @type {Array<RuleChainMetaData>}
     * @memberof RuleChainData
     */
    metadata?: Array<RuleChainMetaData>;
    /**
     * 
     * @type {Array<RuleChain>}
     * @memberof RuleChainData
     */
    ruleChains?: Array<RuleChain>;
}

/**
 * 
 * @export
 * @interface RuleChainId
 */
export interface RuleChainId {
    /**
     * 
     * @type {string}
     * @memberof RuleChainId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface RuleChainMetaData
 */
export interface RuleChainMetaData {
    /**
     * 
     * @type {Array<NodeConnectionInfo>}
     * @memberof RuleChainMetaData
     */
    connections?: Array<NodeConnectionInfo>;
    /**
     * 
     * @type {number}
     * @memberof RuleChainMetaData
     */
    firstNodeIndex?: number;
    /**
     * 
     * @type {Array<RuleNode>}
     * @memberof RuleChainMetaData
     */
    nodes?: Array<RuleNode>;
    /**
     * 
     * @type {Array<RuleChainConnectionInfo>}
     * @memberof RuleChainMetaData
     */
    ruleChainConnections?: Array<RuleChainConnectionInfo>;
    /**
     * 
     * @type {RuleChainId}
     * @memberof RuleChainMetaData
     */
    ruleChainId?: RuleChainId;
}

/**
 * 
 * @export
 * @interface RuleNode
 */
export interface RuleNode {
    /**
     * 
     * @type {string}
     * @memberof RuleNode
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleNode
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof RuleNode
     */
    createdTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RuleNode
     */
    debugMode?: boolean;
    /**
     * 
     * @type {RuleNodeId}
     * @memberof RuleNode
     */
    id?: RuleNodeId;
    /**
     * 
     * @type {string}
     * @memberof RuleNode
     */
    name?: string;
    /**
     * 
     * @type {RuleChainId}
     * @memberof RuleNode
     */
    ruleChainId?: RuleChainId;
    /**
     * 
     * @type {string}
     * @memberof RuleNode
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface RuleNodeId
 */
export interface RuleNodeId {
    /**
     * 
     * @type {string}
     * @memberof RuleNodeId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface SchedulerEvent
 */
export interface SchedulerEvent {
    /**
     * 
     * @type {string}
     * @memberof SchedulerEvent
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEvent
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof SchedulerEvent
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof SchedulerEvent
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {SchedulerEventId}
     * @memberof SchedulerEvent
     */
    id?: SchedulerEventId;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEvent
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof SchedulerEvent
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEvent
     */
    schedule?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof SchedulerEvent
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEvent
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface SchedulerEventId
 */
export interface SchedulerEventId {
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface SchedulerEventInfo
 */
export interface SchedulerEventInfo {
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventInfo
     */
    additionalInfo?: string;
    /**
     * 
     * @type {number}
     * @memberof SchedulerEventInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof SchedulerEventInfo
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {SchedulerEventId}
     * @memberof SchedulerEventInfo
     */
    id?: SchedulerEventId;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventInfo
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof SchedulerEventInfo
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventInfo
     */
    schedule?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof SchedulerEventInfo
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventInfo
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface SchedulerEventWithCustomerInfo
 */
export interface SchedulerEventWithCustomerInfo {
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventWithCustomerInfo
     */
    additionalInfo?: string;
    /**
     * 
     * @type {number}
     * @memberof SchedulerEventWithCustomerInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof SchedulerEventWithCustomerInfo
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {boolean}
     * @memberof SchedulerEventWithCustomerInfo
     */
    customerIsPublic?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventWithCustomerInfo
     */
    customerTitle?: string;
    /**
     * 
     * @type {SchedulerEventId}
     * @memberof SchedulerEventWithCustomerInfo
     */
    id?: SchedulerEventId;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventWithCustomerInfo
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof SchedulerEventWithCustomerInfo
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventWithCustomerInfo
     */
    schedule?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof SchedulerEventWithCustomerInfo
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof SchedulerEventWithCustomerInfo
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface SecuritySettings
 */
export interface SecuritySettings {
    /**
     * 
     * @type {number}
     * @memberof SecuritySettings
     */
    maxFailedLoginAttempts?: number;
    /**
     * 
     * @type {UserPasswordPolicy}
     * @memberof SecuritySettings
     */
    passwordPolicy?: UserPasswordPolicy;
    /**
     * 
     * @type {string}
     * @memberof SecuritySettings
     */
    userLockoutNotificationEmail?: string;
}

/**
 * 
 * @export
 * @interface SelfRegistrationParams
 */
export interface SelfRegistrationParams {
    /**
     * 
     * @type {string}
     * @memberof SelfRegistrationParams
     */
    adminSettingsId?: string;
    /**
     * 
     * @type {string}
     * @memberof SelfRegistrationParams
     */
    captchaSecretKey?: string;
    /**
     * 
     * @type {string}
     * @memberof SelfRegistrationParams
     */
    captchaSiteKey?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SelfRegistrationParams
     */
    defaultDashboardFullscreen?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SelfRegistrationParams
     */
    defaultDashboardId?: string;
    /**
     * 
     * @type {string}
     * @memberof SelfRegistrationParams
     */
    domainName?: string;
    /**
     * 
     * @type {string}
     * @memberof SelfRegistrationParams
     */
    notificationEmail?: string;
    /**
     * 
     * @type {Array<GroupPermission>}
     * @memberof SelfRegistrationParams
     */
    permissions?: Array<GroupPermission>;
    /**
     * 
     * @type {string}
     * @memberof SelfRegistrationParams
     */
    privacyPolicy?: string;
    /**
     * 
     * @type {string}
     * @memberof SelfRegistrationParams
     */
    signUpTextMessage?: string;
}

/**
 * 
 * @export
 * @interface ShareGroupRequest
 */
export interface ShareGroupRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ShareGroupRequest
     */
    allUserGroup?: boolean;
    /**
     * 
     * @type {EntityId}
     * @memberof ShareGroupRequest
     */
    ownerId: EntityId;
    /**
     * 
     * @type {boolean}
     * @memberof ShareGroupRequest
     */
    isAllUserGroup: boolean;
    /**
     * 
     * @type {EntityGroupId}
     * @memberof ShareGroupRequest
     */
    userGroupId: EntityGroupId;
    /**
     * 
     * @type {boolean}
     * @memberof ShareGroupRequest
     */
    readElseWrite: boolean;
    /**
     * 
     * @type {Array<RoleId>}
     * @memberof ShareGroupRequest
     */
    roleIds: Array<RoleId>;
}

/**
 * 
 * @export
 * @interface ShortCustomerInfo
 */
export interface ShortCustomerInfo {
    /**
     * 
     * @type {CustomerId}
     * @memberof ShortCustomerInfo
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {boolean}
     * @memberof ShortCustomerInfo
     */
    _public?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShortCustomerInfo
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShortCustomerInfo
     */
    isPublic: boolean;
}

/**
 * 
 * @export
 * @interface ShortEntityView
 */
export interface ShortEntityView {
    /**
     * 
     * @type {EntityId}
     * @memberof ShortEntityView
     */
    id?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ShortEntityView
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    recaptchaResponse?: string;
}

/**
 * 
 * @export
 * @interface SignUpSelfRegistrationParams
 */
export interface SignUpSelfRegistrationParams {
    /**
     * 
     * @type {string}
     * @memberof SignUpSelfRegistrationParams
     */
    captchaSiteKey?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpSelfRegistrationParams
     */
    signUpTextMessage?: string;
}

/**
 * 
 * @export
 * @interface SmsProviderConfiguration
 */
export interface SmsProviderConfiguration {
}

/**
 * 
 * @export
 * @interface TelemetryEntityView
 */
export interface TelemetryEntityView {
    /**
     * 
     * @type {AttributesEntityView}
     * @memberof TelemetryEntityView
     */
    attributes?: AttributesEntityView;
    /**
     * 
     * @type {Array<string>}
     * @memberof TelemetryEntityView
     */
    timeseries?: Array<string>;
}

/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    email?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof Tenant
     */
    id?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    state?: string;
    /**
     * 
     * @type {TenantProfileId}
     * @memberof Tenant
     */
    tenantProfileId?: TenantProfileId;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    zip?: string;
}

/**
 * 
 * @export
 * @interface TenantId
 */
export interface TenantId {
    /**
     * 
     * @type {string}
     * @memberof TenantId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface TenantInfo
 */
export interface TenantInfo {
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof TenantInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    email?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof TenantInfo
     */
    id?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    state?: string;
    /**
     * 
     * @type {TenantProfileId}
     * @memberof TenantInfo
     */
    tenantProfileId?: TenantProfileId;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    tenantProfileName?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantInfo
     */
    zip?: string;
}

/**
 * 
 * @export
 * @interface TenantProfile
 */
export interface TenantProfile {
    /**
     * 
     * @type {number}
     * @memberof TenantProfile
     */
    createdTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TenantProfile
     */
    _default?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TenantProfile
     */
    description?: string;
    /**
     * 
     * @type {TenantProfileId}
     * @memberof TenantProfile
     */
    id?: TenantProfileId;
    /**
     * 
     * @type {boolean}
     * @memberof TenantProfile
     */
    isolatedTbCore?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TenantProfile
     */
    isolatedTbRuleEngine?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TenantProfile
     */
    name?: string;
    /**
     * 
     * @type {TenantProfileData}
     * @memberof TenantProfile
     */
    profileData?: TenantProfileData;
}

/**
 * 
 * @export
 * @interface TenantProfileConfiguration
 */
export interface TenantProfileConfiguration {
}

/**
 * 
 * @export
 * @interface TenantProfileData
 */
export interface TenantProfileData {
    /**
     * 
     * @type {TenantProfileConfiguration}
     * @memberof TenantProfileData
     */
    configuration?: TenantProfileConfiguration;
}

/**
 * 
 * @export
 * @interface TenantProfileId
 */
export interface TenantProfileId {
    /**
     * 
     * @type {string}
     * @memberof TenantProfileId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface TestSmsRequest
 */
export interface TestSmsRequest {
    /**
     * 
     * @type {string}
     * @memberof TestSmsRequest
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSmsRequest
     */
    numberTo?: string;
    /**
     * 
     * @type {SmsProviderConfiguration}
     * @memberof TestSmsRequest
     */
    providerConfiguration?: SmsProviderConfiguration;
}

/**
 * 
 * @export
 * @interface TsValue
 */
export interface TsValue {
    /**
     * 
     * @type {number}
     * @memberof TsValue
     */
    ts?: number;
    /**
     * 
     * @type {string}
     * @memberof TsValue
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface URI
 */
export interface URI {
    /**
     * 
     * @type {boolean}
     * @memberof URI
     */
    absolute?: boolean;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    authority?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    fragment?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    host?: string;
    /**
     * 
     * @type {boolean}
     * @memberof URI
     */
    opaque?: boolean;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    path?: string;
    /**
     * 
     * @type {number}
     * @memberof URI
     */
    port?: number;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    rawAuthority?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    rawFragment?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    rawPath?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    rawQuery?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    rawSchemeSpecificPart?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    rawUserInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    scheme?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    schemeSpecificPart?: string;
    /**
     * 
     * @type {string}
     * @memberof URI
     */
    userInfo?: string;
}

/**
 * 
 * @export
 * @interface URL
 */
export interface URL {
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    authority?: string;
    /**
     * 
     * @type {any}
     * @memberof URL
     */
    content?: any;
    /**
     * 
     * @type {number}
     * @memberof URL
     */
    defaultPort?: number;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    file?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    host?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    path?: string;
    /**
     * 
     * @type {number}
     * @memberof URL
     */
    port?: number;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    protocol?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    ref?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    userInfo?: string;
}

/**
 * 
 * @export
 * @interface UpdateMessage
 */
export interface UpdateMessage {
    /**
     * 
     * @type {string}
     * @memberof UpdateMessage
     */
    message?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMessage
     */
    updateAvailable?: boolean;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    additionalInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    authority?: User.AuthorityEnum;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    createdTime?: number;
    /**
     * 
     * @type {CustomerId}
     * @memberof User
     */
    customerId?: CustomerId;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {UserId}
     * @memberof User
     */
    id?: UserId;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof User
     */
    ownerId?: EntityId;
    /**
     * 
     * @type {TenantId}
     * @memberof User
     */
    tenantId?: TenantId;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum AuthorityEnum {
        SYSADMIN = <any> 'SYS_ADMIN',
        TENANTADMIN = <any> 'TENANT_ADMIN',
        CUSTOMERUSER = <any> 'CUSTOMER_USER',
        REFRESHTOKEN = <any> 'REFRESH_TOKEN'
    }
}

/**
 * 
 * @export
 * @interface UserId
 */
export interface UserId {
    /**
     * 
     * @type {string}
     * @memberof UserId
     */
    id: string;
}

/**
 * 
 * @export
 * @interface UserPasswordPolicy
 */
export interface UserPasswordPolicy {
    /**
     * 
     * @type {number}
     * @memberof UserPasswordPolicy
     */
    minimumDigits?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPasswordPolicy
     */
    minimumLength?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPasswordPolicy
     */
    minimumLowercaseLetters?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPasswordPolicy
     */
    minimumSpecialCharacters?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPasswordPolicy
     */
    minimumUppercaseLetters?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPasswordPolicy
     */
    passwordExpirationPeriodDays?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPasswordPolicy
     */
    passwordReuseFrequencyDays?: number;
}

/**
 * 
 * @export
 * @interface WhiteLabelingParams
 */
export interface WhiteLabelingParams {
    /**
     * 
     * @type {string}
     * @memberof WhiteLabelingParams
     */
    appTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof WhiteLabelingParams
     */
    customCss?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WhiteLabelingParams
     */
    enableHelpLinks?: boolean;
    /**
     * 
     * @type {Favicon}
     * @memberof WhiteLabelingParams
     */
    favicon?: Favicon;
    /**
     * 
     * @type {string}
     * @memberof WhiteLabelingParams
     */
    faviconChecksum?: string;
    /**
     * 
     * @type {string}
     * @memberof WhiteLabelingParams
     */
    helpLinkBaseUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof WhiteLabelingParams
     */
    logoImageChecksum?: string;
    /**
     * 
     * @type {number}
     * @memberof WhiteLabelingParams
     */
    logoImageHeight?: number;
    /**
     * 
     * @type {string}
     * @memberof WhiteLabelingParams
     */
    logoImageUrl?: string;
    /**
     * 
     * @type {PaletteSettings}
     * @memberof WhiteLabelingParams
     */
    paletteSettings?: PaletteSettings;
    /**
     * 
     * @type {string}
     * @memberof WhiteLabelingParams
     */
    platformName?: string;
    /**
     * 
     * @type {string}
     * @memberof WhiteLabelingParams
     */
    platformVersion?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WhiteLabelingParams
     */
    showNameVersion?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WhiteLabelingParams
     */
    whiteLabelingEnabled?: boolean;
}

/**
 * 
 * @export
 * @interface WidgetType
 */
export interface WidgetType {
    /**
     * 
     * @type {string}
     * @memberof WidgetType
     */
    alias?: string;
    /**
     * 
     * @type {string}
     * @memberof WidgetType
     */
    bundleAlias?: string;
    /**
     * 
     * @type {number}
     * @memberof WidgetType
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof WidgetType
     */
    descriptor?: string;
    /**
     * 
     * @type {WidgetTypeId}
     * @memberof WidgetType
     */
    id?: WidgetTypeId;
    /**
     * 
     * @type {string}
     * @memberof WidgetType
     */
    name?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof WidgetType
     */
    tenantId?: TenantId;
}

/**
 * 
 * @export
 * @interface WidgetTypeDetails
 */
export interface WidgetTypeDetails {
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeDetails
     */
    alias?: string;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeDetails
     */
    bundleAlias?: string;
    /**
     * 
     * @type {number}
     * @memberof WidgetTypeDetails
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeDetails
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeDetails
     */
    descriptor?: string;
    /**
     * 
     * @type {WidgetTypeId}
     * @memberof WidgetTypeDetails
     */
    id?: WidgetTypeId;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeDetails
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeDetails
     */
    name?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof WidgetTypeDetails
     */
    tenantId?: TenantId;
}

/**
 * 
 * @export
 * @interface WidgetTypeId
 */
export interface WidgetTypeId {
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeId
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface WidgetTypeInfo
 */
export interface WidgetTypeInfo {
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeInfo
     */
    alias?: string;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeInfo
     */
    bundleAlias?: string;
    /**
     * 
     * @type {number}
     * @memberof WidgetTypeInfo
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeInfo
     */
    description?: string;
    /**
     * 
     * @type {WidgetTypeId}
     * @memberof WidgetTypeInfo
     */
    id?: WidgetTypeId;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeInfo
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeInfo
     */
    name?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof WidgetTypeInfo
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof WidgetTypeInfo
     */
    widgetType?: string;
}

/**
 * 
 * @export
 * @interface WidgetsBundle
 */
export interface WidgetsBundle {
    /**
     * 
     * @type {string}
     * @memberof WidgetsBundle
     */
    alias?: string;
    /**
     * 
     * @type {number}
     * @memberof WidgetsBundle
     */
    createdTime?: number;
    /**
     * 
     * @type {string}
     * @memberof WidgetsBundle
     */
    description?: string;
    /**
     * 
     * @type {WidgetsBundleId}
     * @memberof WidgetsBundle
     */
    id?: WidgetsBundleId;
    /**
     * 
     * @type {string}
     * @memberof WidgetsBundle
     */
    image?: string;
    /**
     * 
     * @type {TenantId}
     * @memberof WidgetsBundle
     */
    tenantId?: TenantId;
    /**
     * 
     * @type {string}
     * @memberof WidgetsBundle
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface WidgetsBundleId
 */
export interface WidgetsBundleId {
    /**
     * 
     * @type {string}
     * @memberof WidgetsBundleId
     */
    id?: string;
}


/**
 * AdminControllerApi - fetch parameter creator
 * @export
 */
export const AdminControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUpdatesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/admin/updates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAdminSettings
         * @param {string} key key
         * @param {boolean} [systemByDefault] systemByDefault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminSettingsUsingGET(key: string, systemByDefault?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getAdminSettingsUsingGET.');
            }
            const localVarPath = `/api/admin/settings/{key}{?systemByDefault}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (systemByDefault !== undefined) {
                localVarQueryParameter['systemByDefault'] = systemByDefault;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSecuritySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuritySettingsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/admin/securitySettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveAdminSettings
         * @param {AdminSettings} adminSettings adminSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingsUsingPOST(adminSettings: AdminSettings, options: any = {}): FetchArgs {
            // verify required parameter 'adminSettings' is not null or undefined
            if (adminSettings === null || adminSettings === undefined) {
                throw new RequiredError('adminSettings','Required parameter adminSettings was null or undefined when calling saveAdminSettingsUsingPOST.');
            }
            const localVarPath = `/api/admin/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(adminSettings || {}) : (adminSettings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveSecuritySettings
         * @param {SecuritySettings} securitySettings securitySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSecuritySettingsUsingPOST(securitySettings: SecuritySettings, options: any = {}): FetchArgs {
            // verify required parameter 'securitySettings' is not null or undefined
            if (securitySettings === null || securitySettings === undefined) {
                throw new RequiredError('securitySettings','Required parameter securitySettings was null or undefined when calling saveSecuritySettingsUsingPOST.');
            }
            const localVarPath = `/api/admin/securitySettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SecuritySettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(securitySettings || {}) : (securitySettings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sendTestMail
         * @param {AdminSettings} adminSettings adminSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestMailUsingPOST(adminSettings: AdminSettings, options: any = {}): FetchArgs {
            // verify required parameter 'adminSettings' is not null or undefined
            if (adminSettings === null || adminSettings === undefined) {
                throw new RequiredError('adminSettings','Required parameter adminSettings was null or undefined when calling sendTestMailUsingPOST.');
            }
            const localVarPath = `/api/admin/settings/testMail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(adminSettings || {}) : (adminSettings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sendTestSms
         * @param {TestSmsRequest} testSmsRequest testSmsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestSmsUsingPOST(testSmsRequest: TestSmsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'testSmsRequest' is not null or undefined
            if (testSmsRequest === null || testSmsRequest === undefined) {
                throw new RequiredError('testSmsRequest','Required parameter testSmsRequest was null or undefined when calling sendTestSmsUsingPOST.');
            }
            const localVarPath = `/api/admin/settings/testSms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TestSmsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(testSmsRequest || {}) : (testSmsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminControllerApi - functional programming interface
 * @export
 */
export const AdminControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUpdatesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateMessage> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).checkUpdatesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAdminSettings
         * @param {string} key key
         * @param {boolean} [systemByDefault] systemByDefault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminSettingsUsingGET(key: string, systemByDefault?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminSettings> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).getAdminSettingsUsingGET(key, systemByDefault, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSecuritySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuritySettingsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SecuritySettings> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).getSecuritySettingsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveAdminSettings
         * @param {AdminSettings} adminSettings adminSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingsUsingPOST(adminSettings: AdminSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminSettings> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).saveAdminSettingsUsingPOST(adminSettings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveSecuritySettings
         * @param {SecuritySettings} securitySettings securitySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSecuritySettingsUsingPOST(securitySettings: SecuritySettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SecuritySettings> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).saveSecuritySettingsUsingPOST(securitySettings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary sendTestMail
         * @param {AdminSettings} adminSettings adminSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestMailUsingPOST(adminSettings: AdminSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).sendTestMailUsingPOST(adminSettings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary sendTestSms
         * @param {TestSmsRequest} testSmsRequest testSmsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestSmsUsingPOST(testSmsRequest: TestSmsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).sendTestSmsUsingPOST(testSmsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminControllerApi - factory interface
 * @export
 */
export const AdminControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary checkUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUpdatesUsingGET(options?: any) {
            return AdminControllerApiFp(configuration).checkUpdatesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAdminSettings
         * @param {string} key key
         * @param {boolean} [systemByDefault] systemByDefault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminSettingsUsingGET(key: string, systemByDefault?: boolean, options?: any) {
            return AdminControllerApiFp(configuration).getAdminSettingsUsingGET(key, systemByDefault, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSecuritySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuritySettingsUsingGET(options?: any) {
            return AdminControllerApiFp(configuration).getSecuritySettingsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveAdminSettings
         * @param {AdminSettings} adminSettings adminSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingsUsingPOST(adminSettings: AdminSettings, options?: any) {
            return AdminControllerApiFp(configuration).saveAdminSettingsUsingPOST(adminSettings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveSecuritySettings
         * @param {SecuritySettings} securitySettings securitySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSecuritySettingsUsingPOST(securitySettings: SecuritySettings, options?: any) {
            return AdminControllerApiFp(configuration).saveSecuritySettingsUsingPOST(securitySettings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary sendTestMail
         * @param {AdminSettings} adminSettings adminSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestMailUsingPOST(adminSettings: AdminSettings, options?: any) {
            return AdminControllerApiFp(configuration).sendTestMailUsingPOST(adminSettings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary sendTestSms
         * @param {TestSmsRequest} testSmsRequest testSmsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestSmsUsingPOST(testSmsRequest: TestSmsRequest, options?: any) {
            return AdminControllerApiFp(configuration).sendTestSmsUsingPOST(testSmsRequest, options)(fetch, basePath);
        },
    };
};

/**
 * AdminControllerApi - object-oriented interface
 * @export
 * @class AdminControllerApi
 * @extends {BaseAPI}
 */
export class AdminControllerApi extends BaseAPI {
    /**
     * 
     * @summary checkUpdates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public checkUpdatesUsingGET(options?: any) {
        return AdminControllerApiFp(this.configuration).checkUpdatesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAdminSettings
     * @param {string} key key
     * @param {boolean} [systemByDefault] systemByDefault
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getAdminSettingsUsingGET(key: string, systemByDefault?: boolean, options?: any) {
        return AdminControllerApiFp(this.configuration).getAdminSettingsUsingGET(key, systemByDefault, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSecuritySettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getSecuritySettingsUsingGET(options?: any) {
        return AdminControllerApiFp(this.configuration).getSecuritySettingsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveAdminSettings
     * @param {AdminSettings} adminSettings adminSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public saveAdminSettingsUsingPOST(adminSettings: AdminSettings, options?: any) {
        return AdminControllerApiFp(this.configuration).saveAdminSettingsUsingPOST(adminSettings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveSecuritySettings
     * @param {SecuritySettings} securitySettings securitySettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public saveSecuritySettingsUsingPOST(securitySettings: SecuritySettings, options?: any) {
        return AdminControllerApiFp(this.configuration).saveSecuritySettingsUsingPOST(securitySettings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary sendTestMail
     * @param {AdminSettings} adminSettings adminSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public sendTestMailUsingPOST(adminSettings: AdminSettings, options?: any) {
        return AdminControllerApiFp(this.configuration).sendTestMailUsingPOST(adminSettings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary sendTestSms
     * @param {TestSmsRequest} testSmsRequest testSmsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public sendTestSmsUsingPOST(testSmsRequest: TestSmsRequest, options?: any) {
        return AdminControllerApiFp(this.configuration).sendTestSmsUsingPOST(testSmsRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * AlarmControllerApi - fetch parameter creator
 * @export
 */
export const AlarmControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary ackAlarm
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackAlarmUsingPOST(alarmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'alarmId' is not null or undefined
            if (alarmId === null || alarmId === undefined) {
                throw new RequiredError('alarmId','Required parameter alarmId was null or undefined when calling ackAlarmUsingPOST.');
            }
            const localVarPath = `/api/alarm/{alarmId}/ack`
                .replace(`{${"alarmId"}}`, encodeURIComponent(String(alarmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary clearAlarm
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAlarmUsingPOST(alarmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'alarmId' is not null or undefined
            if (alarmId === null || alarmId === undefined) {
                throw new RequiredError('alarmId','Required parameter alarmId was null or undefined when calling clearAlarmUsingPOST.');
            }
            const localVarPath = `/api/alarm/{alarmId}/clear`
                .replace(`{${"alarmId"}}`, encodeURIComponent(String(alarmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteAlarm
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlarmUsingDELETE(alarmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'alarmId' is not null or undefined
            if (alarmId === null || alarmId === undefined) {
                throw new RequiredError('alarmId','Required parameter alarmId was null or undefined when calling deleteAlarmUsingDELETE.');
            }
            const localVarPath = `/api/alarm/{alarmId}`
                .replace(`{${"alarmId"}}`, encodeURIComponent(String(alarmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAlarmById
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlarmByIdUsingGET(alarmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'alarmId' is not null or undefined
            if (alarmId === null || alarmId === undefined) {
                throw new RequiredError('alarmId','Required parameter alarmId was null or undefined when calling getAlarmByIdUsingGET.');
            }
            const localVarPath = `/api/alarm/{alarmId}`
                .replace(`{${"alarmId"}}`, encodeURIComponent(String(alarmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAlarmInfoById
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlarmInfoByIdUsingGET(alarmId: string, options: any = {}): FetchArgs {
            // verify required parameter 'alarmId' is not null or undefined
            if (alarmId === null || alarmId === undefined) {
                throw new RequiredError('alarmId','Required parameter alarmId was null or undefined when calling getAlarmInfoByIdUsingGET.');
            }
            const localVarPath = `/api/alarm/info/{alarmId}`
                .replace(`{${"alarmId"}}`, encodeURIComponent(String(alarmId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAlarms
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [searchStatus] searchStatus
         * @param {string} [status] status
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [offset] offset
         * @param {boolean} [fetchOriginator] fetchOriginator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlarmsUsingGET(entityType: string, entityId: string, pageSize: number, page: number, searchStatus?: string, status?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, offset?: string, fetchOriginator?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getAlarmsUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getAlarmsUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getAlarmsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAlarmsUsingGET.');
            }
            const localVarPath = `/api/alarm/{entityType}/{entityId}{?searchStatus,status,pageSize,page,textSearch,sortProperty,sortOrder,startTime,endTime,offset,fetchOriginator}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (searchStatus !== undefined) {
                localVarQueryParameter['searchStatus'] = searchStatus;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (fetchOriginator !== undefined) {
                localVarQueryParameter['fetchOriginator'] = fetchOriginator;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHighestAlarmSeverity
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} [searchStatus] searchStatus
         * @param {string} [status] status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighestAlarmSeverityUsingGET(entityType: string, entityId: string, searchStatus?: string, status?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getHighestAlarmSeverityUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getHighestAlarmSeverityUsingGET.');
            }
            const localVarPath = `/api/alarm/highestSeverity/{entityType}/{entityId}{?searchStatus,status}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (searchStatus !== undefined) {
                localVarQueryParameter['searchStatus'] = searchStatus;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveAlarm
         * @param {Alarm} alarm alarm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlarmUsingPOST(alarm: Alarm, options: any = {}): FetchArgs {
            // verify required parameter 'alarm' is not null or undefined
            if (alarm === null || alarm === undefined) {
                throw new RequiredError('alarm','Required parameter alarm was null or undefined when calling saveAlarmUsingPOST.');
            }
            const localVarPath = `/api/alarm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Alarm" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(alarm || {}) : (alarm || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlarmControllerApi - functional programming interface
 * @export
 */
export const AlarmControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary ackAlarm
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackAlarmUsingPOST(alarmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AlarmControllerApiFetchParamCreator(configuration).ackAlarmUsingPOST(alarmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary clearAlarm
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAlarmUsingPOST(alarmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AlarmControllerApiFetchParamCreator(configuration).clearAlarmUsingPOST(alarmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteAlarm
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlarmUsingDELETE(alarmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = AlarmControllerApiFetchParamCreator(configuration).deleteAlarmUsingDELETE(alarmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAlarmById
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlarmByIdUsingGET(alarmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alarm> {
            const localVarFetchArgs = AlarmControllerApiFetchParamCreator(configuration).getAlarmByIdUsingGET(alarmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAlarmInfoById
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlarmInfoByIdUsingGET(alarmId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlarmInfo> {
            const localVarFetchArgs = AlarmControllerApiFetchParamCreator(configuration).getAlarmInfoByIdUsingGET(alarmId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAlarms
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [searchStatus] searchStatus
         * @param {string} [status] status
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [offset] offset
         * @param {boolean} [fetchOriginator] fetchOriginator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlarmsUsingGET(entityType: string, entityId: string, pageSize: number, page: number, searchStatus?: string, status?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, offset?: string, fetchOriginator?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAlarmInfo> {
            const localVarFetchArgs = AlarmControllerApiFetchParamCreator(configuration).getAlarmsUsingGET(entityType, entityId, pageSize, page, searchStatus, status, textSearch, sortProperty, sortOrder, startTime, endTime, offset, fetchOriginator, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getHighestAlarmSeverity
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} [searchStatus] searchStatus
         * @param {string} [status] status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighestAlarmSeverityUsingGET(entityType: string, entityId: string, searchStatus?: string, status?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AlarmControllerApiFetchParamCreator(configuration).getHighestAlarmSeverityUsingGET(entityType, entityId, searchStatus, status, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveAlarm
         * @param {Alarm} alarm alarm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlarmUsingPOST(alarm: Alarm, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alarm> {
            const localVarFetchArgs = AlarmControllerApiFetchParamCreator(configuration).saveAlarmUsingPOST(alarm, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AlarmControllerApi - factory interface
 * @export
 */
export const AlarmControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary ackAlarm
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackAlarmUsingPOST(alarmId: string, options?: any) {
            return AlarmControllerApiFp(configuration).ackAlarmUsingPOST(alarmId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary clearAlarm
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAlarmUsingPOST(alarmId: string, options?: any) {
            return AlarmControllerApiFp(configuration).clearAlarmUsingPOST(alarmId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteAlarm
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlarmUsingDELETE(alarmId: string, options?: any) {
            return AlarmControllerApiFp(configuration).deleteAlarmUsingDELETE(alarmId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAlarmById
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlarmByIdUsingGET(alarmId: string, options?: any) {
            return AlarmControllerApiFp(configuration).getAlarmByIdUsingGET(alarmId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAlarmInfoById
         * @param {string} alarmId alarmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlarmInfoByIdUsingGET(alarmId: string, options?: any) {
            return AlarmControllerApiFp(configuration).getAlarmInfoByIdUsingGET(alarmId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAlarms
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [searchStatus] searchStatus
         * @param {string} [status] status
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [offset] offset
         * @param {boolean} [fetchOriginator] fetchOriginator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlarmsUsingGET(entityType: string, entityId: string, pageSize: number, page: number, searchStatus?: string, status?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, offset?: string, fetchOriginator?: boolean, options?: any) {
            return AlarmControllerApiFp(configuration).getAlarmsUsingGET(entityType, entityId, pageSize, page, searchStatus, status, textSearch, sortProperty, sortOrder, startTime, endTime, offset, fetchOriginator, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getHighestAlarmSeverity
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} [searchStatus] searchStatus
         * @param {string} [status] status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighestAlarmSeverityUsingGET(entityType: string, entityId: string, searchStatus?: string, status?: string, options?: any) {
            return AlarmControllerApiFp(configuration).getHighestAlarmSeverityUsingGET(entityType, entityId, searchStatus, status, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveAlarm
         * @param {Alarm} alarm alarm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlarmUsingPOST(alarm: Alarm, options?: any) {
            return AlarmControllerApiFp(configuration).saveAlarmUsingPOST(alarm, options)(fetch, basePath);
        },
    };
};

/**
 * AlarmControllerApi - object-oriented interface
 * @export
 * @class AlarmControllerApi
 * @extends {BaseAPI}
 */
export class AlarmControllerApi extends BaseAPI {
    /**
     * 
     * @summary ackAlarm
     * @param {string} alarmId alarmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmControllerApi
     */
    public ackAlarmUsingPOST(alarmId: string, options?: any) {
        return AlarmControllerApiFp(this.configuration).ackAlarmUsingPOST(alarmId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary clearAlarm
     * @param {string} alarmId alarmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmControllerApi
     */
    public clearAlarmUsingPOST(alarmId: string, options?: any) {
        return AlarmControllerApiFp(this.configuration).clearAlarmUsingPOST(alarmId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteAlarm
     * @param {string} alarmId alarmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmControllerApi
     */
    public deleteAlarmUsingDELETE(alarmId: string, options?: any) {
        return AlarmControllerApiFp(this.configuration).deleteAlarmUsingDELETE(alarmId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAlarmById
     * @param {string} alarmId alarmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmControllerApi
     */
    public getAlarmByIdUsingGET(alarmId: string, options?: any) {
        return AlarmControllerApiFp(this.configuration).getAlarmByIdUsingGET(alarmId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAlarmInfoById
     * @param {string} alarmId alarmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmControllerApi
     */
    public getAlarmInfoByIdUsingGET(alarmId: string, options?: any) {
        return AlarmControllerApiFp(this.configuration).getAlarmInfoByIdUsingGET(alarmId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAlarms
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {number} pageSize pageSize
     * @param {number} page page
     * @param {string} [searchStatus] searchStatus
     * @param {string} [status] status
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {number} [startTime] startTime
     * @param {number} [endTime] endTime
     * @param {string} [offset] offset
     * @param {boolean} [fetchOriginator] fetchOriginator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmControllerApi
     */
    public getAlarmsUsingGET(entityType: string, entityId: string, pageSize: number, page: number, searchStatus?: string, status?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, offset?: string, fetchOriginator?: boolean, options?: any) {
        return AlarmControllerApiFp(this.configuration).getAlarmsUsingGET(entityType, entityId, pageSize, page, searchStatus, status, textSearch, sortProperty, sortOrder, startTime, endTime, offset, fetchOriginator, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getHighestAlarmSeverity
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} [searchStatus] searchStatus
     * @param {string} [status] status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmControllerApi
     */
    public getHighestAlarmSeverityUsingGET(entityType: string, entityId: string, searchStatus?: string, status?: string, options?: any) {
        return AlarmControllerApiFp(this.configuration).getHighestAlarmSeverityUsingGET(entityType, entityId, searchStatus, status, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveAlarm
     * @param {Alarm} alarm alarm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmControllerApi
     */
    public saveAlarmUsingPOST(alarm: Alarm, options?: any) {
        return AlarmControllerApiFp(this.configuration).saveAlarmUsingPOST(alarm, options)(this.fetch, this.basePath);
    }

}

/**
 * AssetControllerApi - fetch parameter creator
 * @export
 */
export const AssetControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteAsset
         * @param {string} assetId assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetUsingDELETE(assetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling deleteAssetUsingDELETE.');
            }
            const localVarPath = `/api/asset/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByQuery
         * @param {AssetSearchQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST(query: AssetSearchQuery, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling findByQueryUsingPOST.');
            }
            const localVarPath = `/api/assets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetSearchQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAssetById
         * @param {string} assetId assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByIdUsingGET(assetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getAssetByIdUsingGET.');
            }
            const localVarPath = `/api/asset/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAssetTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetTypesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/asset/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAssetsByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getAssetsByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getAssetsByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAssetsByEntityGroupIdUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/assets{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAssetsByIds
         * @param {string} assetIds assetIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsByIdsUsingGET(assetIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'assetIds' is not null or undefined
            if (assetIds === null || assetIds === undefined) {
                throw new RequiredError('assetIds','Required parameter assetIds was null or undefined when calling getAssetsByIdsUsingGET.');
            }
            const localVarPath = `/api/assets{?assetIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (assetIds !== undefined) {
                localVarQueryParameter['assetIds'] = assetIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomerAssets
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerAssetsUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomerAssetsUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getCustomerAssetsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getCustomerAssetsUsingGET.');
            }
            const localVarPath = `/api/customer/{customerId}/assets{?type,textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantAsset
         * @param {string} assetName assetName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAssetUsingGET(assetName: string, options: any = {}): FetchArgs {
            // verify required parameter 'assetName' is not null or undefined
            if (assetName === null || assetName === undefined) {
                throw new RequiredError('assetName','Required parameter assetName was null or undefined when calling getTenantAssetUsingGET.');
            }
            const localVarPath = `/api/tenant/assets{?assetName}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (assetName !== undefined) {
                localVarQueryParameter['assetName'] = assetName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantAssets
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAssetsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantAssetsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantAssetsUsingGET.');
            }
            const localVarPath = `/api/tenant/assets{?type,textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserAssets
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getUserAssetsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserAssetsUsingGET.');
            }
            const localVarPath = `/api/user/assets{?type,textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveAsset
         * @param {Asset} asset asset
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAssetUsingPOST(asset: Asset, entityGroupId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new RequiredError('asset','Required parameter asset was null or undefined when calling saveAssetUsingPOST.');
            }
            const localVarPath = `/api/asset{?entityGroupId}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (entityGroupId !== undefined) {
                localVarQueryParameter['entityGroupId'] = entityGroupId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Asset" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(asset || {}) : (asset || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetControllerApi - functional programming interface
 * @export
 */
export const AssetControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteAsset
         * @param {string} assetId assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetUsingDELETE(assetId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).deleteAssetUsingDELETE(assetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findByQuery
         * @param {AssetSearchQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST(query: AssetSearchQuery, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Asset>> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).findByQueryUsingPOST(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAssetById
         * @param {string} assetId assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByIdUsingGET(assetId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Asset> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).getAssetByIdUsingGET(assetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAssetTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetTypesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntitySubtype>> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).getAssetTypesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAssetsByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAsset> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).getAssetsByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAssetsByIds
         * @param {string} assetIds assetIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsByIdsUsingGET(assetIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Asset>> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).getAssetsByIdsUsingGET(assetIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomerAssets
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerAssetsUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAsset> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).getCustomerAssetsUsingGET(customerId, pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantAsset
         * @param {string} assetName assetName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAssetUsingGET(assetName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Asset> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).getTenantAssetUsingGET(assetName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantAssets
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAssetsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAsset> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).getTenantAssetsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserAssets
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAsset> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).getUserAssetsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveAsset
         * @param {Asset} asset asset
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAssetUsingPOST(asset: Asset, entityGroupId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Asset> {
            const localVarFetchArgs = AssetControllerApiFetchParamCreator(configuration).saveAssetUsingPOST(asset, entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetControllerApi - factory interface
 * @export
 */
export const AssetControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteAsset
         * @param {string} assetId assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetUsingDELETE(assetId: string, options?: any) {
            return AssetControllerApiFp(configuration).deleteAssetUsingDELETE(assetId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findByQuery
         * @param {AssetSearchQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST(query: AssetSearchQuery, options?: any) {
            return AssetControllerApiFp(configuration).findByQueryUsingPOST(query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAssetById
         * @param {string} assetId assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByIdUsingGET(assetId: string, options?: any) {
            return AssetControllerApiFp(configuration).getAssetByIdUsingGET(assetId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAssetTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetTypesUsingGET(options?: any) {
            return AssetControllerApiFp(configuration).getAssetTypesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAssetsByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return AssetControllerApiFp(configuration).getAssetsByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAssetsByIds
         * @param {string} assetIds assetIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsByIdsUsingGET(assetIds: string, options?: any) {
            return AssetControllerApiFp(configuration).getAssetsByIdsUsingGET(assetIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomerAssets
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerAssetsUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return AssetControllerApiFp(configuration).getCustomerAssetsUsingGET(customerId, pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantAsset
         * @param {string} assetName assetName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAssetUsingGET(assetName: string, options?: any) {
            return AssetControllerApiFp(configuration).getTenantAssetUsingGET(assetName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantAssets
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAssetsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return AssetControllerApiFp(configuration).getTenantAssetsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserAssets
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return AssetControllerApiFp(configuration).getUserAssetsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveAsset
         * @param {Asset} asset asset
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAssetUsingPOST(asset: Asset, entityGroupId?: string, options?: any) {
            return AssetControllerApiFp(configuration).saveAssetUsingPOST(asset, entityGroupId, options)(fetch, basePath);
        },
    };
};

/**
 * AssetControllerApi - object-oriented interface
 * @export
 * @class AssetControllerApi
 * @extends {BaseAPI}
 */
export class AssetControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteAsset
     * @param {string} assetId assetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public deleteAssetUsingDELETE(assetId: string, options?: any) {
        return AssetControllerApiFp(this.configuration).deleteAssetUsingDELETE(assetId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findByQuery
     * @param {AssetSearchQuery} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public findByQueryUsingPOST(query: AssetSearchQuery, options?: any) {
        return AssetControllerApiFp(this.configuration).findByQueryUsingPOST(query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAssetById
     * @param {string} assetId assetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public getAssetByIdUsingGET(assetId: string, options?: any) {
        return AssetControllerApiFp(this.configuration).getAssetByIdUsingGET(assetId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAssetTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public getAssetTypesUsingGET(options?: any) {
        return AssetControllerApiFp(this.configuration).getAssetTypesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAssetsByEntityGroupId
     * @param {string} entityGroupId entityGroupId
     * @param {string} pageSize Page size
     * @param {string} page Page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public getAssetsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return AssetControllerApiFp(this.configuration).getAssetsByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAssetsByIds
     * @param {string} assetIds assetIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public getAssetsByIdsUsingGET(assetIds: string, options?: any) {
        return AssetControllerApiFp(this.configuration).getAssetsByIdsUsingGET(assetIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomerAssets
     * @param {string} customerId customerId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public getCustomerAssetsUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return AssetControllerApiFp(this.configuration).getCustomerAssetsUsingGET(customerId, pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantAsset
     * @param {string} assetName assetName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public getTenantAssetUsingGET(assetName: string, options?: any) {
        return AssetControllerApiFp(this.configuration).getTenantAssetUsingGET(assetName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantAssets
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public getTenantAssetsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return AssetControllerApiFp(this.configuration).getTenantAssetsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserAssets
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public getUserAssetsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return AssetControllerApiFp(this.configuration).getUserAssetsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveAsset
     * @param {Asset} asset asset
     * @param {string} [entityGroupId] entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetControllerApi
     */
    public saveAssetUsingPOST(asset: Asset, entityGroupId?: string, options?: any) {
        return AssetControllerApiFp(this.configuration).saveAssetUsingPOST(asset, entityGroupId, options)(this.fetch, this.basePath);
    }

}

/**
 * AuditLogControllerApi - fetch parameter creator
 * @export
 */
export const AuditLogControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAuditLogsByCustomerId
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsByCustomerIdUsingGET(customerId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getAuditLogsByCustomerIdUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getAuditLogsByCustomerIdUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAuditLogsByCustomerIdUsingGET.');
            }
            const localVarPath = `/api/audit/logs/customer/{customerId}{?textSearch,sortProperty,sortOrder,startTime,endTime,actionTypes,pageSize,page}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (actionTypes !== undefined) {
                localVarQueryParameter['actionTypes'] = actionTypes;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAuditLogsByEntityId
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsByEntityIdUsingGET(entityType: string, entityId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getAuditLogsByEntityIdUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getAuditLogsByEntityIdUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getAuditLogsByEntityIdUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAuditLogsByEntityIdUsingGET.');
            }
            const localVarPath = `/api/audit/logs/entity/{entityType}/{entityId}{?textSearch,sortProperty,sortOrder,startTime,endTime,actionTypes,pageSize,page}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (actionTypes !== undefined) {
                localVarQueryParameter['actionTypes'] = actionTypes;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAuditLogsByUserId
         * @param {string} userId userId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsByUserIdUsingGET(userId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getAuditLogsByUserIdUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getAuditLogsByUserIdUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAuditLogsByUserIdUsingGET.');
            }
            const localVarPath = `/api/audit/logs/user/{userId}{?textSearch,sortProperty,sortOrder,startTime,endTime,actionTypes,pageSize,page}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (actionTypes !== undefined) {
                localVarQueryParameter['actionTypes'] = actionTypes;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAuditLogs
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getAuditLogsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAuditLogsUsingGET.');
            }
            const localVarPath = `/api/audit/logs{?textSearch,sortProperty,sortOrder,startTime,endTime,actionTypes,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (actionTypes !== undefined) {
                localVarQueryParameter['actionTypes'] = actionTypes;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogControllerApi - functional programming interface
 * @export
 */
export const AuditLogControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAuditLogsByCustomerId
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsByCustomerIdUsingGET(customerId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAuditLog> {
            const localVarFetchArgs = AuditLogControllerApiFetchParamCreator(configuration).getAuditLogsByCustomerIdUsingGET(customerId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAuditLogsByEntityId
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsByEntityIdUsingGET(entityType: string, entityId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAuditLog> {
            const localVarFetchArgs = AuditLogControllerApiFetchParamCreator(configuration).getAuditLogsByEntityIdUsingGET(entityType, entityId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAuditLogsByUserId
         * @param {string} userId userId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsByUserIdUsingGET(userId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAuditLog> {
            const localVarFetchArgs = AuditLogControllerApiFetchParamCreator(configuration).getAuditLogsByUserIdUsingGET(userId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAuditLogs
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAuditLog> {
            const localVarFetchArgs = AuditLogControllerApiFetchParamCreator(configuration).getAuditLogsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuditLogControllerApi - factory interface
 * @export
 */
export const AuditLogControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getAuditLogsByCustomerId
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsByCustomerIdUsingGET(customerId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any) {
            return AuditLogControllerApiFp(configuration).getAuditLogsByCustomerIdUsingGET(customerId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAuditLogsByEntityId
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsByEntityIdUsingGET(entityType: string, entityId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any) {
            return AuditLogControllerApiFp(configuration).getAuditLogsByEntityIdUsingGET(entityType, entityId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAuditLogsByUserId
         * @param {string} userId userId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsByUserIdUsingGET(userId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any) {
            return AuditLogControllerApiFp(configuration).getAuditLogsByUserIdUsingGET(userId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAuditLogs
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {string} [actionTypes] actionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any) {
            return AuditLogControllerApiFp(configuration).getAuditLogsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options)(fetch, basePath);
        },
    };
};

/**
 * AuditLogControllerApi - object-oriented interface
 * @export
 * @class AuditLogControllerApi
 * @extends {BaseAPI}
 */
export class AuditLogControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAuditLogsByCustomerId
     * @param {string} customerId customerId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {number} [startTime] startTime
     * @param {number} [endTime] endTime
     * @param {string} [actionTypes] actionTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogControllerApi
     */
    public getAuditLogsByCustomerIdUsingGET(customerId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any) {
        return AuditLogControllerApiFp(this.configuration).getAuditLogsByCustomerIdUsingGET(customerId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAuditLogsByEntityId
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {number} [startTime] startTime
     * @param {number} [endTime] endTime
     * @param {string} [actionTypes] actionTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogControllerApi
     */
    public getAuditLogsByEntityIdUsingGET(entityType: string, entityId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any) {
        return AuditLogControllerApiFp(this.configuration).getAuditLogsByEntityIdUsingGET(entityType, entityId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAuditLogsByUserId
     * @param {string} userId userId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {number} [startTime] startTime
     * @param {number} [endTime] endTime
     * @param {string} [actionTypes] actionTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogControllerApi
     */
    public getAuditLogsByUserIdUsingGET(userId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any) {
        return AuditLogControllerApiFp(this.configuration).getAuditLogsByUserIdUsingGET(userId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAuditLogs
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {number} [startTime] startTime
     * @param {number} [endTime] endTime
     * @param {string} [actionTypes] actionTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogControllerApi
     */
    public getAuditLogsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, actionTypes?: string, options?: any) {
        return AuditLogControllerApiFp(this.configuration).getAuditLogsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, actionTypes, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthControllerApi - fetch parameter creator
 * @export
 */
export const AuthControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary activateUser
         * @param {string} activateRequest activateRequest
         * @param {boolean} [sendActivationMail] sendActivationMail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUserUsingPOST(activateRequest: string, sendActivationMail?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'activateRequest' is not null or undefined
            if (activateRequest === null || activateRequest === undefined) {
                throw new RequiredError('activateRequest','Required parameter activateRequest was null or undefined when calling activateUserUsingPOST.');
            }
            const localVarPath = `/api/noauth/activate{?sendActivationMail}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sendActivationMail !== undefined) {
                localVarQueryParameter['sendActivationMail'] = sendActivationMail;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(activateRequest || {}) : (activateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary changePassword
         * @param {string} changePasswordRequest changePasswordRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPOST(changePasswordRequest: string, options: any = {}): FetchArgs {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            if (changePasswordRequest === null || changePasswordRequest === undefined) {
                throw new RequiredError('changePasswordRequest','Required parameter changePasswordRequest was null or undefined when calling changePasswordUsingPOST.');
            }
            const localVarPath = `/api/auth/changePassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(changePasswordRequest || {}) : (changePasswordRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary checkActivateToken
         * @param {string} activateToken activateToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkActivateTokenUsingGET(activateToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'activateToken' is not null or undefined
            if (activateToken === null || activateToken === undefined) {
                throw new RequiredError('activateToken','Required parameter activateToken was null or undefined when calling checkActivateTokenUsingGET.');
            }
            const localVarPath = `/api/noauth/activate{?activateToken}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activateToken !== undefined) {
                localVarQueryParameter['activateToken'] = activateToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary checkResetToken
         * @param {string} resetToken resetToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkResetTokenUsingGET(resetToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'resetToken' is not null or undefined
            if (resetToken === null || resetToken === undefined) {
                throw new RequiredError('resetToken','Required parameter resetToken was null or undefined when calling checkResetTokenUsingGET.');
            }
            const localVarPath = `/api/noauth/resetPassword{?resetToken}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (resetToken !== undefined) {
                localVarQueryParameter['resetToken'] = resetToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserPasswordPolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPasswordPolicyUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/noauth/userPasswordPolicy`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/auth/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/api/auth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary requestResetPasswordByEmail
         * @param {string} resetPasswordByEmailRequest resetPasswordByEmailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetPasswordByEmailUsingPOST(resetPasswordByEmailRequest: string, options: any = {}): FetchArgs {
            // verify required parameter 'resetPasswordByEmailRequest' is not null or undefined
            if (resetPasswordByEmailRequest === null || resetPasswordByEmailRequest === undefined) {
                throw new RequiredError('resetPasswordByEmailRequest','Required parameter resetPasswordByEmailRequest was null or undefined when calling requestResetPasswordByEmailUsingPOST.');
            }
            const localVarPath = `/api/noauth/resetPasswordByEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(resetPasswordByEmailRequest || {}) : (resetPasswordByEmailRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary resetPassword
         * @param {string} resetPasswordRequest resetPasswordRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordUsingPOST(resetPasswordRequest: string, options: any = {}): FetchArgs {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            if (resetPasswordRequest === null || resetPasswordRequest === undefined) {
                throw new RequiredError('resetPasswordRequest','Required parameter resetPasswordRequest was null or undefined when calling resetPasswordUsingPOST.');
            }
            const localVarPath = `/api/noauth/resetPassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(resetPasswordRequest || {}) : (resetPasswordRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary activateUser
         * @param {string} activateRequest activateRequest
         * @param {boolean} [sendActivationMail] sendActivationMail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUserUsingPOST(activateRequest: string, sendActivationMail?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).activateUserUsingPOST(activateRequest, sendActivationMail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary changePassword
         * @param {string} changePasswordRequest changePasswordRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPOST(changePasswordRequest: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).changePasswordUsingPOST(changePasswordRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary checkActivateToken
         * @param {string} activateToken activateToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkActivateTokenUsingGET(activateToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).checkActivateTokenUsingGET(activateToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary checkResetToken
         * @param {string} resetToken resetToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkResetTokenUsingGET(resetToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).checkResetTokenUsingGET(resetToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserPasswordPolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPasswordPolicyUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPasswordPolicy> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).getUserPasswordPolicyUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).getUserUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).logoutUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary requestResetPasswordByEmail
         * @param {string} resetPasswordByEmailRequest resetPasswordByEmailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetPasswordByEmailUsingPOST(resetPasswordByEmailRequest: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).requestResetPasswordByEmailUsingPOST(resetPasswordByEmailRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary resetPassword
         * @param {string} resetPasswordRequest resetPasswordRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordUsingPOST(resetPasswordRequest: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).resetPasswordUsingPOST(resetPasswordRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary activateUser
         * @param {string} activateRequest activateRequest
         * @param {boolean} [sendActivationMail] sendActivationMail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUserUsingPOST(activateRequest: string, sendActivationMail?: boolean, options?: any) {
            return AuthControllerApiFp(configuration).activateUserUsingPOST(activateRequest, sendActivationMail, options)(fetch, basePath);
        },
        /**
         * 
         * @summary changePassword
         * @param {string} changePasswordRequest changePasswordRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPOST(changePasswordRequest: string, options?: any) {
            return AuthControllerApiFp(configuration).changePasswordUsingPOST(changePasswordRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary checkActivateToken
         * @param {string} activateToken activateToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkActivateTokenUsingGET(activateToken: string, options?: any) {
            return AuthControllerApiFp(configuration).checkActivateTokenUsingGET(activateToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary checkResetToken
         * @param {string} resetToken resetToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkResetTokenUsingGET(resetToken: string, options?: any) {
            return AuthControllerApiFp(configuration).checkResetTokenUsingGET(resetToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserPasswordPolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPasswordPolicyUsingGET(options?: any) {
            return AuthControllerApiFp(configuration).getUserPasswordPolicyUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(options?: any) {
            return AuthControllerApiFp(configuration).getUserUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUsingPOST(options?: any) {
            return AuthControllerApiFp(configuration).logoutUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary requestResetPasswordByEmail
         * @param {string} resetPasswordByEmailRequest resetPasswordByEmailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestResetPasswordByEmailUsingPOST(resetPasswordByEmailRequest: string, options?: any) {
            return AuthControllerApiFp(configuration).requestResetPasswordByEmailUsingPOST(resetPasswordByEmailRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary resetPassword
         * @param {string} resetPasswordRequest resetPasswordRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordUsingPOST(resetPasswordRequest: string, options?: any) {
            return AuthControllerApiFp(configuration).resetPasswordUsingPOST(resetPasswordRequest, options)(fetch, basePath);
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @summary activateUser
     * @param {string} activateRequest activateRequest
     * @param {boolean} [sendActivationMail] sendActivationMail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public activateUserUsingPOST(activateRequest: string, sendActivationMail?: boolean, options?: any) {
        return AuthControllerApiFp(this.configuration).activateUserUsingPOST(activateRequest, sendActivationMail, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary changePassword
     * @param {string} changePasswordRequest changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public changePasswordUsingPOST(changePasswordRequest: string, options?: any) {
        return AuthControllerApiFp(this.configuration).changePasswordUsingPOST(changePasswordRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary checkActivateToken
     * @param {string} activateToken activateToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public checkActivateTokenUsingGET(activateToken: string, options?: any) {
        return AuthControllerApiFp(this.configuration).checkActivateTokenUsingGET(activateToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary checkResetToken
     * @param {string} resetToken resetToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public checkResetTokenUsingGET(resetToken: string, options?: any) {
        return AuthControllerApiFp(this.configuration).checkResetTokenUsingGET(resetToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserPasswordPolicy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public getUserPasswordPolicyUsingGET(options?: any) {
        return AuthControllerApiFp(this.configuration).getUserPasswordPolicyUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public getUserUsingGET(options?: any) {
        return AuthControllerApiFp(this.configuration).getUserUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public logoutUsingPOST(options?: any) {
        return AuthControllerApiFp(this.configuration).logoutUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary requestResetPasswordByEmail
     * @param {string} resetPasswordByEmailRequest resetPasswordByEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public requestResetPasswordByEmailUsingPOST(resetPasswordByEmailRequest: string, options?: any) {
        return AuthControllerApiFp(this.configuration).requestResetPasswordByEmailUsingPOST(resetPasswordByEmailRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary resetPassword
     * @param {string} resetPasswordRequest resetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public resetPasswordUsingPOST(resetPasswordRequest: string, options?: any) {
        return AuthControllerApiFp(this.configuration).resetPasswordUsingPOST(resetPasswordRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * BlobEntityControllerApi - fetch parameter creator
 * @export
 */
export const BlobEntityControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteBlobEntity
         * @param {string} blobEntityId blobEntityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlobEntityUsingDELETE(blobEntityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'blobEntityId' is not null or undefined
            if (blobEntityId === null || blobEntityId === undefined) {
                throw new RequiredError('blobEntityId','Required parameter blobEntityId was null or undefined when calling deleteBlobEntityUsingDELETE.');
            }
            const localVarPath = `/api/blobEntity/{blobEntityId}`
                .replace(`{${"blobEntityId"}}`, encodeURIComponent(String(blobEntityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary downloadBlobEntity
         * @param {string} blobEntityId blobEntityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBlobEntityUsingGET(blobEntityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'blobEntityId' is not null or undefined
            if (blobEntityId === null || blobEntityId === undefined) {
                throw new RequiredError('blobEntityId','Required parameter blobEntityId was null or undefined when calling downloadBlobEntityUsingGET.');
            }
            const localVarPath = `/api/blobEntity/{blobEntityId}/download`
                .replace(`{${"blobEntityId"}}`, encodeURIComponent(String(blobEntityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBlobEntitiesByIds
         * @param {string} blobEntityIds blobEntityIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlobEntitiesByIdsUsingGET(blobEntityIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'blobEntityIds' is not null or undefined
            if (blobEntityIds === null || blobEntityIds === undefined) {
                throw new RequiredError('blobEntityIds','Required parameter blobEntityIds was null or undefined when calling getBlobEntitiesByIdsUsingGET.');
            }
            const localVarPath = `/api/blobEntities{?blobEntityIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (blobEntityIds !== undefined) {
                localVarQueryParameter['blobEntityIds'] = blobEntityIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBlobEntities
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlobEntitiesUsingGET(pageSize: number, page: number, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getBlobEntitiesUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getBlobEntitiesUsingGET.');
            }
            const localVarPath = `/api/blobEntities{?pageSize,page,type,textSearch,sortProperty,sortOrder,startTime,endTime}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBlobEntityInfoById
         * @param {string} blobEntityId blobEntityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlobEntityInfoByIdUsingGET(blobEntityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'blobEntityId' is not null or undefined
            if (blobEntityId === null || blobEntityId === undefined) {
                throw new RequiredError('blobEntityId','Required parameter blobEntityId was null or undefined when calling getBlobEntityInfoByIdUsingGET.');
            }
            const localVarPath = `/api/blobEntity/info/{blobEntityId}`
                .replace(`{${"blobEntityId"}}`, encodeURIComponent(String(blobEntityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlobEntityControllerApi - functional programming interface
 * @export
 */
export const BlobEntityControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteBlobEntity
         * @param {string} blobEntityId blobEntityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlobEntityUsingDELETE(blobEntityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BlobEntityControllerApiFetchParamCreator(configuration).deleteBlobEntityUsingDELETE(blobEntityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary downloadBlobEntity
         * @param {string} blobEntityId blobEntityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBlobEntityUsingGET(blobEntityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Resource> {
            const localVarFetchArgs = BlobEntityControllerApiFetchParamCreator(configuration).downloadBlobEntityUsingGET(blobEntityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getBlobEntitiesByIds
         * @param {string} blobEntityIds blobEntityIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlobEntitiesByIdsUsingGET(blobEntityIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BlobEntityInfo>> {
            const localVarFetchArgs = BlobEntityControllerApiFetchParamCreator(configuration).getBlobEntitiesByIdsUsingGET(blobEntityIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getBlobEntities
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlobEntitiesUsingGET(pageSize: number, page: number, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataBlobEntityWithCustomerInfo> {
            const localVarFetchArgs = BlobEntityControllerApiFetchParamCreator(configuration).getBlobEntitiesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, startTime, endTime, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getBlobEntityInfoById
         * @param {string} blobEntityId blobEntityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlobEntityInfoByIdUsingGET(blobEntityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BlobEntityWithCustomerInfo> {
            const localVarFetchArgs = BlobEntityControllerApiFetchParamCreator(configuration).getBlobEntityInfoByIdUsingGET(blobEntityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BlobEntityControllerApi - factory interface
 * @export
 */
export const BlobEntityControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteBlobEntity
         * @param {string} blobEntityId blobEntityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlobEntityUsingDELETE(blobEntityId: string, options?: any) {
            return BlobEntityControllerApiFp(configuration).deleteBlobEntityUsingDELETE(blobEntityId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary downloadBlobEntity
         * @param {string} blobEntityId blobEntityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBlobEntityUsingGET(blobEntityId: string, options?: any) {
            return BlobEntityControllerApiFp(configuration).downloadBlobEntityUsingGET(blobEntityId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getBlobEntitiesByIds
         * @param {string} blobEntityIds blobEntityIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlobEntitiesByIdsUsingGET(blobEntityIds: string, options?: any) {
            return BlobEntityControllerApiFp(configuration).getBlobEntitiesByIdsUsingGET(blobEntityIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getBlobEntities
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlobEntitiesUsingGET(pageSize: number, page: number, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options?: any) {
            return BlobEntityControllerApiFp(configuration).getBlobEntitiesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, startTime, endTime, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getBlobEntityInfoById
         * @param {string} blobEntityId blobEntityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlobEntityInfoByIdUsingGET(blobEntityId: string, options?: any) {
            return BlobEntityControllerApiFp(configuration).getBlobEntityInfoByIdUsingGET(blobEntityId, options)(fetch, basePath);
        },
    };
};

/**
 * BlobEntityControllerApi - object-oriented interface
 * @export
 * @class BlobEntityControllerApi
 * @extends {BaseAPI}
 */
export class BlobEntityControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteBlobEntity
     * @param {string} blobEntityId blobEntityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobEntityControllerApi
     */
    public deleteBlobEntityUsingDELETE(blobEntityId: string, options?: any) {
        return BlobEntityControllerApiFp(this.configuration).deleteBlobEntityUsingDELETE(blobEntityId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary downloadBlobEntity
     * @param {string} blobEntityId blobEntityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobEntityControllerApi
     */
    public downloadBlobEntityUsingGET(blobEntityId: string, options?: any) {
        return BlobEntityControllerApiFp(this.configuration).downloadBlobEntityUsingGET(blobEntityId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getBlobEntitiesByIds
     * @param {string} blobEntityIds blobEntityIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobEntityControllerApi
     */
    public getBlobEntitiesByIdsUsingGET(blobEntityIds: string, options?: any) {
        return BlobEntityControllerApiFp(this.configuration).getBlobEntitiesByIdsUsingGET(blobEntityIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getBlobEntities
     * @param {number} pageSize pageSize
     * @param {number} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {number} [startTime] startTime
     * @param {number} [endTime] endTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobEntityControllerApi
     */
    public getBlobEntitiesUsingGET(pageSize: number, page: number, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options?: any) {
        return BlobEntityControllerApiFp(this.configuration).getBlobEntitiesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, startTime, endTime, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getBlobEntityInfoById
     * @param {string} blobEntityId blobEntityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobEntityControllerApi
     */
    public getBlobEntityInfoByIdUsingGET(blobEntityId: string, options?: any) {
        return BlobEntityControllerApiFp(this.configuration).getBlobEntityInfoByIdUsingGET(blobEntityId, options)(this.fetch, this.basePath);
    }

}

/**
 * ChirpStackIntegrationControllerApi - fetch parameter creator
 * @export
 */
export const ChirpStackIntegrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingDELETE.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingDELETE.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingDELETE.');
            }
            const localVarPath = `/api/v1/integrations/chirpstack/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingGET.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingGET.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingGET.');
            }
            const localVarPath = `/api/v1/integrations/chirpstack/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingHEAD.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingHEAD.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingHEAD.');
            }
            const localVarPath = `/api/v1/integrations/chirpstack/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingOPTIONS.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingOPTIONS.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingOPTIONS.');
            }
            const localVarPath = `/api/v1/integrations/chirpstack/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPATCH.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPATCH.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPATCH.');
            }
            const localVarPath = `/api/v1/integrations/chirpstack/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPOST.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPOST.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPOST.');
            }
            const localVarPath = `/api/v1/integrations/chirpstack/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPUT.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPUT.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPUT.');
            }
            const localVarPath = `/api/v1/integrations/chirpstack/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChirpStackIntegrationControllerApi - functional programming interface
 * @export
 */
export const ChirpStackIntegrationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ChirpStackIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingDELETE(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ChirpStackIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingGET(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ChirpStackIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingHEAD(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ChirpStackIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingOPTIONS(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ChirpStackIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPATCH(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ChirpStackIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPOST(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ChirpStackIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPUT(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChirpStackIntegrationControllerApi - factory interface
 * @export
 */
export const ChirpStackIntegrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return ChirpStackIntegrationControllerApiFp(configuration).processRequestUsingDELETE(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return ChirpStackIntegrationControllerApiFp(configuration).processRequestUsingGET(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return ChirpStackIntegrationControllerApiFp(configuration).processRequestUsingHEAD(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return ChirpStackIntegrationControllerApiFp(configuration).processRequestUsingOPTIONS(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return ChirpStackIntegrationControllerApiFp(configuration).processRequestUsingPATCH(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return ChirpStackIntegrationControllerApiFp(configuration).processRequestUsingPOST(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return ChirpStackIntegrationControllerApiFp(configuration).processRequestUsingPUT(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
    };
};

/**
 * ChirpStackIntegrationControllerApi - object-oriented interface
 * @export
 * @class ChirpStackIntegrationControllerApi
 * @extends {BaseAPI}
 */
export class ChirpStackIntegrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChirpStackIntegrationControllerApi
     */
    public processRequestUsingDELETE(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return ChirpStackIntegrationControllerApiFp(this.configuration).processRequestUsingDELETE(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChirpStackIntegrationControllerApi
     */
    public processRequestUsingGET(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return ChirpStackIntegrationControllerApiFp(this.configuration).processRequestUsingGET(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChirpStackIntegrationControllerApi
     */
    public processRequestUsingHEAD(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return ChirpStackIntegrationControllerApiFp(this.configuration).processRequestUsingHEAD(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChirpStackIntegrationControllerApi
     */
    public processRequestUsingOPTIONS(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return ChirpStackIntegrationControllerApiFp(this.configuration).processRequestUsingOPTIONS(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChirpStackIntegrationControllerApi
     */
    public processRequestUsingPATCH(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return ChirpStackIntegrationControllerApiFp(this.configuration).processRequestUsingPATCH(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChirpStackIntegrationControllerApi
     */
    public processRequestUsingPOST(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return ChirpStackIntegrationControllerApiFp(this.configuration).processRequestUsingPOST(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChirpStackIntegrationControllerApi
     */
    public processRequestUsingPUT(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return ChirpStackIntegrationControllerApiFp(this.configuration).processRequestUsingPUT(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

}

/**
 * ComponentDescriptorControllerApi - fetch parameter creator
 * @export
 */
export const ComponentDescriptorControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getComponentDescriptorByClazz
         * @param {string} componentDescriptorClazz componentDescriptorClazz
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponentDescriptorByClazzUsingGET(componentDescriptorClazz: string, options: any = {}): FetchArgs {
            // verify required parameter 'componentDescriptorClazz' is not null or undefined
            if (componentDescriptorClazz === null || componentDescriptorClazz === undefined) {
                throw new RequiredError('componentDescriptorClazz','Required parameter componentDescriptorClazz was null or undefined when calling getComponentDescriptorByClazzUsingGET.');
            }
            const localVarPath = `/api/component/{componentDescriptorClazz}`
                .replace(`{${"componentDescriptorClazz"}}`, encodeURIComponent(String(componentDescriptorClazz)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getComponentDescriptorsByType
         * @param {string} componentType componentType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponentDescriptorsByTypeUsingGET(componentType: string, options: any = {}): FetchArgs {
            // verify required parameter 'componentType' is not null or undefined
            if (componentType === null || componentType === undefined) {
                throw new RequiredError('componentType','Required parameter componentType was null or undefined when calling getComponentDescriptorsByTypeUsingGET.');
            }
            const localVarPath = `/api/components/{componentType}`
                .replace(`{${"componentType"}}`, encodeURIComponent(String(componentType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getComponentDescriptorsByTypes
         * @param {string} componentTypes componentTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponentDescriptorsByTypesUsingGET(componentTypes: string, options: any = {}): FetchArgs {
            // verify required parameter 'componentTypes' is not null or undefined
            if (componentTypes === null || componentTypes === undefined) {
                throw new RequiredError('componentTypes','Required parameter componentTypes was null or undefined when calling getComponentDescriptorsByTypesUsingGET.');
            }
            const localVarPath = `/api/components{?componentTypes}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (componentTypes !== undefined) {
                localVarQueryParameter['componentTypes'] = componentTypes;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComponentDescriptorControllerApi - functional programming interface
 * @export
 */
export const ComponentDescriptorControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getComponentDescriptorByClazz
         * @param {string} componentDescriptorClazz componentDescriptorClazz
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponentDescriptorByClazzUsingGET(componentDescriptorClazz: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ComponentDescriptor> {
            const localVarFetchArgs = ComponentDescriptorControllerApiFetchParamCreator(configuration).getComponentDescriptorByClazzUsingGET(componentDescriptorClazz, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getComponentDescriptorsByType
         * @param {string} componentType componentType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponentDescriptorsByTypeUsingGET(componentType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComponentDescriptor>> {
            const localVarFetchArgs = ComponentDescriptorControllerApiFetchParamCreator(configuration).getComponentDescriptorsByTypeUsingGET(componentType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getComponentDescriptorsByTypes
         * @param {string} componentTypes componentTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponentDescriptorsByTypesUsingGET(componentTypes: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComponentDescriptor>> {
            const localVarFetchArgs = ComponentDescriptorControllerApiFetchParamCreator(configuration).getComponentDescriptorsByTypesUsingGET(componentTypes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ComponentDescriptorControllerApi - factory interface
 * @export
 */
export const ComponentDescriptorControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getComponentDescriptorByClazz
         * @param {string} componentDescriptorClazz componentDescriptorClazz
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponentDescriptorByClazzUsingGET(componentDescriptorClazz: string, options?: any) {
            return ComponentDescriptorControllerApiFp(configuration).getComponentDescriptorByClazzUsingGET(componentDescriptorClazz, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getComponentDescriptorsByType
         * @param {string} componentType componentType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponentDescriptorsByTypeUsingGET(componentType: string, options?: any) {
            return ComponentDescriptorControllerApiFp(configuration).getComponentDescriptorsByTypeUsingGET(componentType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getComponentDescriptorsByTypes
         * @param {string} componentTypes componentTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponentDescriptorsByTypesUsingGET(componentTypes: string, options?: any) {
            return ComponentDescriptorControllerApiFp(configuration).getComponentDescriptorsByTypesUsingGET(componentTypes, options)(fetch, basePath);
        },
    };
};

/**
 * ComponentDescriptorControllerApi - object-oriented interface
 * @export
 * @class ComponentDescriptorControllerApi
 * @extends {BaseAPI}
 */
export class ComponentDescriptorControllerApi extends BaseAPI {
    /**
     * 
     * @summary getComponentDescriptorByClazz
     * @param {string} componentDescriptorClazz componentDescriptorClazz
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentDescriptorControllerApi
     */
    public getComponentDescriptorByClazzUsingGET(componentDescriptorClazz: string, options?: any) {
        return ComponentDescriptorControllerApiFp(this.configuration).getComponentDescriptorByClazzUsingGET(componentDescriptorClazz, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getComponentDescriptorsByType
     * @param {string} componentType componentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentDescriptorControllerApi
     */
    public getComponentDescriptorsByTypeUsingGET(componentType: string, options?: any) {
        return ComponentDescriptorControllerApiFp(this.configuration).getComponentDescriptorsByTypeUsingGET(componentType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getComponentDescriptorsByTypes
     * @param {string} componentTypes componentTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentDescriptorControllerApi
     */
    public getComponentDescriptorsByTypesUsingGET(componentTypes: string, options?: any) {
        return ComponentDescriptorControllerApiFp(this.configuration).getComponentDescriptorsByTypesUsingGET(componentTypes, options)(this.fetch, this.basePath);
    }

}

/**
 * ConverterControllerApi - fetch parameter creator
 * @export
 */
export const ConverterControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteConverter
         * @param {string} converterId converterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConverterUsingDELETE(converterId: string, options: any = {}): FetchArgs {
            // verify required parameter 'converterId' is not null or undefined
            if (converterId === null || converterId === undefined) {
                throw new RequiredError('converterId','Required parameter converterId was null or undefined when calling deleteConverterUsingDELETE.');
            }
            const localVarPath = `/api/converter/{converterId}`
                .replace(`{${"converterId"}}`, encodeURIComponent(String(converterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getConverterById
         * @param {string} converterId converterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConverterByIdUsingGET(converterId: string, options: any = {}): FetchArgs {
            // verify required parameter 'converterId' is not null or undefined
            if (converterId === null || converterId === undefined) {
                throw new RequiredError('converterId','Required parameter converterId was null or undefined when calling getConverterByIdUsingGET.');
            }
            const localVarPath = `/api/converter/{converterId}`
                .replace(`{${"converterId"}}`, encodeURIComponent(String(converterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getConvertersByIds
         * @param {string} converterIds converterIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertersByIdsUsingGET(converterIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'converterIds' is not null or undefined
            if (converterIds === null || converterIds === undefined) {
                throw new RequiredError('converterIds','Required parameter converterIds was null or undefined when calling getConvertersByIdsUsingGET.');
            }
            const localVarPath = `/api/converters{?converterIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (converterIds !== undefined) {
                localVarQueryParameter['converterIds'] = converterIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getConverters
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getConvertersUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getConvertersUsingGET.');
            }
            const localVarPath = `/api/converters{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getLatestConverterDebugInput
         * @param {string} converterId converterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestConverterDebugInputUsingGET(converterId: string, options: any = {}): FetchArgs {
            // verify required parameter 'converterId' is not null or undefined
            if (converterId === null || converterId === undefined) {
                throw new RequiredError('converterId','Required parameter converterId was null or undefined when calling getLatestConverterDebugInputUsingGET.');
            }
            const localVarPath = `/api/converter/{converterId}/debugIn`
                .replace(`{${"converterId"}}`, encodeURIComponent(String(converterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveConverter
         * @param {Converter} converter converter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveConverterUsingPOST(converter: Converter, options: any = {}): FetchArgs {
            // verify required parameter 'converter' is not null or undefined
            if (converter === null || converter === undefined) {
                throw new RequiredError('converter','Required parameter converter was null or undefined when calling saveConverterUsingPOST.');
            }
            const localVarPath = `/api/converter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Converter" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(converter || {}) : (converter || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary testDownLinkConverter
         * @param {string} inputParams inputParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDownLinkConverterUsingPOST(inputParams: string, options: any = {}): FetchArgs {
            // verify required parameter 'inputParams' is not null or undefined
            if (inputParams === null || inputParams === undefined) {
                throw new RequiredError('inputParams','Required parameter inputParams was null or undefined when calling testDownLinkConverterUsingPOST.');
            }
            const localVarPath = `/api/converter/testDownLink`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inputParams || {}) : (inputParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary testUpLinkConverter
         * @param {string} inputParams inputParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUpLinkConverterUsingPOST(inputParams: string, options: any = {}): FetchArgs {
            // verify required parameter 'inputParams' is not null or undefined
            if (inputParams === null || inputParams === undefined) {
                throw new RequiredError('inputParams','Required parameter inputParams was null or undefined when calling testUpLinkConverterUsingPOST.');
            }
            const localVarPath = `/api/converter/testUpLink`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inputParams || {}) : (inputParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConverterControllerApi - functional programming interface
 * @export
 */
export const ConverterControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteConverter
         * @param {string} converterId converterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConverterUsingDELETE(converterId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConverterControllerApiFetchParamCreator(configuration).deleteConverterUsingDELETE(converterId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getConverterById
         * @param {string} converterId converterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConverterByIdUsingGET(converterId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Converter> {
            const localVarFetchArgs = ConverterControllerApiFetchParamCreator(configuration).getConverterByIdUsingGET(converterId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getConvertersByIds
         * @param {string} converterIds converterIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertersByIdsUsingGET(converterIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Converter>> {
            const localVarFetchArgs = ConverterControllerApiFetchParamCreator(configuration).getConvertersByIdsUsingGET(converterIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getConverters
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataConverter> {
            const localVarFetchArgs = ConverterControllerApiFetchParamCreator(configuration).getConvertersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getLatestConverterDebugInput
         * @param {string} converterId converterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestConverterDebugInputUsingGET(converterId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ConverterControllerApiFetchParamCreator(configuration).getLatestConverterDebugInputUsingGET(converterId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveConverter
         * @param {Converter} converter converter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveConverterUsingPOST(converter: Converter, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Converter> {
            const localVarFetchArgs = ConverterControllerApiFetchParamCreator(configuration).saveConverterUsingPOST(converter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary testDownLinkConverter
         * @param {string} inputParams inputParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDownLinkConverterUsingPOST(inputParams: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ConverterControllerApiFetchParamCreator(configuration).testDownLinkConverterUsingPOST(inputParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary testUpLinkConverter
         * @param {string} inputParams inputParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUpLinkConverterUsingPOST(inputParams: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ConverterControllerApiFetchParamCreator(configuration).testUpLinkConverterUsingPOST(inputParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConverterControllerApi - factory interface
 * @export
 */
export const ConverterControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteConverter
         * @param {string} converterId converterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConverterUsingDELETE(converterId: string, options?: any) {
            return ConverterControllerApiFp(configuration).deleteConverterUsingDELETE(converterId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getConverterById
         * @param {string} converterId converterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConverterByIdUsingGET(converterId: string, options?: any) {
            return ConverterControllerApiFp(configuration).getConverterByIdUsingGET(converterId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getConvertersByIds
         * @param {string} converterIds converterIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertersByIdsUsingGET(converterIds: string, options?: any) {
            return ConverterControllerApiFp(configuration).getConvertersByIdsUsingGET(converterIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getConverters
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return ConverterControllerApiFp(configuration).getConvertersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getLatestConverterDebugInput
         * @param {string} converterId converterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestConverterDebugInputUsingGET(converterId: string, options?: any) {
            return ConverterControllerApiFp(configuration).getLatestConverterDebugInputUsingGET(converterId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveConverter
         * @param {Converter} converter converter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveConverterUsingPOST(converter: Converter, options?: any) {
            return ConverterControllerApiFp(configuration).saveConverterUsingPOST(converter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary testDownLinkConverter
         * @param {string} inputParams inputParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDownLinkConverterUsingPOST(inputParams: string, options?: any) {
            return ConverterControllerApiFp(configuration).testDownLinkConverterUsingPOST(inputParams, options)(fetch, basePath);
        },
        /**
         * 
         * @summary testUpLinkConverter
         * @param {string} inputParams inputParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUpLinkConverterUsingPOST(inputParams: string, options?: any) {
            return ConverterControllerApiFp(configuration).testUpLinkConverterUsingPOST(inputParams, options)(fetch, basePath);
        },
    };
};

/**
 * ConverterControllerApi - object-oriented interface
 * @export
 * @class ConverterControllerApi
 * @extends {BaseAPI}
 */
export class ConverterControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteConverter
     * @param {string} converterId converterId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConverterControllerApi
     */
    public deleteConverterUsingDELETE(converterId: string, options?: any) {
        return ConverterControllerApiFp(this.configuration).deleteConverterUsingDELETE(converterId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getConverterById
     * @param {string} converterId converterId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConverterControllerApi
     */
    public getConverterByIdUsingGET(converterId: string, options?: any) {
        return ConverterControllerApiFp(this.configuration).getConverterByIdUsingGET(converterId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getConvertersByIds
     * @param {string} converterIds converterIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConverterControllerApi
     */
    public getConvertersByIdsUsingGET(converterIds: string, options?: any) {
        return ConverterControllerApiFp(this.configuration).getConvertersByIdsUsingGET(converterIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getConverters
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConverterControllerApi
     */
    public getConvertersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return ConverterControllerApiFp(this.configuration).getConvertersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getLatestConverterDebugInput
     * @param {string} converterId converterId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConverterControllerApi
     */
    public getLatestConverterDebugInputUsingGET(converterId: string, options?: any) {
        return ConverterControllerApiFp(this.configuration).getLatestConverterDebugInputUsingGET(converterId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveConverter
     * @param {Converter} converter converter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConverterControllerApi
     */
    public saveConverterUsingPOST(converter: Converter, options?: any) {
        return ConverterControllerApiFp(this.configuration).saveConverterUsingPOST(converter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary testDownLinkConverter
     * @param {string} inputParams inputParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConverterControllerApi
     */
    public testDownLinkConverterUsingPOST(inputParams: string, options?: any) {
        return ConverterControllerApiFp(this.configuration).testDownLinkConverterUsingPOST(inputParams, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary testUpLinkConverter
     * @param {string} inputParams inputParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConverterControllerApi
     */
    public testUpLinkConverterUsingPOST(inputParams: string, options?: any) {
        return ConverterControllerApiFp(this.configuration).testUpLinkConverterUsingPOST(inputParams, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomMenuControllerApi - fetch parameter creator
 * @export
 */
export const CustomMenuControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCurrentCustomMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentCustomMenuUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/customMenu/currentCustomMenu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomMenuUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/customMenu/customMenu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveCustomMenu
         * @param {CustomMenu} [customMenu] customMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomMenuUsingPOST(customMenu?: CustomMenu, options: any = {}): FetchArgs {
            const localVarPath = `/api/customMenu/customMenu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomMenu" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customMenu || {}) : (customMenu || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomMenuControllerApi - functional programming interface
 * @export
 */
export const CustomMenuControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCurrentCustomMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentCustomMenuUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomMenu> {
            const localVarFetchArgs = CustomMenuControllerApiFetchParamCreator(configuration).getCurrentCustomMenuUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomMenuUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomMenu> {
            const localVarFetchArgs = CustomMenuControllerApiFetchParamCreator(configuration).getCustomMenuUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveCustomMenu
         * @param {CustomMenu} [customMenu] customMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomMenuUsingPOST(customMenu?: CustomMenu, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomMenu> {
            const localVarFetchArgs = CustomMenuControllerApiFetchParamCreator(configuration).saveCustomMenuUsingPOST(customMenu, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomMenuControllerApi - factory interface
 * @export
 */
export const CustomMenuControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getCurrentCustomMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentCustomMenuUsingGET(options?: any) {
            return CustomMenuControllerApiFp(configuration).getCurrentCustomMenuUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomMenuUsingGET(options?: any) {
            return CustomMenuControllerApiFp(configuration).getCustomMenuUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveCustomMenu
         * @param {CustomMenu} [customMenu] customMenu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomMenuUsingPOST(customMenu?: CustomMenu, options?: any) {
            return CustomMenuControllerApiFp(configuration).saveCustomMenuUsingPOST(customMenu, options)(fetch, basePath);
        },
    };
};

/**
 * CustomMenuControllerApi - object-oriented interface
 * @export
 * @class CustomMenuControllerApi
 * @extends {BaseAPI}
 */
export class CustomMenuControllerApi extends BaseAPI {
    /**
     * 
     * @summary getCurrentCustomMenu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomMenuControllerApi
     */
    public getCurrentCustomMenuUsingGET(options?: any) {
        return CustomMenuControllerApiFp(this.configuration).getCurrentCustomMenuUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomMenu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomMenuControllerApi
     */
    public getCustomMenuUsingGET(options?: any) {
        return CustomMenuControllerApiFp(this.configuration).getCustomMenuUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveCustomMenu
     * @param {CustomMenu} [customMenu] customMenu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomMenuControllerApi
     */
    public saveCustomMenuUsingPOST(customMenu?: CustomMenu, options?: any) {
        return CustomMenuControllerApiFp(this.configuration).saveCustomMenuUsingPOST(customMenu, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomTranslationControllerApi - fetch parameter creator
 * @export
 */
export const CustomTranslationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCurrentCustomTranslation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentCustomTranslationUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/customTranslation/currentCustomTranslation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomTranslation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomTranslationUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/customTranslation/customTranslation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveCustomTranslation
         * @param {CustomTranslation} customTranslation customTranslation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomTranslationUsingPOST(customTranslation: CustomTranslation, options: any = {}): FetchArgs {
            // verify required parameter 'customTranslation' is not null or undefined
            if (customTranslation === null || customTranslation === undefined) {
                throw new RequiredError('customTranslation','Required parameter customTranslation was null or undefined when calling saveCustomTranslationUsingPOST.');
            }
            const localVarPath = `/api/customTranslation/customTranslation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomTranslation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customTranslation || {}) : (customTranslation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomTranslationControllerApi - functional programming interface
 * @export
 */
export const CustomTranslationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCurrentCustomTranslation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentCustomTranslationUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomTranslation> {
            const localVarFetchArgs = CustomTranslationControllerApiFetchParamCreator(configuration).getCurrentCustomTranslationUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomTranslation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomTranslationUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomTranslation> {
            const localVarFetchArgs = CustomTranslationControllerApiFetchParamCreator(configuration).getCustomTranslationUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveCustomTranslation
         * @param {CustomTranslation} customTranslation customTranslation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomTranslationUsingPOST(customTranslation: CustomTranslation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomTranslation> {
            const localVarFetchArgs = CustomTranslationControllerApiFetchParamCreator(configuration).saveCustomTranslationUsingPOST(customTranslation, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomTranslationControllerApi - factory interface
 * @export
 */
export const CustomTranslationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getCurrentCustomTranslation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentCustomTranslationUsingGET(options?: any) {
            return CustomTranslationControllerApiFp(configuration).getCurrentCustomTranslationUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomTranslation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomTranslationUsingGET(options?: any) {
            return CustomTranslationControllerApiFp(configuration).getCustomTranslationUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveCustomTranslation
         * @param {CustomTranslation} customTranslation customTranslation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomTranslationUsingPOST(customTranslation: CustomTranslation, options?: any) {
            return CustomTranslationControllerApiFp(configuration).saveCustomTranslationUsingPOST(customTranslation, options)(fetch, basePath);
        },
    };
};

/**
 * CustomTranslationControllerApi - object-oriented interface
 * @export
 * @class CustomTranslationControllerApi
 * @extends {BaseAPI}
 */
export class CustomTranslationControllerApi extends BaseAPI {
    /**
     * 
     * @summary getCurrentCustomTranslation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTranslationControllerApi
     */
    public getCurrentCustomTranslationUsingGET(options?: any) {
        return CustomTranslationControllerApiFp(this.configuration).getCurrentCustomTranslationUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomTranslation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTranslationControllerApi
     */
    public getCustomTranslationUsingGET(options?: any) {
        return CustomTranslationControllerApiFp(this.configuration).getCustomTranslationUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveCustomTranslation
     * @param {CustomTranslation} customTranslation customTranslation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTranslationControllerApi
     */
    public saveCustomTranslationUsingPOST(customTranslation: CustomTranslation, options?: any) {
        return CustomTranslationControllerApiFp(this.configuration).saveCustomTranslationUsingPOST(customTranslation, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerControllerApi - fetch parameter creator
 * @export
 */
export const CustomerControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteCustomer
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerUsingDELETE(customerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling deleteCustomerUsingDELETE.');
            }
            const localVarPath = `/api/customer/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomerById
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByIdUsingGET(customerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomerByIdUsingGET.');
            }
            const localVarPath = `/api/customer/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomerTitleById
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerTitleByIdUsingGET(customerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomerTitleByIdUsingGET.');
            }
            const localVarPath = `/api/customer/{customerId}/title`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomersByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getCustomersByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getCustomersByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getCustomersByEntityGroupIdUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/customers{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomersByIds
         * @param {string} customerIds customerIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByIdsUsingGET(customerIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerIds' is not null or undefined
            if (customerIds === null || customerIds === undefined) {
                throw new RequiredError('customerIds','Required parameter customerIds was null or undefined when calling getCustomersByIdsUsingGET.');
            }
            const localVarPath = `/api/customers{?customerIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (customerIds !== undefined) {
                localVarQueryParameter['customerIds'] = customerIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getCustomersUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getCustomersUsingGET.');
            }
            const localVarPath = `/api/customers{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getShortCustomerInfoById
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortCustomerInfoByIdUsingGET(customerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getShortCustomerInfoByIdUsingGET.');
            }
            const localVarPath = `/api/customer/{customerId}/shortInfo`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantCustomer
         * @param {string} customerTitle customerTitle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantCustomerUsingGET(customerTitle: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerTitle' is not null or undefined
            if (customerTitle === null || customerTitle === undefined) {
                throw new RequiredError('customerTitle','Required parameter customerTitle was null or undefined when calling getTenantCustomerUsingGET.');
            }
            const localVarPath = `/api/tenant/customers{?customerTitle}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (customerTitle !== undefined) {
                localVarQueryParameter['customerTitle'] = customerTitle;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserCustomers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCustomersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getUserCustomersUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserCustomersUsingGET.');
            }
            const localVarPath = `/api/user/customers{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveCustomer
         * @param {Customer} customer customer
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomerUsingPOST(customer: Customer, entityGroupId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customer' is not null or undefined
            if (customer === null || customer === undefined) {
                throw new RequiredError('customer','Required parameter customer was null or undefined when calling saveCustomerUsingPOST.');
            }
            const localVarPath = `/api/customer{?entityGroupId}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (entityGroupId !== undefined) {
                localVarQueryParameter['entityGroupId'] = entityGroupId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customer || {}) : (customer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerControllerApi - functional programming interface
 * @export
 */
export const CustomerControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteCustomer
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerUsingDELETE(customerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).deleteCustomerUsingDELETE(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomerById
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByIdUsingGET(customerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).getCustomerByIdUsingGET(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomerTitleById
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerTitleByIdUsingGET(customerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).getCustomerTitleByIdUsingGET(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomersByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataCustomer> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).getCustomersByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomersByIds
         * @param {string} customerIds customerIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByIdsUsingGET(customerIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Customer>> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).getCustomersByIdsUsingGET(customerIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataCustomer> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).getCustomersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getShortCustomerInfoById
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortCustomerInfoByIdUsingGET(customerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).getShortCustomerInfoByIdUsingGET(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantCustomer
         * @param {string} customerTitle customerTitle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantCustomerUsingGET(customerTitle: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).getTenantCustomerUsingGET(customerTitle, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserCustomers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCustomersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataCustomer> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).getUserCustomersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveCustomer
         * @param {Customer} customer customer
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomerUsingPOST(customer: Customer, entityGroupId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).saveCustomerUsingPOST(customer, entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerControllerApi - factory interface
 * @export
 */
export const CustomerControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteCustomer
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerUsingDELETE(customerId: string, options?: any) {
            return CustomerControllerApiFp(configuration).deleteCustomerUsingDELETE(customerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomerById
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByIdUsingGET(customerId: string, options?: any) {
            return CustomerControllerApiFp(configuration).getCustomerByIdUsingGET(customerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomerTitleById
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerTitleByIdUsingGET(customerId: string, options?: any) {
            return CustomerControllerApiFp(configuration).getCustomerTitleByIdUsingGET(customerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomersByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return CustomerControllerApiFp(configuration).getCustomersByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomersByIds
         * @param {string} customerIds customerIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByIdsUsingGET(customerIds: string, options?: any) {
            return CustomerControllerApiFp(configuration).getCustomersByIdsUsingGET(customerIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return CustomerControllerApiFp(configuration).getCustomersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getShortCustomerInfoById
         * @param {string} customerId customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortCustomerInfoByIdUsingGET(customerId: string, options?: any) {
            return CustomerControllerApiFp(configuration).getShortCustomerInfoByIdUsingGET(customerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantCustomer
         * @param {string} customerTitle customerTitle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantCustomerUsingGET(customerTitle: string, options?: any) {
            return CustomerControllerApiFp(configuration).getTenantCustomerUsingGET(customerTitle, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserCustomers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCustomersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return CustomerControllerApiFp(configuration).getUserCustomersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveCustomer
         * @param {Customer} customer customer
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomerUsingPOST(customer: Customer, entityGroupId?: string, options?: any) {
            return CustomerControllerApiFp(configuration).saveCustomerUsingPOST(customer, entityGroupId, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerControllerApi - object-oriented interface
 * @export
 * @class CustomerControllerApi
 * @extends {BaseAPI}
 */
export class CustomerControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteCustomer
     * @param {string} customerId customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public deleteCustomerUsingDELETE(customerId: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).deleteCustomerUsingDELETE(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomerById
     * @param {string} customerId customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public getCustomerByIdUsingGET(customerId: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).getCustomerByIdUsingGET(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomerTitleById
     * @param {string} customerId customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public getCustomerTitleByIdUsingGET(customerId: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).getCustomerTitleByIdUsingGET(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomersByEntityGroupId
     * @param {string} entityGroupId entityGroupId
     * @param {string} pageSize Page size
     * @param {string} page Page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public getCustomersByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).getCustomersByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomersByIds
     * @param {string} customerIds customerIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public getCustomersByIdsUsingGET(customerIds: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).getCustomersByIdsUsingGET(customerIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomers
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public getCustomersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).getCustomersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getShortCustomerInfoById
     * @param {string} customerId customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public getShortCustomerInfoByIdUsingGET(customerId: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).getShortCustomerInfoByIdUsingGET(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantCustomer
     * @param {string} customerTitle customerTitle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public getTenantCustomerUsingGET(customerTitle: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).getTenantCustomerUsingGET(customerTitle, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserCustomers
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public getUserCustomersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).getUserCustomersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveCustomer
     * @param {Customer} customer customer
     * @param {string} [entityGroupId] entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public saveCustomerUsingPOST(customer: Customer, entityGroupId?: string, options?: any) {
        return CustomerControllerApiFp(this.configuration).saveCustomerUsingPOST(customer, entityGroupId, options)(this.fetch, this.basePath);
    }

}

/**
 * DashboardControllerApi - fetch parameter creator
 * @export
 */
export const DashboardControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteDashboard
         * @param {string} dashboardId dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardUsingDELETE(dashboardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId','Required parameter dashboardId was null or undefined when calling deleteDashboardUsingDELETE.');
            }
            const localVarPath = `/api/dashboard/{dashboardId}`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary exportGroupDashboards
         * @param {string} entityGroupId entityGroupId
         * @param {string} limit limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportGroupDashboardsUsingGET(entityGroupId: string, limit: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling exportGroupDashboardsUsingGET.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling exportGroupDashboardsUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/dashboards/export{?limit}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomerHomeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerHomeDashboardInfoUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/customer/dashboard/home/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDashboardById
         * @param {string} dashboardId dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardByIdUsingGET(dashboardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId','Required parameter dashboardId was null or undefined when calling getDashboardByIdUsingGET.');
            }
            const localVarPath = `/api/dashboard/{dashboardId}`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDashboardInfoById
         * @param {string} dashboardId dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardInfoByIdUsingGET(dashboardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId','Required parameter dashboardId was null or undefined when calling getDashboardInfoByIdUsingGET.');
            }
            const localVarPath = `/api/dashboard/info/{dashboardId}`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDashboardsByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {number} pageSize Page size
         * @param {number} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getDashboardsByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getDashboardsByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getDashboardsByEntityGroupIdUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/dashboards{?pageSize,page,textSearch,sortProperty,sortOrder}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDashboardsByIds
         * @param {string} dashboardIds dashboardIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsByIdsUsingGET(dashboardIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardIds' is not null or undefined
            if (dashboardIds === null || dashboardIds === undefined) {
                throw new RequiredError('dashboardIds','Required parameter dashboardIds was null or undefined when calling getDashboardsByIdsUsingGET.');
            }
            const localVarPath = `/api/dashboards{?dashboardIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (dashboardIds !== undefined) {
                localVarQueryParameter['dashboardIds'] = dashboardIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGroupDashboards
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDashboardsUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getGroupDashboardsUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getGroupDashboardsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getGroupDashboardsUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/dashboards{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHomeDashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeDashboardUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/dashboard/home`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMaxDatapointsLimit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxDatapointsLimitUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/dashboard/maxDatapointsLimit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getServerTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerTimeUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/dashboard/serverTime`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantDashboards
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDashboardsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantDashboardsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantDashboardsUsingGET.');
            }
            const localVarPath = `/api/tenant/dashboards{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantDashboards
         * @param {string} tenantId tenantId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDashboardsUsingGET1(tenantId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getTenantDashboardsUsingGET1.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantDashboardsUsingGET1.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantDashboardsUsingGET1.');
            }
            const localVarPath = `/api/tenant/{tenantId}/dashboards{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantHomeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantHomeDashboardInfoUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/tenant/dashboard/home/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserDashboards
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {string} [operation] operation
         * @param {string} [userId] userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDashboardsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, operation?: string, userId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getUserDashboardsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserDashboardsUsingGET.');
            }
            const localVarPath = `/api/user/dashboards{?textSearch,sortProperty,sortOrder,operation,userId,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (operation !== undefined) {
                localVarQueryParameter['operation'] = operation;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary importGroupDashboards
         * @param {string} entityGroupId entityGroupId
         * @param {Array<Dashboard>} dashboardList dashboardList
         * @param {boolean} [overwrite] overwrite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGroupDashboardsUsingPOST(entityGroupId: string, dashboardList: Array<Dashboard>, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling importGroupDashboardsUsingPOST.');
            }
            // verify required parameter 'dashboardList' is not null or undefined
            if (dashboardList === null || dashboardList === undefined) {
                throw new RequiredError('dashboardList','Required parameter dashboardList was null or undefined when calling importGroupDashboardsUsingPOST.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/dashboards/import{?overwrite}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Dashboard&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(dashboardList || {}) : (dashboardList || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveDashboard
         * @param {Dashboard} dashboard dashboard
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDashboardUsingPOST(dashboard: Dashboard, entityGroupId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'dashboard' is not null or undefined
            if (dashboard === null || dashboard === undefined) {
                throw new RequiredError('dashboard','Required parameter dashboard was null or undefined when calling saveDashboardUsingPOST.');
            }
            const localVarPath = `/api/dashboard{?entityGroupId}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (entityGroupId !== undefined) {
                localVarQueryParameter['entityGroupId'] = entityGroupId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(dashboard || {}) : (dashboard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setCustomerHomeDashboardInfo
         * @param {HomeDashboardInfo} homeDashboardInfo homeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerHomeDashboardInfoUsingPOST(homeDashboardInfo: HomeDashboardInfo, options: any = {}): FetchArgs {
            // verify required parameter 'homeDashboardInfo' is not null or undefined
            if (homeDashboardInfo === null || homeDashboardInfo === undefined) {
                throw new RequiredError('homeDashboardInfo','Required parameter homeDashboardInfo was null or undefined when calling setCustomerHomeDashboardInfoUsingPOST.');
            }
            const localVarPath = `/api/customer/dashboard/home/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HomeDashboardInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(homeDashboardInfo || {}) : (homeDashboardInfo || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setTenantHomeDashboardInfo
         * @param {HomeDashboardInfo} homeDashboardInfo homeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTenantHomeDashboardInfoUsingPOST(homeDashboardInfo: HomeDashboardInfo, options: any = {}): FetchArgs {
            // verify required parameter 'homeDashboardInfo' is not null or undefined
            if (homeDashboardInfo === null || homeDashboardInfo === undefined) {
                throw new RequiredError('homeDashboardInfo','Required parameter homeDashboardInfo was null or undefined when calling setTenantHomeDashboardInfoUsingPOST.');
            }
            const localVarPath = `/api/tenant/dashboard/home/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HomeDashboardInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(homeDashboardInfo || {}) : (homeDashboardInfo || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardControllerApi - functional programming interface
 * @export
 */
export const DashboardControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteDashboard
         * @param {string} dashboardId dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardUsingDELETE(dashboardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).deleteDashboardUsingDELETE(dashboardId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary exportGroupDashboards
         * @param {string} entityGroupId entityGroupId
         * @param {string} limit limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportGroupDashboardsUsingGET(entityGroupId: string, limit: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Dashboard>> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).exportGroupDashboardsUsingGET(entityGroupId, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomerHomeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerHomeDashboardInfoUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HomeDashboardInfo> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getCustomerHomeDashboardInfoUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDashboardById
         * @param {string} dashboardId dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardByIdUsingGET(dashboardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Dashboard> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getDashboardByIdUsingGET(dashboardId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDashboardInfoById
         * @param {string} dashboardId dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardInfoByIdUsingGET(dashboardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DashboardInfo> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getDashboardInfoByIdUsingGET(dashboardId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDashboardsByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {number} pageSize Page size
         * @param {number} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDashboardInfo> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getDashboardsByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDashboardsByIds
         * @param {string} dashboardIds dashboardIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsByIdsUsingGET(dashboardIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DashboardInfo>> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getDashboardsByIdsUsingGET(dashboardIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getGroupDashboards
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDashboardsUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDashboardInfo> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getGroupDashboardsUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getHomeDashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeDashboardUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HomeDashboard> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getHomeDashboardUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMaxDatapointsLimit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxDatapointsLimitUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getMaxDatapointsLimitUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getServerTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerTimeUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getServerTimeUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantDashboards
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDashboardsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDashboardInfo> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getTenantDashboardsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantDashboards
         * @param {string} tenantId tenantId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDashboardsUsingGET1(tenantId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDashboardInfo> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getTenantDashboardsUsingGET1(tenantId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantHomeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantHomeDashboardInfoUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HomeDashboardInfo> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getTenantHomeDashboardInfoUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserDashboards
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {string} [operation] operation
         * @param {string} [userId] userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDashboardsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, operation?: string, userId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDashboardInfo> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getUserDashboardsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, operation, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary importGroupDashboards
         * @param {string} entityGroupId entityGroupId
         * @param {Array<Dashboard>} dashboardList dashboardList
         * @param {boolean} [overwrite] overwrite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGroupDashboardsUsingPOST(entityGroupId: string, dashboardList: Array<Dashboard>, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).importGroupDashboardsUsingPOST(entityGroupId, dashboardList, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveDashboard
         * @param {Dashboard} dashboard dashboard
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDashboardUsingPOST(dashboard: Dashboard, entityGroupId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Dashboard> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).saveDashboardUsingPOST(dashboard, entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary setCustomerHomeDashboardInfo
         * @param {HomeDashboardInfo} homeDashboardInfo homeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerHomeDashboardInfoUsingPOST(homeDashboardInfo: HomeDashboardInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).setCustomerHomeDashboardInfoUsingPOST(homeDashboardInfo, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary setTenantHomeDashboardInfo
         * @param {HomeDashboardInfo} homeDashboardInfo homeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTenantHomeDashboardInfoUsingPOST(homeDashboardInfo: HomeDashboardInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).setTenantHomeDashboardInfoUsingPOST(homeDashboardInfo, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DashboardControllerApi - factory interface
 * @export
 */
export const DashboardControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteDashboard
         * @param {string} dashboardId dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardUsingDELETE(dashboardId: string, options?: any) {
            return DashboardControllerApiFp(configuration).deleteDashboardUsingDELETE(dashboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary exportGroupDashboards
         * @param {string} entityGroupId entityGroupId
         * @param {string} limit limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportGroupDashboardsUsingGET(entityGroupId: string, limit: string, options?: any) {
            return DashboardControllerApiFp(configuration).exportGroupDashboardsUsingGET(entityGroupId, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomerHomeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerHomeDashboardInfoUsingGET(options?: any) {
            return DashboardControllerApiFp(configuration).getCustomerHomeDashboardInfoUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDashboardById
         * @param {string} dashboardId dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardByIdUsingGET(dashboardId: string, options?: any) {
            return DashboardControllerApiFp(configuration).getDashboardByIdUsingGET(dashboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDashboardInfoById
         * @param {string} dashboardId dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardInfoByIdUsingGET(dashboardId: string, options?: any) {
            return DashboardControllerApiFp(configuration).getDashboardInfoByIdUsingGET(dashboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDashboardsByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {number} pageSize Page size
         * @param {number} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return DashboardControllerApiFp(configuration).getDashboardsByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDashboardsByIds
         * @param {string} dashboardIds dashboardIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsByIdsUsingGET(dashboardIds: string, options?: any) {
            return DashboardControllerApiFp(configuration).getDashboardsByIdsUsingGET(dashboardIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getGroupDashboards
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDashboardsUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return DashboardControllerApiFp(configuration).getGroupDashboardsUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getHomeDashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeDashboardUsingGET(options?: any) {
            return DashboardControllerApiFp(configuration).getHomeDashboardUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMaxDatapointsLimit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxDatapointsLimitUsingGET(options?: any) {
            return DashboardControllerApiFp(configuration).getMaxDatapointsLimitUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getServerTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerTimeUsingGET(options?: any) {
            return DashboardControllerApiFp(configuration).getServerTimeUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantDashboards
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDashboardsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return DashboardControllerApiFp(configuration).getTenantDashboardsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantDashboards
         * @param {string} tenantId tenantId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDashboardsUsingGET1(tenantId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return DashboardControllerApiFp(configuration).getTenantDashboardsUsingGET1(tenantId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantHomeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantHomeDashboardInfoUsingGET(options?: any) {
            return DashboardControllerApiFp(configuration).getTenantHomeDashboardInfoUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserDashboards
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {string} [operation] operation
         * @param {string} [userId] userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDashboardsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, operation?: string, userId?: string, options?: any) {
            return DashboardControllerApiFp(configuration).getUserDashboardsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, operation, userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary importGroupDashboards
         * @param {string} entityGroupId entityGroupId
         * @param {Array<Dashboard>} dashboardList dashboardList
         * @param {boolean} [overwrite] overwrite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGroupDashboardsUsingPOST(entityGroupId: string, dashboardList: Array<Dashboard>, overwrite?: boolean, options?: any) {
            return DashboardControllerApiFp(configuration).importGroupDashboardsUsingPOST(entityGroupId, dashboardList, overwrite, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveDashboard
         * @param {Dashboard} dashboard dashboard
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDashboardUsingPOST(dashboard: Dashboard, entityGroupId?: string, options?: any) {
            return DashboardControllerApiFp(configuration).saveDashboardUsingPOST(dashboard, entityGroupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary setCustomerHomeDashboardInfo
         * @param {HomeDashboardInfo} homeDashboardInfo homeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerHomeDashboardInfoUsingPOST(homeDashboardInfo: HomeDashboardInfo, options?: any) {
            return DashboardControllerApiFp(configuration).setCustomerHomeDashboardInfoUsingPOST(homeDashboardInfo, options)(fetch, basePath);
        },
        /**
         * 
         * @summary setTenantHomeDashboardInfo
         * @param {HomeDashboardInfo} homeDashboardInfo homeDashboardInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTenantHomeDashboardInfoUsingPOST(homeDashboardInfo: HomeDashboardInfo, options?: any) {
            return DashboardControllerApiFp(configuration).setTenantHomeDashboardInfoUsingPOST(homeDashboardInfo, options)(fetch, basePath);
        },
    };
};

/**
 * DashboardControllerApi - object-oriented interface
 * @export
 * @class DashboardControllerApi
 * @extends {BaseAPI}
 */
export class DashboardControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteDashboard
     * @param {string} dashboardId dashboardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public deleteDashboardUsingDELETE(dashboardId: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).deleteDashboardUsingDELETE(dashboardId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary exportGroupDashboards
     * @param {string} entityGroupId entityGroupId
     * @param {string} limit limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public exportGroupDashboardsUsingGET(entityGroupId: string, limit: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).exportGroupDashboardsUsingGET(entityGroupId, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomerHomeDashboardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getCustomerHomeDashboardInfoUsingGET(options?: any) {
        return DashboardControllerApiFp(this.configuration).getCustomerHomeDashboardInfoUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDashboardById
     * @param {string} dashboardId dashboardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getDashboardByIdUsingGET(dashboardId: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).getDashboardByIdUsingGET(dashboardId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDashboardInfoById
     * @param {string} dashboardId dashboardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getDashboardInfoByIdUsingGET(dashboardId: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).getDashboardInfoByIdUsingGET(dashboardId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDashboardsByEntityGroupId
     * @param {string} entityGroupId entityGroupId
     * @param {number} pageSize Page size
     * @param {number} page Page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getDashboardsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).getDashboardsByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDashboardsByIds
     * @param {string} dashboardIds dashboardIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getDashboardsByIdsUsingGET(dashboardIds: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).getDashboardsByIdsUsingGET(dashboardIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getGroupDashboards
     * @param {string} entityGroupId entityGroupId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getGroupDashboardsUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).getGroupDashboardsUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getHomeDashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getHomeDashboardUsingGET(options?: any) {
        return DashboardControllerApiFp(this.configuration).getHomeDashboardUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMaxDatapointsLimit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getMaxDatapointsLimitUsingGET(options?: any) {
        return DashboardControllerApiFp(this.configuration).getMaxDatapointsLimitUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getServerTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getServerTimeUsingGET(options?: any) {
        return DashboardControllerApiFp(this.configuration).getServerTimeUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantDashboards
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getTenantDashboardsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).getTenantDashboardsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantDashboards
     * @param {string} tenantId tenantId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getTenantDashboardsUsingGET1(tenantId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).getTenantDashboardsUsingGET1(tenantId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantHomeDashboardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getTenantHomeDashboardInfoUsingGET(options?: any) {
        return DashboardControllerApiFp(this.configuration).getTenantHomeDashboardInfoUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserDashboards
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {string} [operation] operation
     * @param {string} [userId] userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getUserDashboardsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, operation?: string, userId?: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).getUserDashboardsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, operation, userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary importGroupDashboards
     * @param {string} entityGroupId entityGroupId
     * @param {Array<Dashboard>} dashboardList dashboardList
     * @param {boolean} [overwrite] overwrite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public importGroupDashboardsUsingPOST(entityGroupId: string, dashboardList: Array<Dashboard>, overwrite?: boolean, options?: any) {
        return DashboardControllerApiFp(this.configuration).importGroupDashboardsUsingPOST(entityGroupId, dashboardList, overwrite, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveDashboard
     * @param {Dashboard} dashboard dashboard
     * @param {string} [entityGroupId] entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public saveDashboardUsingPOST(dashboard: Dashboard, entityGroupId?: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).saveDashboardUsingPOST(dashboard, entityGroupId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary setCustomerHomeDashboardInfo
     * @param {HomeDashboardInfo} homeDashboardInfo homeDashboardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public setCustomerHomeDashboardInfoUsingPOST(homeDashboardInfo: HomeDashboardInfo, options?: any) {
        return DashboardControllerApiFp(this.configuration).setCustomerHomeDashboardInfoUsingPOST(homeDashboardInfo, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary setTenantHomeDashboardInfo
     * @param {HomeDashboardInfo} homeDashboardInfo homeDashboardInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public setTenantHomeDashboardInfoUsingPOST(homeDashboardInfo: HomeDashboardInfo, options?: any) {
        return DashboardControllerApiFp(this.configuration).setTenantHomeDashboardInfoUsingPOST(homeDashboardInfo, options)(this.fetch, this.basePath);
    }

}

/**
 * DeviceApiControllerApi - fetch parameter creator
 * @export
 */
export const DeviceApiControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary claimDevice
         * @param {string} deviceToken deviceToken
         * @param {string} [json] json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDeviceUsingPOST(deviceToken: string, json?: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceToken' is not null or undefined
            if (deviceToken === null || deviceToken === undefined) {
                throw new RequiredError('deviceToken','Required parameter deviceToken was null or undefined when calling claimDeviceUsingPOST.');
            }
            const localVarPath = `/api/v1/{deviceToken}/claim`
                .replace(`{${"deviceToken"}}`, encodeURIComponent(String(deviceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(json || {}) : (json || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDeviceAttributes
         * @param {string} deviceToken deviceToken
         * @param {string} [clientKeys] clientKeys
         * @param {string} [sharedKeys] sharedKeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAttributesUsingGET(deviceToken: string, clientKeys?: string, sharedKeys?: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceToken' is not null or undefined
            if (deviceToken === null || deviceToken === undefined) {
                throw new RequiredError('deviceToken','Required parameter deviceToken was null or undefined when calling getDeviceAttributesUsingGET.');
            }
            const localVarPath = `/api/v1/{deviceToken}/attributes{?clientKeys,sharedKeys}`
                .replace(`{${"deviceToken"}}`, encodeURIComponent(String(deviceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (clientKeys !== undefined) {
                localVarQueryParameter['clientKeys'] = clientKeys;
            }

            if (sharedKeys !== undefined) {
                localVarQueryParameter['sharedKeys'] = sharedKeys;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary postDeviceAttributes
         * @param {string} deviceToken deviceToken
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeviceAttributesUsingPOST(deviceToken: string, json: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceToken' is not null or undefined
            if (deviceToken === null || deviceToken === undefined) {
                throw new RequiredError('deviceToken','Required parameter deviceToken was null or undefined when calling postDeviceAttributesUsingPOST.');
            }
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling postDeviceAttributesUsingPOST.');
            }
            const localVarPath = `/api/v1/{deviceToken}/attributes`
                .replace(`{${"deviceToken"}}`, encodeURIComponent(String(deviceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(json || {}) : (json || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary postRpcRequest
         * @param {string} deviceToken deviceToken
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRpcRequestUsingPOST(deviceToken: string, json: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceToken' is not null or undefined
            if (deviceToken === null || deviceToken === undefined) {
                throw new RequiredError('deviceToken','Required parameter deviceToken was null or undefined when calling postRpcRequestUsingPOST.');
            }
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling postRpcRequestUsingPOST.');
            }
            const localVarPath = `/api/v1/{deviceToken}/rpc`
                .replace(`{${"deviceToken"}}`, encodeURIComponent(String(deviceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(json || {}) : (json || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary postTelemetry
         * @param {string} deviceToken deviceToken
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelemetryUsingPOST(deviceToken: string, json: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceToken' is not null or undefined
            if (deviceToken === null || deviceToken === undefined) {
                throw new RequiredError('deviceToken','Required parameter deviceToken was null or undefined when calling postTelemetryUsingPOST.');
            }
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling postTelemetryUsingPOST.');
            }
            const localVarPath = `/api/v1/{deviceToken}/telemetry`
                .replace(`{${"deviceToken"}}`, encodeURIComponent(String(deviceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(json || {}) : (json || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary provisionDevice
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionDeviceUsingPOST(json: string, options: any = {}): FetchArgs {
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling provisionDeviceUsingPOST.');
            }
            const localVarPath = `/api/v1/provision`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(json || {}) : (json || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary replyToCommand
         * @param {string} deviceToken deviceToken
         * @param {number} requestId requestId
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToCommandUsingPOST(deviceToken: string, requestId: number, json: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceToken' is not null or undefined
            if (deviceToken === null || deviceToken === undefined) {
                throw new RequiredError('deviceToken','Required parameter deviceToken was null or undefined when calling replyToCommandUsingPOST.');
            }
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling replyToCommandUsingPOST.');
            }
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling replyToCommandUsingPOST.');
            }
            const localVarPath = `/api/v1/{deviceToken}/rpc/{requestId}`
                .replace(`{${"deviceToken"}}`, encodeURIComponent(String(deviceToken)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(json || {}) : (json || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary subscribeToAttributes
         * @param {string} deviceToken deviceToken
         * @param {number} [timeout] timeout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToAttributesUsingGET(deviceToken: string, timeout?: number, options: any = {}): FetchArgs {
            // verify required parameter 'deviceToken' is not null or undefined
            if (deviceToken === null || deviceToken === undefined) {
                throw new RequiredError('deviceToken','Required parameter deviceToken was null or undefined when calling subscribeToAttributesUsingGET.');
            }
            const localVarPath = `/api/v1/{deviceToken}/attributes/updates{?timeout}`
                .replace(`{${"deviceToken"}}`, encodeURIComponent(String(deviceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary subscribeToCommands
         * @param {string} deviceToken deviceToken
         * @param {number} [timeout] timeout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToCommandsUsingGET(deviceToken: string, timeout?: number, options: any = {}): FetchArgs {
            // verify required parameter 'deviceToken' is not null or undefined
            if (deviceToken === null || deviceToken === undefined) {
                throw new RequiredError('deviceToken','Required parameter deviceToken was null or undefined when calling subscribeToCommandsUsingGET.');
            }
            const localVarPath = `/api/v1/{deviceToken}/rpc{?timeout}`
                .replace(`{${"deviceToken"}}`, encodeURIComponent(String(deviceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApiControllerApi - functional programming interface
 * @export
 */
export const DeviceApiControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary claimDevice
         * @param {string} deviceToken deviceToken
         * @param {string} [json] json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDeviceUsingPOST(deviceToken: string, json?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceApiControllerApiFetchParamCreator(configuration).claimDeviceUsingPOST(deviceToken, json, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDeviceAttributes
         * @param {string} deviceToken deviceToken
         * @param {string} [clientKeys] clientKeys
         * @param {string} [sharedKeys] sharedKeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAttributesUsingGET(deviceToken: string, clientKeys?: string, sharedKeys?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceApiControllerApiFetchParamCreator(configuration).getDeviceAttributesUsingGET(deviceToken, clientKeys, sharedKeys, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary postDeviceAttributes
         * @param {string} deviceToken deviceToken
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeviceAttributesUsingPOST(deviceToken: string, json: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceApiControllerApiFetchParamCreator(configuration).postDeviceAttributesUsingPOST(deviceToken, json, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary postRpcRequest
         * @param {string} deviceToken deviceToken
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRpcRequestUsingPOST(deviceToken: string, json: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceApiControllerApiFetchParamCreator(configuration).postRpcRequestUsingPOST(deviceToken, json, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary postTelemetry
         * @param {string} deviceToken deviceToken
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelemetryUsingPOST(deviceToken: string, json: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceApiControllerApiFetchParamCreator(configuration).postTelemetryUsingPOST(deviceToken, json, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary provisionDevice
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionDeviceUsingPOST(json: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceApiControllerApiFetchParamCreator(configuration).provisionDeviceUsingPOST(json, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary replyToCommand
         * @param {string} deviceToken deviceToken
         * @param {number} requestId requestId
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToCommandUsingPOST(deviceToken: string, requestId: number, json: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceApiControllerApiFetchParamCreator(configuration).replyToCommandUsingPOST(deviceToken, requestId, json, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary subscribeToAttributes
         * @param {string} deviceToken deviceToken
         * @param {number} [timeout] timeout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToAttributesUsingGET(deviceToken: string, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceApiControllerApiFetchParamCreator(configuration).subscribeToAttributesUsingGET(deviceToken, timeout, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary subscribeToCommands
         * @param {string} deviceToken deviceToken
         * @param {number} [timeout] timeout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToCommandsUsingGET(deviceToken: string, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceApiControllerApiFetchParamCreator(configuration).subscribeToCommandsUsingGET(deviceToken, timeout, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceApiControllerApi - factory interface
 * @export
 */
export const DeviceApiControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary claimDevice
         * @param {string} deviceToken deviceToken
         * @param {string} [json] json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDeviceUsingPOST(deviceToken: string, json?: string, options?: any) {
            return DeviceApiControllerApiFp(configuration).claimDeviceUsingPOST(deviceToken, json, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDeviceAttributes
         * @param {string} deviceToken deviceToken
         * @param {string} [clientKeys] clientKeys
         * @param {string} [sharedKeys] sharedKeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceAttributesUsingGET(deviceToken: string, clientKeys?: string, sharedKeys?: string, options?: any) {
            return DeviceApiControllerApiFp(configuration).getDeviceAttributesUsingGET(deviceToken, clientKeys, sharedKeys, options)(fetch, basePath);
        },
        /**
         * 
         * @summary postDeviceAttributes
         * @param {string} deviceToken deviceToken
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeviceAttributesUsingPOST(deviceToken: string, json: string, options?: any) {
            return DeviceApiControllerApiFp(configuration).postDeviceAttributesUsingPOST(deviceToken, json, options)(fetch, basePath);
        },
        /**
         * 
         * @summary postRpcRequest
         * @param {string} deviceToken deviceToken
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRpcRequestUsingPOST(deviceToken: string, json: string, options?: any) {
            return DeviceApiControllerApiFp(configuration).postRpcRequestUsingPOST(deviceToken, json, options)(fetch, basePath);
        },
        /**
         * 
         * @summary postTelemetry
         * @param {string} deviceToken deviceToken
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelemetryUsingPOST(deviceToken: string, json: string, options?: any) {
            return DeviceApiControllerApiFp(configuration).postTelemetryUsingPOST(deviceToken, json, options)(fetch, basePath);
        },
        /**
         * 
         * @summary provisionDevice
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionDeviceUsingPOST(json: string, options?: any) {
            return DeviceApiControllerApiFp(configuration).provisionDeviceUsingPOST(json, options)(fetch, basePath);
        },
        /**
         * 
         * @summary replyToCommand
         * @param {string} deviceToken deviceToken
         * @param {number} requestId requestId
         * @param {string} json json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToCommandUsingPOST(deviceToken: string, requestId: number, json: string, options?: any) {
            return DeviceApiControllerApiFp(configuration).replyToCommandUsingPOST(deviceToken, requestId, json, options)(fetch, basePath);
        },
        /**
         * 
         * @summary subscribeToAttributes
         * @param {string} deviceToken deviceToken
         * @param {number} [timeout] timeout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToAttributesUsingGET(deviceToken: string, timeout?: number, options?: any) {
            return DeviceApiControllerApiFp(configuration).subscribeToAttributesUsingGET(deviceToken, timeout, options)(fetch, basePath);
        },
        /**
         * 
         * @summary subscribeToCommands
         * @param {string} deviceToken deviceToken
         * @param {number} [timeout] timeout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToCommandsUsingGET(deviceToken: string, timeout?: number, options?: any) {
            return DeviceApiControllerApiFp(configuration).subscribeToCommandsUsingGET(deviceToken, timeout, options)(fetch, basePath);
        },
    };
};

/**
 * DeviceApiControllerApi - object-oriented interface
 * @export
 * @class DeviceApiControllerApi
 * @extends {BaseAPI}
 */
export class DeviceApiControllerApi extends BaseAPI {
    /**
     * 
     * @summary claimDevice
     * @param {string} deviceToken deviceToken
     * @param {string} [json] json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiControllerApi
     */
    public claimDeviceUsingPOST(deviceToken: string, json?: string, options?: any) {
        return DeviceApiControllerApiFp(this.configuration).claimDeviceUsingPOST(deviceToken, json, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDeviceAttributes
     * @param {string} deviceToken deviceToken
     * @param {string} [clientKeys] clientKeys
     * @param {string} [sharedKeys] sharedKeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiControllerApi
     */
    public getDeviceAttributesUsingGET(deviceToken: string, clientKeys?: string, sharedKeys?: string, options?: any) {
        return DeviceApiControllerApiFp(this.configuration).getDeviceAttributesUsingGET(deviceToken, clientKeys, sharedKeys, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary postDeviceAttributes
     * @param {string} deviceToken deviceToken
     * @param {string} json json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiControllerApi
     */
    public postDeviceAttributesUsingPOST(deviceToken: string, json: string, options?: any) {
        return DeviceApiControllerApiFp(this.configuration).postDeviceAttributesUsingPOST(deviceToken, json, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary postRpcRequest
     * @param {string} deviceToken deviceToken
     * @param {string} json json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiControllerApi
     */
    public postRpcRequestUsingPOST(deviceToken: string, json: string, options?: any) {
        return DeviceApiControllerApiFp(this.configuration).postRpcRequestUsingPOST(deviceToken, json, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary postTelemetry
     * @param {string} deviceToken deviceToken
     * @param {string} json json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiControllerApi
     */
    public postTelemetryUsingPOST(deviceToken: string, json: string, options?: any) {
        return DeviceApiControllerApiFp(this.configuration).postTelemetryUsingPOST(deviceToken, json, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary provisionDevice
     * @param {string} json json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiControllerApi
     */
    public provisionDeviceUsingPOST(json: string, options?: any) {
        return DeviceApiControllerApiFp(this.configuration).provisionDeviceUsingPOST(json, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary replyToCommand
     * @param {string} deviceToken deviceToken
     * @param {number} requestId requestId
     * @param {string} json json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiControllerApi
     */
    public replyToCommandUsingPOST(deviceToken: string, requestId: number, json: string, options?: any) {
        return DeviceApiControllerApiFp(this.configuration).replyToCommandUsingPOST(deviceToken, requestId, json, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary subscribeToAttributes
     * @param {string} deviceToken deviceToken
     * @param {number} [timeout] timeout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiControllerApi
     */
    public subscribeToAttributesUsingGET(deviceToken: string, timeout?: number, options?: any) {
        return DeviceApiControllerApiFp(this.configuration).subscribeToAttributesUsingGET(deviceToken, timeout, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary subscribeToCommands
     * @param {string} deviceToken deviceToken
     * @param {number} [timeout] timeout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiControllerApi
     */
    public subscribeToCommandsUsingGET(deviceToken: string, timeout?: number, options?: any) {
        return DeviceApiControllerApiFp(this.configuration).subscribeToCommandsUsingGET(deviceToken, timeout, options)(this.fetch, this.basePath);
    }

}

/**
 * DeviceControllerApi - fetch parameter creator
 * @export
 */
export const DeviceControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary assignDeviceToTenant
         * @param {string} tenantId tenantId
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignDeviceToTenantUsingPOST(tenantId: string, deviceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling assignDeviceToTenantUsingPOST.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling assignDeviceToTenantUsingPOST.');
            }
            const localVarPath = `/api/tenant/{tenantId}/device/{deviceId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary claimDevice
         * @param {string} deviceName deviceName
         * @param {ClaimRequest} [claimRequest] claimRequest
         * @param {string} [subCustomerId] subCustomerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDeviceUsingPOST1(deviceName: string, claimRequest?: ClaimRequest, subCustomerId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceName' is not null or undefined
            if (deviceName === null || deviceName === undefined) {
                throw new RequiredError('deviceName','Required parameter deviceName was null or undefined when calling claimDeviceUsingPOST1.');
            }
            const localVarPath = `/api/customer/device/{deviceName}/claim{?subCustomerId}`
                .replace(`{${"deviceName"}}`, encodeURIComponent(String(deviceName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (subCustomerId !== undefined) {
                localVarQueryParameter['subCustomerId'] = subCustomerId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClaimRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(claimRequest || {}) : (claimRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteDevice
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceUsingDELETE(deviceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling deleteDeviceUsingDELETE.');
            }
            const localVarPath = `/api/device/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByQuery
         * @param {DeviceSearchQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST1(query: DeviceSearchQuery, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling findByQueryUsingPOST1.');
            }
            const localVarPath = `/api/devices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceSearchQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomerDevices
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDevicesUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomerDevicesUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getCustomerDevicesUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getCustomerDevicesUsingGET.');
            }
            const localVarPath = `/api/customer/{customerId}/devices{?type,textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDeviceById
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceByIdUsingGET(deviceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling getDeviceByIdUsingGET.');
            }
            const localVarPath = `/api/device/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDeviceCredentialsByDeviceId
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceCredentialsByDeviceIdUsingGET(deviceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling getDeviceCredentialsByDeviceIdUsingGET.');
            }
            const localVarPath = `/api/device/{deviceId}/credentials`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDeviceTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceTypesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/device/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDevicesByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getDevicesByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getDevicesByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getDevicesByEntityGroupIdUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/devices{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDevicesByIds
         * @param {string} deviceIds deviceIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesByIdsUsingGET(deviceIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceIds' is not null or undefined
            if (deviceIds === null || deviceIds === undefined) {
                throw new RequiredError('deviceIds','Required parameter deviceIds was null or undefined when calling getDevicesByIdsUsingGET.');
            }
            const localVarPath = `/api/devices{?deviceIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (deviceIds !== undefined) {
                localVarQueryParameter['deviceIds'] = deviceIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantDevice
         * @param {string} deviceName deviceName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDeviceUsingGET(deviceName: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceName' is not null or undefined
            if (deviceName === null || deviceName === undefined) {
                throw new RequiredError('deviceName','Required parameter deviceName was null or undefined when calling getTenantDeviceUsingGET.');
            }
            const localVarPath = `/api/tenant/devices{?deviceName}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (deviceName !== undefined) {
                localVarQueryParameter['deviceName'] = deviceName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantDevices
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDevicesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantDevicesUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantDevicesUsingGET.');
            }
            const localVarPath = `/api/tenant/devices{?type,textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserDevices
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDevicesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getUserDevicesUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserDevicesUsingGET.');
            }
            const localVarPath = `/api/user/devices{?type,textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reClaimDevice
         * @param {string} deviceName deviceName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reClaimDeviceUsingDELETE(deviceName: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceName' is not null or undefined
            if (deviceName === null || deviceName === undefined) {
                throw new RequiredError('deviceName','Required parameter deviceName was null or undefined when calling reClaimDeviceUsingDELETE.');
            }
            const localVarPath = `/api/customer/device/{deviceName}/claim`
                .replace(`{${"deviceName"}}`, encodeURIComponent(String(deviceName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveDeviceCredentials
         * @param {DeviceCredentials} deviceCredentials deviceCredentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceCredentialsUsingPOST(deviceCredentials: DeviceCredentials, options: any = {}): FetchArgs {
            // verify required parameter 'deviceCredentials' is not null or undefined
            if (deviceCredentials === null || deviceCredentials === undefined) {
                throw new RequiredError('deviceCredentials','Required parameter deviceCredentials was null or undefined when calling saveDeviceCredentialsUsingPOST.');
            }
            const localVarPath = `/api/device/credentials`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceCredentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deviceCredentials || {}) : (deviceCredentials || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveDevice
         * @param {Device} device device
         * @param {string} [accessToken] accessToken
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceUsingPOST(device: Device, accessToken?: string, entityGroupId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'device' is not null or undefined
            if (device === null || device === undefined) {
                throw new RequiredError('device','Required parameter device was null or undefined when calling saveDeviceUsingPOST.');
            }
            const localVarPath = `/api/device{?accessToken,entityGroupId}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (accessToken !== undefined) {
                localVarQueryParameter['accessToken'] = accessToken;
            }

            if (entityGroupId !== undefined) {
                localVarQueryParameter['entityGroupId'] = entityGroupId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Device" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(device || {}) : (device || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceControllerApi - functional programming interface
 * @export
 */
export const DeviceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary assignDeviceToTenant
         * @param {string} tenantId tenantId
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignDeviceToTenantUsingPOST(tenantId: string, deviceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Device> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).assignDeviceToTenantUsingPOST(tenantId, deviceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary claimDevice
         * @param {string} deviceName deviceName
         * @param {ClaimRequest} [claimRequest] claimRequest
         * @param {string} [subCustomerId] subCustomerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDeviceUsingPOST1(deviceName: string, claimRequest?: ClaimRequest, subCustomerId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).claimDeviceUsingPOST1(deviceName, claimRequest, subCustomerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteDevice
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceUsingDELETE(deviceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).deleteDeviceUsingDELETE(deviceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findByQuery
         * @param {DeviceSearchQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST1(query: DeviceSearchQuery, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Device>> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).findByQueryUsingPOST1(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomerDevices
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDevicesUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDevice> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).getCustomerDevicesUsingGET(customerId, pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDeviceById
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceByIdUsingGET(deviceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Device> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).getDeviceByIdUsingGET(deviceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDeviceCredentialsByDeviceId
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceCredentialsByDeviceIdUsingGET(deviceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceCredentials> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).getDeviceCredentialsByDeviceIdUsingGET(deviceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDeviceTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceTypesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntitySubtype>> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).getDeviceTypesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDevicesByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDevice> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).getDevicesByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDevicesByIds
         * @param {string} deviceIds deviceIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesByIdsUsingGET(deviceIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Device>> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).getDevicesByIdsUsingGET(deviceIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantDevice
         * @param {string} deviceName deviceName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDeviceUsingGET(deviceName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Device> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).getTenantDeviceUsingGET(deviceName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantDevices
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDevicesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDevice> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).getTenantDevicesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserDevices
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDevicesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDevice> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).getUserDevicesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary reClaimDevice
         * @param {string} deviceName deviceName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reClaimDeviceUsingDELETE(deviceName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).reClaimDeviceUsingDELETE(deviceName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveDeviceCredentials
         * @param {DeviceCredentials} deviceCredentials deviceCredentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceCredentialsUsingPOST(deviceCredentials: DeviceCredentials, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceCredentials> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).saveDeviceCredentialsUsingPOST(deviceCredentials, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveDevice
         * @param {Device} device device
         * @param {string} [accessToken] accessToken
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceUsingPOST(device: Device, accessToken?: string, entityGroupId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Device> {
            const localVarFetchArgs = DeviceControllerApiFetchParamCreator(configuration).saveDeviceUsingPOST(device, accessToken, entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceControllerApi - factory interface
 * @export
 */
export const DeviceControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary assignDeviceToTenant
         * @param {string} tenantId tenantId
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignDeviceToTenantUsingPOST(tenantId: string, deviceId: string, options?: any) {
            return DeviceControllerApiFp(configuration).assignDeviceToTenantUsingPOST(tenantId, deviceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary claimDevice
         * @param {string} deviceName deviceName
         * @param {ClaimRequest} [claimRequest] claimRequest
         * @param {string} [subCustomerId] subCustomerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDeviceUsingPOST1(deviceName: string, claimRequest?: ClaimRequest, subCustomerId?: string, options?: any) {
            return DeviceControllerApiFp(configuration).claimDeviceUsingPOST1(deviceName, claimRequest, subCustomerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteDevice
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceUsingDELETE(deviceId: string, options?: any) {
            return DeviceControllerApiFp(configuration).deleteDeviceUsingDELETE(deviceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findByQuery
         * @param {DeviceSearchQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST1(query: DeviceSearchQuery, options?: any) {
            return DeviceControllerApiFp(configuration).findByQueryUsingPOST1(query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomerDevices
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDevicesUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return DeviceControllerApiFp(configuration).getCustomerDevicesUsingGET(customerId, pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDeviceById
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceByIdUsingGET(deviceId: string, options?: any) {
            return DeviceControllerApiFp(configuration).getDeviceByIdUsingGET(deviceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDeviceCredentialsByDeviceId
         * @param {string} deviceId deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceCredentialsByDeviceIdUsingGET(deviceId: string, options?: any) {
            return DeviceControllerApiFp(configuration).getDeviceCredentialsByDeviceIdUsingGET(deviceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDeviceTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceTypesUsingGET(options?: any) {
            return DeviceControllerApiFp(configuration).getDeviceTypesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDevicesByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return DeviceControllerApiFp(configuration).getDevicesByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDevicesByIds
         * @param {string} deviceIds deviceIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesByIdsUsingGET(deviceIds: string, options?: any) {
            return DeviceControllerApiFp(configuration).getDevicesByIdsUsingGET(deviceIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantDevice
         * @param {string} deviceName deviceName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDeviceUsingGET(deviceName: string, options?: any) {
            return DeviceControllerApiFp(configuration).getTenantDeviceUsingGET(deviceName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantDevices
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantDevicesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return DeviceControllerApiFp(configuration).getTenantDevicesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserDevices
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDevicesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return DeviceControllerApiFp(configuration).getUserDevicesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary reClaimDevice
         * @param {string} deviceName deviceName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reClaimDeviceUsingDELETE(deviceName: string, options?: any) {
            return DeviceControllerApiFp(configuration).reClaimDeviceUsingDELETE(deviceName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveDeviceCredentials
         * @param {DeviceCredentials} deviceCredentials deviceCredentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceCredentialsUsingPOST(deviceCredentials: DeviceCredentials, options?: any) {
            return DeviceControllerApiFp(configuration).saveDeviceCredentialsUsingPOST(deviceCredentials, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveDevice
         * @param {Device} device device
         * @param {string} [accessToken] accessToken
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceUsingPOST(device: Device, accessToken?: string, entityGroupId?: string, options?: any) {
            return DeviceControllerApiFp(configuration).saveDeviceUsingPOST(device, accessToken, entityGroupId, options)(fetch, basePath);
        },
    };
};

/**
 * DeviceControllerApi - object-oriented interface
 * @export
 * @class DeviceControllerApi
 * @extends {BaseAPI}
 */
export class DeviceControllerApi extends BaseAPI {
    /**
     * 
     * @summary assignDeviceToTenant
     * @param {string} tenantId tenantId
     * @param {string} deviceId deviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public assignDeviceToTenantUsingPOST(tenantId: string, deviceId: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).assignDeviceToTenantUsingPOST(tenantId, deviceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary claimDevice
     * @param {string} deviceName deviceName
     * @param {ClaimRequest} [claimRequest] claimRequest
     * @param {string} [subCustomerId] subCustomerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public claimDeviceUsingPOST1(deviceName: string, claimRequest?: ClaimRequest, subCustomerId?: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).claimDeviceUsingPOST1(deviceName, claimRequest, subCustomerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteDevice
     * @param {string} deviceId deviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deleteDeviceUsingDELETE(deviceId: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).deleteDeviceUsingDELETE(deviceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findByQuery
     * @param {DeviceSearchQuery} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public findByQueryUsingPOST1(query: DeviceSearchQuery, options?: any) {
        return DeviceControllerApiFp(this.configuration).findByQueryUsingPOST1(query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomerDevices
     * @param {string} customerId customerId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public getCustomerDevicesUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).getCustomerDevicesUsingGET(customerId, pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDeviceById
     * @param {string} deviceId deviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public getDeviceByIdUsingGET(deviceId: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).getDeviceByIdUsingGET(deviceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDeviceCredentialsByDeviceId
     * @param {string} deviceId deviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public getDeviceCredentialsByDeviceIdUsingGET(deviceId: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).getDeviceCredentialsByDeviceIdUsingGET(deviceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDeviceTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public getDeviceTypesUsingGET(options?: any) {
        return DeviceControllerApiFp(this.configuration).getDeviceTypesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDevicesByEntityGroupId
     * @param {string} entityGroupId entityGroupId
     * @param {string} pageSize Page size
     * @param {string} page Page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public getDevicesByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).getDevicesByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDevicesByIds
     * @param {string} deviceIds deviceIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public getDevicesByIdsUsingGET(deviceIds: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).getDevicesByIdsUsingGET(deviceIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantDevice
     * @param {string} deviceName deviceName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public getTenantDeviceUsingGET(deviceName: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).getTenantDeviceUsingGET(deviceName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantDevices
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public getTenantDevicesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).getTenantDevicesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserDevices
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public getUserDevicesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).getUserDevicesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary reClaimDevice
     * @param {string} deviceName deviceName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public reClaimDeviceUsingDELETE(deviceName: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).reClaimDeviceUsingDELETE(deviceName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveDeviceCredentials
     * @param {DeviceCredentials} deviceCredentials deviceCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public saveDeviceCredentialsUsingPOST(deviceCredentials: DeviceCredentials, options?: any) {
        return DeviceControllerApiFp(this.configuration).saveDeviceCredentialsUsingPOST(deviceCredentials, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveDevice
     * @param {Device} device device
     * @param {string} [accessToken] accessToken
     * @param {string} [entityGroupId] entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public saveDeviceUsingPOST(device: Device, accessToken?: string, entityGroupId?: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).saveDeviceUsingPOST(device, accessToken, entityGroupId, options)(this.fetch, this.basePath);
    }

}

/**
 * DeviceProfileControllerApi - fetch parameter creator
 * @export
 */
export const DeviceProfileControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteDeviceProfile
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceProfileUsingDELETE(deviceProfileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceProfileId' is not null or undefined
            if (deviceProfileId === null || deviceProfileId === undefined) {
                throw new RequiredError('deviceProfileId','Required parameter deviceProfileId was null or undefined when calling deleteDeviceProfileUsingDELETE.');
            }
            const localVarPath = `/api/deviceProfile/{deviceProfileId}`
                .replace(`{${"deviceProfileId"}}`, encodeURIComponent(String(deviceProfileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAttributesKeys
         * @param {string} [deviceProfileId] deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesKeysUsingGET(deviceProfileId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/deviceProfile/devices/keys/attributes{?deviceProfileId}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDefaultDeviceProfileInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDeviceProfileInfoUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/deviceProfileInfo/default`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDeviceProfileById
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfileByIdUsingGET(deviceProfileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceProfileId' is not null or undefined
            if (deviceProfileId === null || deviceProfileId === undefined) {
                throw new RequiredError('deviceProfileId','Required parameter deviceProfileId was null or undefined when calling getDeviceProfileByIdUsingGET.');
            }
            const localVarPath = `/api/deviceProfile/{deviceProfileId}`
                .replace(`{${"deviceProfileId"}}`, encodeURIComponent(String(deviceProfileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDeviceProfileInfoById
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfileInfoByIdUsingGET(deviceProfileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceProfileId' is not null or undefined
            if (deviceProfileId === null || deviceProfileId === undefined) {
                throw new RequiredError('deviceProfileId','Required parameter deviceProfileId was null or undefined when calling getDeviceProfileInfoByIdUsingGET.');
            }
            const localVarPath = `/api/deviceProfileInfo/{deviceProfileId}`
                .replace(`{${"deviceProfileId"}}`, encodeURIComponent(String(deviceProfileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDeviceProfileInfos
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {string} [transportType] transportType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfileInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, transportType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getDeviceProfileInfosUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getDeviceProfileInfosUsingGET.');
            }
            const localVarPath = `/api/deviceProfileInfos{?textSearch,sortProperty,sortOrder,transportType,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (transportType !== undefined) {
                localVarQueryParameter['transportType'] = transportType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDeviceProfiles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfilesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getDeviceProfilesUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getDeviceProfilesUsingGET.');
            }
            const localVarPath = `/api/deviceProfiles{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTimeseriesKeys
         * @param {string} [deviceProfileId] deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseriesKeysUsingGET(deviceProfileId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/deviceProfile/devices/keys/timeseries{?deviceProfileId}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveDeviceProfile
         * @param {DeviceProfile} deviceProfile deviceProfile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceProfileUsingPOST(deviceProfile: DeviceProfile, options: any = {}): FetchArgs {
            // verify required parameter 'deviceProfile' is not null or undefined
            if (deviceProfile === null || deviceProfile === undefined) {
                throw new RequiredError('deviceProfile','Required parameter deviceProfile was null or undefined when calling saveDeviceProfileUsingPOST.');
            }
            const localVarPath = `/api/deviceProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(deviceProfile || {}) : (deviceProfile || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setDefaultDeviceProfile
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultDeviceProfileUsingPOST(deviceProfileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceProfileId' is not null or undefined
            if (deviceProfileId === null || deviceProfileId === undefined) {
                throw new RequiredError('deviceProfileId','Required parameter deviceProfileId was null or undefined when calling setDefaultDeviceProfileUsingPOST.');
            }
            const localVarPath = `/api/deviceProfile/{deviceProfileId}/default`
                .replace(`{${"deviceProfileId"}}`, encodeURIComponent(String(deviceProfileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceProfileControllerApi - functional programming interface
 * @export
 */
export const DeviceProfileControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteDeviceProfile
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceProfileUsingDELETE(deviceProfileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).deleteDeviceProfileUsingDELETE(deviceProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAttributesKeys
         * @param {string} [deviceProfileId] deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesKeysUsingGET(deviceProfileId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).getAttributesKeysUsingGET(deviceProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDefaultDeviceProfileInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDeviceProfileInfoUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceProfileInfo> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).getDefaultDeviceProfileInfoUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDeviceProfileById
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfileByIdUsingGET(deviceProfileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceProfile> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).getDeviceProfileByIdUsingGET(deviceProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDeviceProfileInfoById
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfileInfoByIdUsingGET(deviceProfileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceProfileInfo> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).getDeviceProfileInfoByIdUsingGET(deviceProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDeviceProfileInfos
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {string} [transportType] transportType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfileInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, transportType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDeviceProfileInfo> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).getDeviceProfileInfosUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, transportType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDeviceProfiles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfilesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataDeviceProfile> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).getDeviceProfilesUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTimeseriesKeys
         * @param {string} [deviceProfileId] deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseriesKeysUsingGET(deviceProfileId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).getTimeseriesKeysUsingGET(deviceProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveDeviceProfile
         * @param {DeviceProfile} deviceProfile deviceProfile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceProfileUsingPOST(deviceProfile: DeviceProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceProfile> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).saveDeviceProfileUsingPOST(deviceProfile, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary setDefaultDeviceProfile
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultDeviceProfileUsingPOST(deviceProfileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceProfile> {
            const localVarFetchArgs = DeviceProfileControllerApiFetchParamCreator(configuration).setDefaultDeviceProfileUsingPOST(deviceProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceProfileControllerApi - factory interface
 * @export
 */
export const DeviceProfileControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteDeviceProfile
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceProfileUsingDELETE(deviceProfileId: string, options?: any) {
            return DeviceProfileControllerApiFp(configuration).deleteDeviceProfileUsingDELETE(deviceProfileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAttributesKeys
         * @param {string} [deviceProfileId] deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesKeysUsingGET(deviceProfileId?: string, options?: any) {
            return DeviceProfileControllerApiFp(configuration).getAttributesKeysUsingGET(deviceProfileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDefaultDeviceProfileInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDeviceProfileInfoUsingGET(options?: any) {
            return DeviceProfileControllerApiFp(configuration).getDefaultDeviceProfileInfoUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDeviceProfileById
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfileByIdUsingGET(deviceProfileId: string, options?: any) {
            return DeviceProfileControllerApiFp(configuration).getDeviceProfileByIdUsingGET(deviceProfileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDeviceProfileInfoById
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfileInfoByIdUsingGET(deviceProfileId: string, options?: any) {
            return DeviceProfileControllerApiFp(configuration).getDeviceProfileInfoByIdUsingGET(deviceProfileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDeviceProfileInfos
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {string} [transportType] transportType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfileInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, transportType?: string, options?: any) {
            return DeviceProfileControllerApiFp(configuration).getDeviceProfileInfosUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, transportType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDeviceProfiles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceProfilesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return DeviceProfileControllerApiFp(configuration).getDeviceProfilesUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTimeseriesKeys
         * @param {string} [deviceProfileId] deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseriesKeysUsingGET(deviceProfileId?: string, options?: any) {
            return DeviceProfileControllerApiFp(configuration).getTimeseriesKeysUsingGET(deviceProfileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveDeviceProfile
         * @param {DeviceProfile} deviceProfile deviceProfile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceProfileUsingPOST(deviceProfile: DeviceProfile, options?: any) {
            return DeviceProfileControllerApiFp(configuration).saveDeviceProfileUsingPOST(deviceProfile, options)(fetch, basePath);
        },
        /**
         * 
         * @summary setDefaultDeviceProfile
         * @param {string} deviceProfileId deviceProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultDeviceProfileUsingPOST(deviceProfileId: string, options?: any) {
            return DeviceProfileControllerApiFp(configuration).setDefaultDeviceProfileUsingPOST(deviceProfileId, options)(fetch, basePath);
        },
    };
};

/**
 * DeviceProfileControllerApi - object-oriented interface
 * @export
 * @class DeviceProfileControllerApi
 * @extends {BaseAPI}
 */
export class DeviceProfileControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteDeviceProfile
     * @param {string} deviceProfileId deviceProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public deleteDeviceProfileUsingDELETE(deviceProfileId: string, options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).deleteDeviceProfileUsingDELETE(deviceProfileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAttributesKeys
     * @param {string} [deviceProfileId] deviceProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public getAttributesKeysUsingGET(deviceProfileId?: string, options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).getAttributesKeysUsingGET(deviceProfileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDefaultDeviceProfileInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public getDefaultDeviceProfileInfoUsingGET(options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).getDefaultDeviceProfileInfoUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDeviceProfileById
     * @param {string} deviceProfileId deviceProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public getDeviceProfileByIdUsingGET(deviceProfileId: string, options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).getDeviceProfileByIdUsingGET(deviceProfileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDeviceProfileInfoById
     * @param {string} deviceProfileId deviceProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public getDeviceProfileInfoByIdUsingGET(deviceProfileId: string, options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).getDeviceProfileInfoByIdUsingGET(deviceProfileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDeviceProfileInfos
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {string} [transportType] transportType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public getDeviceProfileInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, transportType?: string, options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).getDeviceProfileInfosUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, transportType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDeviceProfiles
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public getDeviceProfilesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).getDeviceProfilesUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTimeseriesKeys
     * @param {string} [deviceProfileId] deviceProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public getTimeseriesKeysUsingGET(deviceProfileId?: string, options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).getTimeseriesKeysUsingGET(deviceProfileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveDeviceProfile
     * @param {DeviceProfile} deviceProfile deviceProfile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public saveDeviceProfileUsingPOST(deviceProfile: DeviceProfile, options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).saveDeviceProfileUsingPOST(deviceProfile, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary setDefaultDeviceProfile
     * @param {string} deviceProfileId deviceProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceProfileControllerApi
     */
    public setDefaultDeviceProfileUsingPOST(deviceProfileId: string, options?: any) {
        return DeviceProfileControllerApiFp(this.configuration).setDefaultDeviceProfileUsingPOST(deviceProfileId, options)(this.fetch, this.basePath);
    }

}

/**
 * EntityGroupControllerApi - fetch parameter creator
 * @export
 */
export const EntityGroupControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addEntitiesToEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {Array<string>} strEntityIds strEntityIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntitiesToEntityGroupUsingPOST(entityGroupId: string, strEntityIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling addEntitiesToEntityGroupUsingPOST.');
            }
            // verify required parameter 'strEntityIds' is not null or undefined
            if (strEntityIds === null || strEntityIds === undefined) {
                throw new RequiredError('strEntityIds','Required parameter strEntityIds was null or undefined when calling addEntitiesToEntityGroupUsingPOST.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/addEntities`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(strEntityIds || {}) : (strEntityIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityGroupUsingDELETE(entityGroupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling deleteEntityGroupUsingDELETE.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntities
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getEntitiesUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getEntitiesUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getEntitiesUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/entities{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityGroupAllByOwnerAndType
         * @param {string} ownerType ownerType
         * @param {string} ownerId ownerId
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupAllByOwnerAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options: any = {}): FetchArgs {
            // verify required parameter 'ownerType' is not null or undefined
            if (ownerType === null || ownerType === undefined) {
                throw new RequiredError('ownerType','Required parameter ownerType was null or undefined when calling getEntityGroupAllByOwnerAndTypeUsingGET.');
            }
            // verify required parameter 'ownerId' is not null or undefined
            if (ownerId === null || ownerId === undefined) {
                throw new RequiredError('ownerId','Required parameter ownerId was null or undefined when calling getEntityGroupAllByOwnerAndTypeUsingGET.');
            }
            // verify required parameter 'groupType' is not null or undefined
            if (groupType === null || groupType === undefined) {
                throw new RequiredError('groupType','Required parameter groupType was null or undefined when calling getEntityGroupAllByOwnerAndTypeUsingGET.');
            }
            const localVarPath = `/api/entityGroup/all/{ownerType}/{ownerId}/{groupType}`
                .replace(`{${"ownerType"}}`, encodeURIComponent(String(ownerType)))
                .replace(`{${"ownerId"}}`, encodeURIComponent(String(ownerId)))
                .replace(`{${"groupType"}}`, encodeURIComponent(String(groupType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityGroupById
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupByIdUsingGET(entityGroupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getEntityGroupByIdUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityGroupByOwnerAndNameAndType
         * @param {string} ownerType ownerType
         * @param {string} ownerId ownerId
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {string} groupName groupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupByOwnerAndNameAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', groupName: string, options: any = {}): FetchArgs {
            // verify required parameter 'ownerType' is not null or undefined
            if (ownerType === null || ownerType === undefined) {
                throw new RequiredError('ownerType','Required parameter ownerType was null or undefined when calling getEntityGroupByOwnerAndNameAndTypeUsingGET.');
            }
            // verify required parameter 'ownerId' is not null or undefined
            if (ownerId === null || ownerId === undefined) {
                throw new RequiredError('ownerId','Required parameter ownerId was null or undefined when calling getEntityGroupByOwnerAndNameAndTypeUsingGET.');
            }
            // verify required parameter 'groupType' is not null or undefined
            if (groupType === null || groupType === undefined) {
                throw new RequiredError('groupType','Required parameter groupType was null or undefined when calling getEntityGroupByOwnerAndNameAndTypeUsingGET.');
            }
            // verify required parameter 'groupName' is not null or undefined
            if (groupName === null || groupName === undefined) {
                throw new RequiredError('groupName','Required parameter groupName was null or undefined when calling getEntityGroupByOwnerAndNameAndTypeUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{ownerType}/{ownerId}/{groupType}/{groupName}`
                .replace(`{${"ownerType"}}`, encodeURIComponent(String(ownerType)))
                .replace(`{${"ownerId"}}`, encodeURIComponent(String(ownerId)))
                .replace(`{${"groupType"}}`, encodeURIComponent(String(groupType)))
                .replace(`{${"groupName"}}`, encodeURIComponent(String(groupName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityGroupsByIds
         * @param {string} entityGroupIds entityGroupIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsByIdsUsingGET(entityGroupIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupIds' is not null or undefined
            if (entityGroupIds === null || entityGroupIds === undefined) {
                throw new RequiredError('entityGroupIds','Required parameter entityGroupIds was null or undefined when calling getEntityGroupsByIdsUsingGET.');
            }
            const localVarPath = `/api/entityGroups{?entityGroupIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (entityGroupIds !== undefined) {
                localVarQueryParameter['entityGroupIds'] = entityGroupIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityGroupsByOwnerAndType
         * @param {string} ownerType ownerType
         * @param {string} ownerId ownerId
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsByOwnerAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options: any = {}): FetchArgs {
            // verify required parameter 'ownerType' is not null or undefined
            if (ownerType === null || ownerType === undefined) {
                throw new RequiredError('ownerType','Required parameter ownerType was null or undefined when calling getEntityGroupsByOwnerAndTypeUsingGET.');
            }
            // verify required parameter 'ownerId' is not null or undefined
            if (ownerId === null || ownerId === undefined) {
                throw new RequiredError('ownerId','Required parameter ownerId was null or undefined when calling getEntityGroupsByOwnerAndTypeUsingGET.');
            }
            // verify required parameter 'groupType' is not null or undefined
            if (groupType === null || groupType === undefined) {
                throw new RequiredError('groupType','Required parameter groupType was null or undefined when calling getEntityGroupsByOwnerAndTypeUsingGET.');
            }
            const localVarPath = `/api/entityGroups/{ownerType}/{ownerId}/{groupType}`
                .replace(`{${"ownerType"}}`, encodeURIComponent(String(ownerType)))
                .replace(`{${"ownerId"}}`, encodeURIComponent(String(ownerId)))
                .replace(`{${"groupType"}}`, encodeURIComponent(String(groupType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityGroupsByType
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsByTypeUsingGET(groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options: any = {}): FetchArgs {
            // verify required parameter 'groupType' is not null or undefined
            if (groupType === null || groupType === undefined) {
                throw new RequiredError('groupType','Required parameter groupType was null or undefined when calling getEntityGroupsByTypeUsingGET.');
            }
            const localVarPath = `/api/entityGroups/{groupType}`
                .replace(`{${"groupType"}}`, encodeURIComponent(String(groupType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityGroupsForEntity
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} entityType Entity type
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsForEntityUsingGET(entityType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', entityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getEntityGroupsForEntityUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getEntityGroupsForEntityUsingGET.');
            }
            const localVarPath = `/api/entityGroups/{entityType}/{entityId}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGroupEntity
         * @param {string} entityGroupId entityGroupId
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupEntityUsingGET(entityGroupId: string, entityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getGroupEntityUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getGroupEntityUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/{entityId}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getOwners
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getOwnersUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getOwnersUsingGET.');
            }
            const localVarPath = `/api/owners{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary makeEntityGroupPrivate
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeEntityGroupPrivateUsingPOST(entityGroupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling makeEntityGroupPrivateUsingPOST.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/makePrivate`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary makeEntityGroupPublic
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeEntityGroupPublicUsingPOST(entityGroupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling makeEntityGroupPublicUsingPOST.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/makePublic`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removeEntitiesFromEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {Array<string>} strEntityIds strEntityIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntitiesFromEntityGroupUsingPOST(entityGroupId: string, strEntityIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling removeEntitiesFromEntityGroupUsingPOST.');
            }
            // verify required parameter 'strEntityIds' is not null or undefined
            if (strEntityIds === null || strEntityIds === undefined) {
                throw new RequiredError('strEntityIds','Required parameter strEntityIds was null or undefined when calling removeEntitiesFromEntityGroupUsingPOST.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/deleteEntities`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(strEntityIds || {}) : (strEntityIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveEntityGroup
         * @param {EntityGroup} entityGroup entityGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityGroupUsingPOST(entityGroup: EntityGroup, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroup' is not null or undefined
            if (entityGroup === null || entityGroup === undefined) {
                throw new RequiredError('entityGroup','Required parameter entityGroup was null or undefined when calling saveEntityGroupUsingPOST.');
            }
            const localVarPath = `/api/entityGroup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityGroup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityGroup || {}) : (entityGroup || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary shareEntityGroupToChildOwnerUserGroup
         * @param {string} entityGroupId entityGroupId
         * @param {string} userGroupId userGroupId
         * @param {string} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareEntityGroupToChildOwnerUserGroupUsingPOST(entityGroupId: string, userGroupId: string, roleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling shareEntityGroupToChildOwnerUserGroupUsingPOST.');
            }
            // verify required parameter 'userGroupId' is not null or undefined
            if (userGroupId === null || userGroupId === undefined) {
                throw new RequiredError('userGroupId','Required parameter userGroupId was null or undefined when calling shareEntityGroupToChildOwnerUserGroupUsingPOST.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling shareEntityGroupToChildOwnerUserGroupUsingPOST.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/{userGroupId}/{roleId}/share`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)))
                .replace(`{${"userGroupId"}}`, encodeURIComponent(String(userGroupId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary shareEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {ShareGroupRequest} shareGroupRequest shareGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareEntityGroupUsingPOST(entityGroupId: string, shareGroupRequest: ShareGroupRequest, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling shareEntityGroupUsingPOST.');
            }
            // verify required parameter 'shareGroupRequest' is not null or undefined
            if (shareGroupRequest === null || shareGroupRequest === undefined) {
                throw new RequiredError('shareGroupRequest','Required parameter shareGroupRequest was null or undefined when calling shareEntityGroupUsingPOST.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/share`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShareGroupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(shareGroupRequest || {}) : (shareGroupRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityGroupControllerApi - functional programming interface
 * @export
 */
export const EntityGroupControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addEntitiesToEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {Array<string>} strEntityIds strEntityIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntitiesToEntityGroupUsingPOST(entityGroupId: string, strEntityIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).addEntitiesToEntityGroupUsingPOST(entityGroupId, strEntityIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityGroupUsingDELETE(entityGroupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).deleteEntityGroupUsingDELETE(entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntities
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataShortEntityView> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getEntitiesUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityGroupAllByOwnerAndType
         * @param {string} ownerType ownerType
         * @param {string} ownerId ownerId
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupAllByOwnerAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityGroupInfo> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getEntityGroupAllByOwnerAndTypeUsingGET(ownerType, ownerId, groupType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityGroupById
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupByIdUsingGET(entityGroupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityGroupInfo> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getEntityGroupByIdUsingGET(entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityGroupByOwnerAndNameAndType
         * @param {string} ownerType ownerType
         * @param {string} ownerId ownerId
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {string} groupName groupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupByOwnerAndNameAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', groupName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityGroupInfo> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getEntityGroupByOwnerAndNameAndTypeUsingGET(ownerType, ownerId, groupType, groupName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityGroupsByIds
         * @param {string} entityGroupIds entityGroupIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsByIdsUsingGET(entityGroupIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityGroup>> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getEntityGroupsByIdsUsingGET(entityGroupIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityGroupsByOwnerAndType
         * @param {string} ownerType ownerType
         * @param {string} ownerId ownerId
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsByOwnerAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityGroupInfo>> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getEntityGroupsByOwnerAndTypeUsingGET(ownerType, ownerId, groupType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityGroupsByType
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsByTypeUsingGET(groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityGroupInfo>> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getEntityGroupsByTypeUsingGET(groupType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityGroupsForEntity
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} entityType Entity type
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsForEntityUsingGET(entityType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', entityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityGroupId>> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getEntityGroupsForEntityUsingGET(entityType, entityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getGroupEntity
         * @param {string} entityGroupId entityGroupId
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupEntityUsingGET(entityGroupId: string, entityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShortEntityView> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getGroupEntityUsingGET(entityGroupId, entityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getOwners
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataContactBasedobject> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).getOwnersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary makeEntityGroupPrivate
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeEntityGroupPrivateUsingPOST(entityGroupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).makeEntityGroupPrivateUsingPOST(entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary makeEntityGroupPublic
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeEntityGroupPublicUsingPOST(entityGroupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).makeEntityGroupPublicUsingPOST(entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary removeEntitiesFromEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {Array<string>} strEntityIds strEntityIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntitiesFromEntityGroupUsingPOST(entityGroupId: string, strEntityIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).removeEntitiesFromEntityGroupUsingPOST(entityGroupId, strEntityIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveEntityGroup
         * @param {EntityGroup} entityGroup entityGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityGroupUsingPOST(entityGroup: EntityGroup, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityGroupInfo> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).saveEntityGroupUsingPOST(entityGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary shareEntityGroupToChildOwnerUserGroup
         * @param {string} entityGroupId entityGroupId
         * @param {string} userGroupId userGroupId
         * @param {string} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareEntityGroupToChildOwnerUserGroupUsingPOST(entityGroupId: string, userGroupId: string, roleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).shareEntityGroupToChildOwnerUserGroupUsingPOST(entityGroupId, userGroupId, roleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary shareEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {ShareGroupRequest} shareGroupRequest shareGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareEntityGroupUsingPOST(entityGroupId: string, shareGroupRequest: ShareGroupRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityGroupControllerApiFetchParamCreator(configuration).shareEntityGroupUsingPOST(entityGroupId, shareGroupRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EntityGroupControllerApi - factory interface
 * @export
 */
export const EntityGroupControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary addEntitiesToEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {Array<string>} strEntityIds strEntityIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntitiesToEntityGroupUsingPOST(entityGroupId: string, strEntityIds: Array<string>, options?: any) {
            return EntityGroupControllerApiFp(configuration).addEntitiesToEntityGroupUsingPOST(entityGroupId, strEntityIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityGroupUsingDELETE(entityGroupId: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).deleteEntityGroupUsingDELETE(entityGroupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntities
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).getEntitiesUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityGroupAllByOwnerAndType
         * @param {string} ownerType ownerType
         * @param {string} ownerId ownerId
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupAllByOwnerAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options?: any) {
            return EntityGroupControllerApiFp(configuration).getEntityGroupAllByOwnerAndTypeUsingGET(ownerType, ownerId, groupType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityGroupById
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupByIdUsingGET(entityGroupId: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).getEntityGroupByIdUsingGET(entityGroupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityGroupByOwnerAndNameAndType
         * @param {string} ownerType ownerType
         * @param {string} ownerId ownerId
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {string} groupName groupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupByOwnerAndNameAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', groupName: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).getEntityGroupByOwnerAndNameAndTypeUsingGET(ownerType, ownerId, groupType, groupName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityGroupsByIds
         * @param {string} entityGroupIds entityGroupIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsByIdsUsingGET(entityGroupIds: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).getEntityGroupsByIdsUsingGET(entityGroupIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityGroupsByOwnerAndType
         * @param {string} ownerType ownerType
         * @param {string} ownerId ownerId
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsByOwnerAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options?: any) {
            return EntityGroupControllerApiFp(configuration).getEntityGroupsByOwnerAndTypeUsingGET(ownerType, ownerId, groupType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityGroupsByType
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsByTypeUsingGET(groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options?: any) {
            return EntityGroupControllerApiFp(configuration).getEntityGroupsByTypeUsingGET(groupType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityGroupsForEntity
         * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} entityType Entity type
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupsForEntityUsingGET(entityType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', entityId: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).getEntityGroupsForEntityUsingGET(entityType, entityId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getGroupEntity
         * @param {string} entityGroupId entityGroupId
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupEntityUsingGET(entityGroupId: string, entityId: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).getGroupEntityUsingGET(entityGroupId, entityId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getOwners
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).getOwnersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary makeEntityGroupPrivate
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeEntityGroupPrivateUsingPOST(entityGroupId: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).makeEntityGroupPrivateUsingPOST(entityGroupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary makeEntityGroupPublic
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeEntityGroupPublicUsingPOST(entityGroupId: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).makeEntityGroupPublicUsingPOST(entityGroupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary removeEntitiesFromEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {Array<string>} strEntityIds strEntityIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntitiesFromEntityGroupUsingPOST(entityGroupId: string, strEntityIds: Array<string>, options?: any) {
            return EntityGroupControllerApiFp(configuration).removeEntitiesFromEntityGroupUsingPOST(entityGroupId, strEntityIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveEntityGroup
         * @param {EntityGroup} entityGroup entityGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityGroupUsingPOST(entityGroup: EntityGroup, options?: any) {
            return EntityGroupControllerApiFp(configuration).saveEntityGroupUsingPOST(entityGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary shareEntityGroupToChildOwnerUserGroup
         * @param {string} entityGroupId entityGroupId
         * @param {string} userGroupId userGroupId
         * @param {string} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareEntityGroupToChildOwnerUserGroupUsingPOST(entityGroupId: string, userGroupId: string, roleId: string, options?: any) {
            return EntityGroupControllerApiFp(configuration).shareEntityGroupToChildOwnerUserGroupUsingPOST(entityGroupId, userGroupId, roleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary shareEntityGroup
         * @param {string} entityGroupId entityGroupId
         * @param {ShareGroupRequest} shareGroupRequest shareGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareEntityGroupUsingPOST(entityGroupId: string, shareGroupRequest: ShareGroupRequest, options?: any) {
            return EntityGroupControllerApiFp(configuration).shareEntityGroupUsingPOST(entityGroupId, shareGroupRequest, options)(fetch, basePath);
        },
    };
};

/**
 * EntityGroupControllerApi - object-oriented interface
 * @export
 * @class EntityGroupControllerApi
 * @extends {BaseAPI}
 */
export class EntityGroupControllerApi extends BaseAPI {
    /**
     * 
     * @summary addEntitiesToEntityGroup
     * @param {string} entityGroupId entityGroupId
     * @param {Array<string>} strEntityIds strEntityIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public addEntitiesToEntityGroupUsingPOST(entityGroupId: string, strEntityIds: Array<string>, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).addEntitiesToEntityGroupUsingPOST(entityGroupId, strEntityIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteEntityGroup
     * @param {string} entityGroupId entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public deleteEntityGroupUsingDELETE(entityGroupId: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).deleteEntityGroupUsingDELETE(entityGroupId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntities
     * @param {string} entityGroupId entityGroupId
     * @param {string} pageSize Page size
     * @param {string} page Page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getEntitiesUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getEntitiesUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityGroupAllByOwnerAndType
     * @param {string} ownerType ownerType
     * @param {string} ownerId ownerId
     * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getEntityGroupAllByOwnerAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getEntityGroupAllByOwnerAndTypeUsingGET(ownerType, ownerId, groupType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityGroupById
     * @param {string} entityGroupId entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getEntityGroupByIdUsingGET(entityGroupId: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getEntityGroupByIdUsingGET(entityGroupId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityGroupByOwnerAndNameAndType
     * @param {string} ownerType ownerType
     * @param {string} ownerId ownerId
     * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
     * @param {string} groupName groupName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getEntityGroupByOwnerAndNameAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', groupName: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getEntityGroupByOwnerAndNameAndTypeUsingGET(ownerType, ownerId, groupType, groupName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityGroupsByIds
     * @param {string} entityGroupIds entityGroupIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getEntityGroupsByIdsUsingGET(entityGroupIds: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getEntityGroupsByIdsUsingGET(entityGroupIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityGroupsByOwnerAndType
     * @param {string} ownerType ownerType
     * @param {string} ownerId ownerId
     * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getEntityGroupsByOwnerAndTypeUsingGET(ownerType: string, ownerId: string, groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getEntityGroupsByOwnerAndTypeUsingGET(ownerType, ownerId, groupType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityGroupsByType
     * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} groupType EntityGroup type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getEntityGroupsByTypeUsingGET(groupType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getEntityGroupsByTypeUsingGET(groupType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityGroupsForEntity
     * @param {'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD'} entityType Entity type
     * @param {string} entityId entityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getEntityGroupsForEntityUsingGET(entityType: 'CUSTOMER' | 'ASSET' | 'DEVICE' | 'USER' | 'ENTITY_VIEW' | 'DASHBOARD', entityId: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getEntityGroupsForEntityUsingGET(entityType, entityId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getGroupEntity
     * @param {string} entityGroupId entityGroupId
     * @param {string} entityId entityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getGroupEntityUsingGET(entityGroupId: string, entityId: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getGroupEntityUsingGET(entityGroupId, entityId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getOwners
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public getOwnersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).getOwnersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary makeEntityGroupPrivate
     * @param {string} entityGroupId entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public makeEntityGroupPrivateUsingPOST(entityGroupId: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).makeEntityGroupPrivateUsingPOST(entityGroupId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary makeEntityGroupPublic
     * @param {string} entityGroupId entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public makeEntityGroupPublicUsingPOST(entityGroupId: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).makeEntityGroupPublicUsingPOST(entityGroupId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary removeEntitiesFromEntityGroup
     * @param {string} entityGroupId entityGroupId
     * @param {Array<string>} strEntityIds strEntityIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public removeEntitiesFromEntityGroupUsingPOST(entityGroupId: string, strEntityIds: Array<string>, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).removeEntitiesFromEntityGroupUsingPOST(entityGroupId, strEntityIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveEntityGroup
     * @param {EntityGroup} entityGroup entityGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public saveEntityGroupUsingPOST(entityGroup: EntityGroup, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).saveEntityGroupUsingPOST(entityGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary shareEntityGroupToChildOwnerUserGroup
     * @param {string} entityGroupId entityGroupId
     * @param {string} userGroupId userGroupId
     * @param {string} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public shareEntityGroupToChildOwnerUserGroupUsingPOST(entityGroupId: string, userGroupId: string, roleId: string, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).shareEntityGroupToChildOwnerUserGroupUsingPOST(entityGroupId, userGroupId, roleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary shareEntityGroup
     * @param {string} entityGroupId entityGroupId
     * @param {ShareGroupRequest} shareGroupRequest shareGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGroupControllerApi
     */
    public shareEntityGroupUsingPOST(entityGroupId: string, shareGroupRequest: ShareGroupRequest, options?: any) {
        return EntityGroupControllerApiFp(this.configuration).shareEntityGroupUsingPOST(entityGroupId, shareGroupRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * EntityQueryControllerApi - fetch parameter creator
 * @export
 */
export const EntityQueryControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary countEntitiesByQuery
         * @param {EntityCountQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countEntitiesByQueryUsingPOST(query: EntityCountQuery, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling countEntitiesByQueryUsingPOST.');
            }
            const localVarPath = `/api/entitiesQuery/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityCountQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findAlarmDataByQuery
         * @param {AlarmDataQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAlarmDataByQueryUsingPOST(query: AlarmDataQuery, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling findAlarmDataByQueryUsingPOST.');
            }
            const localVarPath = `/api/alarmsQuery/find`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AlarmDataQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findEntityDataByQuery
         * @param {EntityDataQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEntityDataByQueryUsingPOST(query: EntityDataQuery, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling findEntityDataByQueryUsingPOST.');
            }
            const localVarPath = `/api/entitiesQuery/find`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDataQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findEntityTimeseriesAndAttributesKeysByQuery
         * @param {EntityDataQuery} query query
         * @param {boolean} timeseries timeseries
         * @param {boolean} attributes attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEntityTimeseriesAndAttributesKeysByQueryUsingPOST(query: EntityDataQuery, timeseries: boolean, attributes: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling findEntityTimeseriesAndAttributesKeysByQueryUsingPOST.');
            }
            // verify required parameter 'timeseries' is not null or undefined
            if (timeseries === null || timeseries === undefined) {
                throw new RequiredError('timeseries','Required parameter timeseries was null or undefined when calling findEntityTimeseriesAndAttributesKeysByQueryUsingPOST.');
            }
            // verify required parameter 'attributes' is not null or undefined
            if (attributes === null || attributes === undefined) {
                throw new RequiredError('attributes','Required parameter attributes was null or undefined when calling findEntityTimeseriesAndAttributesKeysByQueryUsingPOST.');
            }
            const localVarPath = `/api/entitiesQuery/find/keys{?timeseries,attributes}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (timeseries !== undefined) {
                localVarQueryParameter['timeseries'] = timeseries;
            }

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = attributes;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDataQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityQueryControllerApi - functional programming interface
 * @export
 */
export const EntityQueryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary countEntitiesByQuery
         * @param {EntityCountQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countEntitiesByQueryUsingPOST(query: EntityCountQuery, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = EntityQueryControllerApiFetchParamCreator(configuration).countEntitiesByQueryUsingPOST(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findAlarmDataByQuery
         * @param {AlarmDataQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAlarmDataByQueryUsingPOST(query: AlarmDataQuery, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataAlarmData> {
            const localVarFetchArgs = EntityQueryControllerApiFetchParamCreator(configuration).findAlarmDataByQueryUsingPOST(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findEntityDataByQuery
         * @param {EntityDataQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEntityDataByQueryUsingPOST(query: EntityDataQuery, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataEntityData> {
            const localVarFetchArgs = EntityQueryControllerApiFetchParamCreator(configuration).findEntityDataByQueryUsingPOST(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findEntityTimeseriesAndAttributesKeysByQuery
         * @param {EntityDataQuery} query query
         * @param {boolean} timeseries timeseries
         * @param {boolean} attributes attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEntityTimeseriesAndAttributesKeysByQueryUsingPOST(query: EntityDataQuery, timeseries: boolean, attributes: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = EntityQueryControllerApiFetchParamCreator(configuration).findEntityTimeseriesAndAttributesKeysByQueryUsingPOST(query, timeseries, attributes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EntityQueryControllerApi - factory interface
 * @export
 */
export const EntityQueryControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary countEntitiesByQuery
         * @param {EntityCountQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countEntitiesByQueryUsingPOST(query: EntityCountQuery, options?: any) {
            return EntityQueryControllerApiFp(configuration).countEntitiesByQueryUsingPOST(query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findAlarmDataByQuery
         * @param {AlarmDataQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAlarmDataByQueryUsingPOST(query: AlarmDataQuery, options?: any) {
            return EntityQueryControllerApiFp(configuration).findAlarmDataByQueryUsingPOST(query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findEntityDataByQuery
         * @param {EntityDataQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEntityDataByQueryUsingPOST(query: EntityDataQuery, options?: any) {
            return EntityQueryControllerApiFp(configuration).findEntityDataByQueryUsingPOST(query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findEntityTimeseriesAndAttributesKeysByQuery
         * @param {EntityDataQuery} query query
         * @param {boolean} timeseries timeseries
         * @param {boolean} attributes attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEntityTimeseriesAndAttributesKeysByQueryUsingPOST(query: EntityDataQuery, timeseries: boolean, attributes: boolean, options?: any) {
            return EntityQueryControllerApiFp(configuration).findEntityTimeseriesAndAttributesKeysByQueryUsingPOST(query, timeseries, attributes, options)(fetch, basePath);
        },
    };
};

/**
 * EntityQueryControllerApi - object-oriented interface
 * @export
 * @class EntityQueryControllerApi
 * @extends {BaseAPI}
 */
export class EntityQueryControllerApi extends BaseAPI {
    /**
     * 
     * @summary countEntitiesByQuery
     * @param {EntityCountQuery} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityQueryControllerApi
     */
    public countEntitiesByQueryUsingPOST(query: EntityCountQuery, options?: any) {
        return EntityQueryControllerApiFp(this.configuration).countEntitiesByQueryUsingPOST(query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findAlarmDataByQuery
     * @param {AlarmDataQuery} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityQueryControllerApi
     */
    public findAlarmDataByQueryUsingPOST(query: AlarmDataQuery, options?: any) {
        return EntityQueryControllerApiFp(this.configuration).findAlarmDataByQueryUsingPOST(query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findEntityDataByQuery
     * @param {EntityDataQuery} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityQueryControllerApi
     */
    public findEntityDataByQueryUsingPOST(query: EntityDataQuery, options?: any) {
        return EntityQueryControllerApiFp(this.configuration).findEntityDataByQueryUsingPOST(query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findEntityTimeseriesAndAttributesKeysByQuery
     * @param {EntityDataQuery} query query
     * @param {boolean} timeseries timeseries
     * @param {boolean} attributes attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityQueryControllerApi
     */
    public findEntityTimeseriesAndAttributesKeysByQueryUsingPOST(query: EntityDataQuery, timeseries: boolean, attributes: boolean, options?: any) {
        return EntityQueryControllerApiFp(this.configuration).findEntityTimeseriesAndAttributesKeysByQueryUsingPOST(query, timeseries, attributes, options)(this.fetch, this.basePath);
    }

}

/**
 * EntityRelationControllerApi - fetch parameter creator
 * @export
 */
export const EntityRelationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRelation
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} relationType relationType
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationUsingDELETE(fromId: string, fromType: string, relationType: string, toId: string, toType: string, relationTypeGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fromId' is not null or undefined
            if (fromId === null || fromId === undefined) {
                throw new RequiredError('fromId','Required parameter fromId was null or undefined when calling deleteRelationUsingDELETE.');
            }
            // verify required parameter 'fromType' is not null or undefined
            if (fromType === null || fromType === undefined) {
                throw new RequiredError('fromType','Required parameter fromType was null or undefined when calling deleteRelationUsingDELETE.');
            }
            // verify required parameter 'relationType' is not null or undefined
            if (relationType === null || relationType === undefined) {
                throw new RequiredError('relationType','Required parameter relationType was null or undefined when calling deleteRelationUsingDELETE.');
            }
            // verify required parameter 'toId' is not null or undefined
            if (toId === null || toId === undefined) {
                throw new RequiredError('toId','Required parameter toId was null or undefined when calling deleteRelationUsingDELETE.');
            }
            // verify required parameter 'toType' is not null or undefined
            if (toType === null || toType === undefined) {
                throw new RequiredError('toType','Required parameter toType was null or undefined when calling deleteRelationUsingDELETE.');
            }
            const localVarPath = `/api/relation{?relationTypeGroup,fromId,fromType,relationType,toId,toType}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (relationTypeGroup !== undefined) {
                localVarQueryParameter['relationTypeGroup'] = relationTypeGroup;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (fromType !== undefined) {
                localVarQueryParameter['fromType'] = fromType;
            }

            if (relationType !== undefined) {
                localVarQueryParameter['relationType'] = relationType;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (toType !== undefined) {
                localVarQueryParameter['toType'] = toType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteRelations
         * @param {string} entityId entityId
         * @param {string} entityType entityType
         * @param {string} id 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationsUsingDELETE(entityId: string, entityType: string, id: string, type: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling deleteRelationsUsingDELETE.');
            }
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling deleteRelationsUsingDELETE.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRelationsUsingDELETE.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling deleteRelationsUsingDELETE.');
            }
            const localVarPath = `/api/relations{?entityId,entityType,id,type}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByFrom
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByFromUsingGET(fromId: string, fromType: string, relationTypeGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fromId' is not null or undefined
            if (fromId === null || fromId === undefined) {
                throw new RequiredError('fromId','Required parameter fromId was null or undefined when calling findByFromUsingGET.');
            }
            // verify required parameter 'fromType' is not null or undefined
            if (fromType === null || fromType === undefined) {
                throw new RequiredError('fromType','Required parameter fromType was null or undefined when calling findByFromUsingGET.');
            }
            const localVarPath = `/api/relations{?relationTypeGroup,fromId,fromType}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (relationTypeGroup !== undefined) {
                localVarQueryParameter['relationTypeGroup'] = relationTypeGroup;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (fromType !== undefined) {
                localVarQueryParameter['fromType'] = fromType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByFrom
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} relationType relationType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByFromUsingGET1(fromId: string, fromType: string, relationType: string, relationTypeGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fromId' is not null or undefined
            if (fromId === null || fromId === undefined) {
                throw new RequiredError('fromId','Required parameter fromId was null or undefined when calling findByFromUsingGET1.');
            }
            // verify required parameter 'fromType' is not null or undefined
            if (fromType === null || fromType === undefined) {
                throw new RequiredError('fromType','Required parameter fromType was null or undefined when calling findByFromUsingGET1.');
            }
            // verify required parameter 'relationType' is not null or undefined
            if (relationType === null || relationType === undefined) {
                throw new RequiredError('relationType','Required parameter relationType was null or undefined when calling findByFromUsingGET1.');
            }
            const localVarPath = `/api/relations{?relationTypeGroup,fromId,fromType,relationType}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (relationTypeGroup !== undefined) {
                localVarQueryParameter['relationTypeGroup'] = relationTypeGroup;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (fromType !== undefined) {
                localVarQueryParameter['fromType'] = fromType;
            }

            if (relationType !== undefined) {
                localVarQueryParameter['relationType'] = relationType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByQuery
         * @param {EntityRelationsQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST2(query: EntityRelationsQuery, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling findByQueryUsingPOST2.');
            }
            const localVarPath = `/api/relations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityRelationsQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByTo
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByToUsingGET(toId: string, toType: string, relationTypeGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'toId' is not null or undefined
            if (toId === null || toId === undefined) {
                throw new RequiredError('toId','Required parameter toId was null or undefined when calling findByToUsingGET.');
            }
            // verify required parameter 'toType' is not null or undefined
            if (toType === null || toType === undefined) {
                throw new RequiredError('toType','Required parameter toType was null or undefined when calling findByToUsingGET.');
            }
            const localVarPath = `/api/relations{?relationTypeGroup,toId,toType}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (relationTypeGroup !== undefined) {
                localVarQueryParameter['relationTypeGroup'] = relationTypeGroup;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (toType !== undefined) {
                localVarQueryParameter['toType'] = toType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByTo
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} relationType relationType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByToUsingGET1(toId: string, toType: string, relationType: string, relationTypeGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'toId' is not null or undefined
            if (toId === null || toId === undefined) {
                throw new RequiredError('toId','Required parameter toId was null or undefined when calling findByToUsingGET1.');
            }
            // verify required parameter 'toType' is not null or undefined
            if (toType === null || toType === undefined) {
                throw new RequiredError('toType','Required parameter toType was null or undefined when calling findByToUsingGET1.');
            }
            // verify required parameter 'relationType' is not null or undefined
            if (relationType === null || relationType === undefined) {
                throw new RequiredError('relationType','Required parameter relationType was null or undefined when calling findByToUsingGET1.');
            }
            const localVarPath = `/api/relations{?relationTypeGroup,toId,toType,relationType}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (relationTypeGroup !== undefined) {
                localVarQueryParameter['relationTypeGroup'] = relationTypeGroup;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (toType !== undefined) {
                localVarQueryParameter['toType'] = toType;
            }

            if (relationType !== undefined) {
                localVarQueryParameter['relationType'] = relationType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findInfoByFrom
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInfoByFromUsingGET(fromId: string, fromType: string, relationTypeGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fromId' is not null or undefined
            if (fromId === null || fromId === undefined) {
                throw new RequiredError('fromId','Required parameter fromId was null or undefined when calling findInfoByFromUsingGET.');
            }
            // verify required parameter 'fromType' is not null or undefined
            if (fromType === null || fromType === undefined) {
                throw new RequiredError('fromType','Required parameter fromType was null or undefined when calling findInfoByFromUsingGET.');
            }
            const localVarPath = `/api/relations/info{?relationTypeGroup,fromId,fromType}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (relationTypeGroup !== undefined) {
                localVarQueryParameter['relationTypeGroup'] = relationTypeGroup;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (fromType !== undefined) {
                localVarQueryParameter['fromType'] = fromType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findInfoByQuery
         * @param {EntityRelationsQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInfoByQueryUsingPOST(query: EntityRelationsQuery, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling findInfoByQueryUsingPOST.');
            }
            const localVarPath = `/api/relations/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityRelationsQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findInfoByTo
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInfoByToUsingGET(toId: string, toType: string, relationTypeGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'toId' is not null or undefined
            if (toId === null || toId === undefined) {
                throw new RequiredError('toId','Required parameter toId was null or undefined when calling findInfoByToUsingGET.');
            }
            // verify required parameter 'toType' is not null or undefined
            if (toType === null || toType === undefined) {
                throw new RequiredError('toType','Required parameter toType was null or undefined when calling findInfoByToUsingGET.');
            }
            const localVarPath = `/api/relations/info{?relationTypeGroup,toId,toType}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (relationTypeGroup !== undefined) {
                localVarQueryParameter['relationTypeGroup'] = relationTypeGroup;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (toType !== undefined) {
                localVarQueryParameter['toType'] = toType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRelation
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} relationType relationType
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationUsingGET(fromId: string, fromType: string, relationType: string, toId: string, toType: string, relationTypeGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fromId' is not null or undefined
            if (fromId === null || fromId === undefined) {
                throw new RequiredError('fromId','Required parameter fromId was null or undefined when calling getRelationUsingGET.');
            }
            // verify required parameter 'fromType' is not null or undefined
            if (fromType === null || fromType === undefined) {
                throw new RequiredError('fromType','Required parameter fromType was null or undefined when calling getRelationUsingGET.');
            }
            // verify required parameter 'relationType' is not null or undefined
            if (relationType === null || relationType === undefined) {
                throw new RequiredError('relationType','Required parameter relationType was null or undefined when calling getRelationUsingGET.');
            }
            // verify required parameter 'toId' is not null or undefined
            if (toId === null || toId === undefined) {
                throw new RequiredError('toId','Required parameter toId was null or undefined when calling getRelationUsingGET.');
            }
            // verify required parameter 'toType' is not null or undefined
            if (toType === null || toType === undefined) {
                throw new RequiredError('toType','Required parameter toType was null or undefined when calling getRelationUsingGET.');
            }
            const localVarPath = `/api/relation{?relationTypeGroup,fromId,fromType,relationType,toId,toType}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (relationTypeGroup !== undefined) {
                localVarQueryParameter['relationTypeGroup'] = relationTypeGroup;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (fromType !== undefined) {
                localVarQueryParameter['fromType'] = fromType;
            }

            if (relationType !== undefined) {
                localVarQueryParameter['relationType'] = relationType;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (toType !== undefined) {
                localVarQueryParameter['toType'] = toType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveRelation
         * @param {EntityRelation} relation relation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRelationUsingPOST(relation: EntityRelation, options: any = {}): FetchArgs {
            // verify required parameter 'relation' is not null or undefined
            if (relation === null || relation === undefined) {
                throw new RequiredError('relation','Required parameter relation was null or undefined when calling saveRelationUsingPOST.');
            }
            const localVarPath = `/api/relation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityRelation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(relation || {}) : (relation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityRelationControllerApi - functional programming interface
 * @export
 */
export const EntityRelationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRelation
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} relationType relationType
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationUsingDELETE(fromId: string, fromType: string, relationType: string, toId: string, toType: string, relationTypeGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).deleteRelationUsingDELETE(fromId, fromType, relationType, toId, toType, relationTypeGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteRelations
         * @param {string} entityId entityId
         * @param {string} entityType entityType
         * @param {string} id 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationsUsingDELETE(entityId: string, entityType: string, id: string, type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).deleteRelationsUsingDELETE(entityId, entityType, id, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findByFrom
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByFromUsingGET(fromId: string, fromType: string, relationTypeGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityRelation>> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).findByFromUsingGET(fromId, fromType, relationTypeGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findByFrom
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} relationType relationType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByFromUsingGET1(fromId: string, fromType: string, relationType: string, relationTypeGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityRelation>> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).findByFromUsingGET1(fromId, fromType, relationType, relationTypeGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findByQuery
         * @param {EntityRelationsQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST2(query: EntityRelationsQuery, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityRelation>> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).findByQueryUsingPOST2(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findByTo
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByToUsingGET(toId: string, toType: string, relationTypeGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityRelation>> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).findByToUsingGET(toId, toType, relationTypeGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findByTo
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} relationType relationType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByToUsingGET1(toId: string, toType: string, relationType: string, relationTypeGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityRelation>> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).findByToUsingGET1(toId, toType, relationType, relationTypeGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findInfoByFrom
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInfoByFromUsingGET(fromId: string, fromType: string, relationTypeGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityRelationInfo>> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).findInfoByFromUsingGET(fromId, fromType, relationTypeGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findInfoByQuery
         * @param {EntityRelationsQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInfoByQueryUsingPOST(query: EntityRelationsQuery, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityRelationInfo>> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).findInfoByQueryUsingPOST(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findInfoByTo
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInfoByToUsingGET(toId: string, toType: string, relationTypeGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityRelationInfo>> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).findInfoByToUsingGET(toId, toType, relationTypeGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRelation
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} relationType relationType
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationUsingGET(fromId: string, fromType: string, relationType: string, toId: string, toType: string, relationTypeGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityRelation> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).getRelationUsingGET(fromId, fromType, relationType, toId, toType, relationTypeGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveRelation
         * @param {EntityRelation} relation relation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRelationUsingPOST(relation: EntityRelation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityRelationControllerApiFetchParamCreator(configuration).saveRelationUsingPOST(relation, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EntityRelationControllerApi - factory interface
 * @export
 */
export const EntityRelationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteRelation
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} relationType relationType
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationUsingDELETE(fromId: string, fromType: string, relationType: string, toId: string, toType: string, relationTypeGroup?: string, options?: any) {
            return EntityRelationControllerApiFp(configuration).deleteRelationUsingDELETE(fromId, fromType, relationType, toId, toType, relationTypeGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteRelations
         * @param {string} entityId entityId
         * @param {string} entityType entityType
         * @param {string} id 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationsUsingDELETE(entityId: string, entityType: string, id: string, type: string, options?: any) {
            return EntityRelationControllerApiFp(configuration).deleteRelationsUsingDELETE(entityId, entityType, id, type, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findByFrom
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByFromUsingGET(fromId: string, fromType: string, relationTypeGroup?: string, options?: any) {
            return EntityRelationControllerApiFp(configuration).findByFromUsingGET(fromId, fromType, relationTypeGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findByFrom
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} relationType relationType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByFromUsingGET1(fromId: string, fromType: string, relationType: string, relationTypeGroup?: string, options?: any) {
            return EntityRelationControllerApiFp(configuration).findByFromUsingGET1(fromId, fromType, relationType, relationTypeGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findByQuery
         * @param {EntityRelationsQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST2(query: EntityRelationsQuery, options?: any) {
            return EntityRelationControllerApiFp(configuration).findByQueryUsingPOST2(query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findByTo
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByToUsingGET(toId: string, toType: string, relationTypeGroup?: string, options?: any) {
            return EntityRelationControllerApiFp(configuration).findByToUsingGET(toId, toType, relationTypeGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findByTo
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} relationType relationType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByToUsingGET1(toId: string, toType: string, relationType: string, relationTypeGroup?: string, options?: any) {
            return EntityRelationControllerApiFp(configuration).findByToUsingGET1(toId, toType, relationType, relationTypeGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findInfoByFrom
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInfoByFromUsingGET(fromId: string, fromType: string, relationTypeGroup?: string, options?: any) {
            return EntityRelationControllerApiFp(configuration).findInfoByFromUsingGET(fromId, fromType, relationTypeGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findInfoByQuery
         * @param {EntityRelationsQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInfoByQueryUsingPOST(query: EntityRelationsQuery, options?: any) {
            return EntityRelationControllerApiFp(configuration).findInfoByQueryUsingPOST(query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findInfoByTo
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInfoByToUsingGET(toId: string, toType: string, relationTypeGroup?: string, options?: any) {
            return EntityRelationControllerApiFp(configuration).findInfoByToUsingGET(toId, toType, relationTypeGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRelation
         * @param {string} fromId fromId
         * @param {string} fromType fromType
         * @param {string} relationType relationType
         * @param {string} toId toId
         * @param {string} toType toType
         * @param {string} [relationTypeGroup] relationTypeGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationUsingGET(fromId: string, fromType: string, relationType: string, toId: string, toType: string, relationTypeGroup?: string, options?: any) {
            return EntityRelationControllerApiFp(configuration).getRelationUsingGET(fromId, fromType, relationType, toId, toType, relationTypeGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveRelation
         * @param {EntityRelation} relation relation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRelationUsingPOST(relation: EntityRelation, options?: any) {
            return EntityRelationControllerApiFp(configuration).saveRelationUsingPOST(relation, options)(fetch, basePath);
        },
    };
};

/**
 * EntityRelationControllerApi - object-oriented interface
 * @export
 * @class EntityRelationControllerApi
 * @extends {BaseAPI}
 */
export class EntityRelationControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteRelation
     * @param {string} fromId fromId
     * @param {string} fromType fromType
     * @param {string} relationType relationType
     * @param {string} toId toId
     * @param {string} toType toType
     * @param {string} [relationTypeGroup] relationTypeGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public deleteRelationUsingDELETE(fromId: string, fromType: string, relationType: string, toId: string, toType: string, relationTypeGroup?: string, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).deleteRelationUsingDELETE(fromId, fromType, relationType, toId, toType, relationTypeGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteRelations
     * @param {string} entityId entityId
     * @param {string} entityType entityType
     * @param {string} id 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public deleteRelationsUsingDELETE(entityId: string, entityType: string, id: string, type: string, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).deleteRelationsUsingDELETE(entityId, entityType, id, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findByFrom
     * @param {string} fromId fromId
     * @param {string} fromType fromType
     * @param {string} [relationTypeGroup] relationTypeGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public findByFromUsingGET(fromId: string, fromType: string, relationTypeGroup?: string, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).findByFromUsingGET(fromId, fromType, relationTypeGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findByFrom
     * @param {string} fromId fromId
     * @param {string} fromType fromType
     * @param {string} relationType relationType
     * @param {string} [relationTypeGroup] relationTypeGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public findByFromUsingGET1(fromId: string, fromType: string, relationType: string, relationTypeGroup?: string, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).findByFromUsingGET1(fromId, fromType, relationType, relationTypeGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findByQuery
     * @param {EntityRelationsQuery} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public findByQueryUsingPOST2(query: EntityRelationsQuery, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).findByQueryUsingPOST2(query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findByTo
     * @param {string} toId toId
     * @param {string} toType toType
     * @param {string} [relationTypeGroup] relationTypeGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public findByToUsingGET(toId: string, toType: string, relationTypeGroup?: string, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).findByToUsingGET(toId, toType, relationTypeGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findByTo
     * @param {string} toId toId
     * @param {string} toType toType
     * @param {string} relationType relationType
     * @param {string} [relationTypeGroup] relationTypeGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public findByToUsingGET1(toId: string, toType: string, relationType: string, relationTypeGroup?: string, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).findByToUsingGET1(toId, toType, relationType, relationTypeGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findInfoByFrom
     * @param {string} fromId fromId
     * @param {string} fromType fromType
     * @param {string} [relationTypeGroup] relationTypeGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public findInfoByFromUsingGET(fromId: string, fromType: string, relationTypeGroup?: string, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).findInfoByFromUsingGET(fromId, fromType, relationTypeGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findInfoByQuery
     * @param {EntityRelationsQuery} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public findInfoByQueryUsingPOST(query: EntityRelationsQuery, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).findInfoByQueryUsingPOST(query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findInfoByTo
     * @param {string} toId toId
     * @param {string} toType toType
     * @param {string} [relationTypeGroup] relationTypeGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public findInfoByToUsingGET(toId: string, toType: string, relationTypeGroup?: string, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).findInfoByToUsingGET(toId, toType, relationTypeGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRelation
     * @param {string} fromId fromId
     * @param {string} fromType fromType
     * @param {string} relationType relationType
     * @param {string} toId toId
     * @param {string} toType toType
     * @param {string} [relationTypeGroup] relationTypeGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public getRelationUsingGET(fromId: string, fromType: string, relationType: string, toId: string, toType: string, relationTypeGroup?: string, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).getRelationUsingGET(fromId, fromType, relationType, toId, toType, relationTypeGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveRelation
     * @param {EntityRelation} relation relation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityRelationControllerApi
     */
    public saveRelationUsingPOST(relation: EntityRelation, options?: any) {
        return EntityRelationControllerApiFp(this.configuration).saveRelationUsingPOST(relation, options)(this.fetch, this.basePath);
    }

}

/**
 * EntityViewControllerApi - fetch parameter creator
 * @export
 */
export const EntityViewControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteEntityView
         * @param {string} entityViewId entityViewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityViewUsingDELETE(entityViewId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityViewId' is not null or undefined
            if (entityViewId === null || entityViewId === undefined) {
                throw new RequiredError('entityViewId','Required parameter entityViewId was null or undefined when calling deleteEntityViewUsingDELETE.');
            }
            const localVarPath = `/api/entityView/{entityViewId}`
                .replace(`{${"entityViewId"}}`, encodeURIComponent(String(entityViewId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByQuery
         * @param {EntityViewSearchQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST3(query: EntityViewSearchQuery, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling findByQueryUsingPOST3.');
            }
            const localVarPath = `/api/entityViews`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityViewSearchQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomerEntityViews
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerEntityViewsUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomerEntityViewsUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getCustomerEntityViewsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getCustomerEntityViewsUsingGET.');
            }
            const localVarPath = `/api/customer/{customerId}/entityViews{?type,textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityViewById
         * @param {string} entityViewId entityViewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewByIdUsingGET(entityViewId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityViewId' is not null or undefined
            if (entityViewId === null || entityViewId === undefined) {
                throw new RequiredError('entityViewId','Required parameter entityViewId was null or undefined when calling getEntityViewByIdUsingGET.');
            }
            const localVarPath = `/api/entityView/{entityViewId}`
                .replace(`{${"entityViewId"}}`, encodeURIComponent(String(entityViewId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityViewTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewTypesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/entityView/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityViewsByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getEntityViewsByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getEntityViewsByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getEntityViewsByEntityGroupIdUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/entityViews{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityViewsByIds
         * @param {string} entityViewIds entityViewIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewsByIdsUsingGET(entityViewIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityViewIds' is not null or undefined
            if (entityViewIds === null || entityViewIds === undefined) {
                throw new RequiredError('entityViewIds','Required parameter entityViewIds was null or undefined when calling getEntityViewsByIdsUsingGET.');
            }
            const localVarPath = `/api/entityViews{?entityViewIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (entityViewIds !== undefined) {
                localVarQueryParameter['entityViewIds'] = entityViewIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantEntityView
         * @param {string} entityViewName entityViewName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantEntityViewUsingGET(entityViewName: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityViewName' is not null or undefined
            if (entityViewName === null || entityViewName === undefined) {
                throw new RequiredError('entityViewName','Required parameter entityViewName was null or undefined when calling getTenantEntityViewUsingGET.');
            }
            const localVarPath = `/api/tenant/entityViews{?entityViewName}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (entityViewName !== undefined) {
                localVarQueryParameter['entityViewName'] = entityViewName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantEntityViews
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantEntityViewsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantEntityViewsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantEntityViewsUsingGET.');
            }
            const localVarPath = `/api/tenant/entityViews{?type,textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserEntityViews
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEntityViewsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getUserEntityViewsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserEntityViewsUsingGET.');
            }
            const localVarPath = `/api/user/entityViews{?type,textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveEntityView
         * @param {EntityView} entityView entityView
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityViewUsingPOST(entityView: EntityView, entityGroupId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityView' is not null or undefined
            if (entityView === null || entityView === undefined) {
                throw new RequiredError('entityView','Required parameter entityView was null or undefined when calling saveEntityViewUsingPOST.');
            }
            const localVarPath = `/api/entityView{?entityGroupId}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (entityGroupId !== undefined) {
                localVarQueryParameter['entityGroupId'] = entityGroupId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityView" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityView || {}) : (entityView || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityViewControllerApi - functional programming interface
 * @export
 */
export const EntityViewControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteEntityView
         * @param {string} entityViewId entityViewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityViewUsingDELETE(entityViewId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).deleteEntityViewUsingDELETE(entityViewId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findByQuery
         * @param {EntityViewSearchQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST3(query: EntityViewSearchQuery, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityView>> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).findByQueryUsingPOST3(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomerEntityViews
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerEntityViewsUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataEntityView> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).getCustomerEntityViewsUsingGET(customerId, pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityViewById
         * @param {string} entityViewId entityViewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewByIdUsingGET(entityViewId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityView> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).getEntityViewByIdUsingGET(entityViewId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityViewTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewTypesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntitySubtype>> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).getEntityViewTypesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityViewsByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataEntityView> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).getEntityViewsByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityViewsByIds
         * @param {string} entityViewIds entityViewIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewsByIdsUsingGET(entityViewIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EntityView>> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).getEntityViewsByIdsUsingGET(entityViewIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantEntityView
         * @param {string} entityViewName entityViewName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantEntityViewUsingGET(entityViewName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityView> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).getTenantEntityViewUsingGET(entityViewName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantEntityViews
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantEntityViewsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataEntityView> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).getTenantEntityViewsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserEntityViews
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEntityViewsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataEntityView> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).getUserEntityViewsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveEntityView
         * @param {EntityView} entityView entityView
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityViewUsingPOST(entityView: EntityView, entityGroupId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityView> {
            const localVarFetchArgs = EntityViewControllerApiFetchParamCreator(configuration).saveEntityViewUsingPOST(entityView, entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EntityViewControllerApi - factory interface
 * @export
 */
export const EntityViewControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteEntityView
         * @param {string} entityViewId entityViewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityViewUsingDELETE(entityViewId: string, options?: any) {
            return EntityViewControllerApiFp(configuration).deleteEntityViewUsingDELETE(entityViewId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findByQuery
         * @param {EntityViewSearchQuery} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByQueryUsingPOST3(query: EntityViewSearchQuery, options?: any) {
            return EntityViewControllerApiFp(configuration).findByQueryUsingPOST3(query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomerEntityViews
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerEntityViewsUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return EntityViewControllerApiFp(configuration).getCustomerEntityViewsUsingGET(customerId, pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityViewById
         * @param {string} entityViewId entityViewId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewByIdUsingGET(entityViewId: string, options?: any) {
            return EntityViewControllerApiFp(configuration).getEntityViewByIdUsingGET(entityViewId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityViewTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewTypesUsingGET(options?: any) {
            return EntityViewControllerApiFp(configuration).getEntityViewTypesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityViewsByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return EntityViewControllerApiFp(configuration).getEntityViewsByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityViewsByIds
         * @param {string} entityViewIds entityViewIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityViewsByIdsUsingGET(entityViewIds: string, options?: any) {
            return EntityViewControllerApiFp(configuration).getEntityViewsByIdsUsingGET(entityViewIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantEntityView
         * @param {string} entityViewName entityViewName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantEntityViewUsingGET(entityViewName: string, options?: any) {
            return EntityViewControllerApiFp(configuration).getTenantEntityViewUsingGET(entityViewName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantEntityViews
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantEntityViewsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return EntityViewControllerApiFp(configuration).getTenantEntityViewsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserEntityViews
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEntityViewsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return EntityViewControllerApiFp(configuration).getUserEntityViewsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveEntityView
         * @param {EntityView} entityView entityView
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityViewUsingPOST(entityView: EntityView, entityGroupId?: string, options?: any) {
            return EntityViewControllerApiFp(configuration).saveEntityViewUsingPOST(entityView, entityGroupId, options)(fetch, basePath);
        },
    };
};

/**
 * EntityViewControllerApi - object-oriented interface
 * @export
 * @class EntityViewControllerApi
 * @extends {BaseAPI}
 */
export class EntityViewControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteEntityView
     * @param {string} entityViewId entityViewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public deleteEntityViewUsingDELETE(entityViewId: string, options?: any) {
        return EntityViewControllerApiFp(this.configuration).deleteEntityViewUsingDELETE(entityViewId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findByQuery
     * @param {EntityViewSearchQuery} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public findByQueryUsingPOST3(query: EntityViewSearchQuery, options?: any) {
        return EntityViewControllerApiFp(this.configuration).findByQueryUsingPOST3(query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomerEntityViews
     * @param {string} customerId customerId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public getCustomerEntityViewsUsingGET(customerId: string, pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return EntityViewControllerApiFp(this.configuration).getCustomerEntityViewsUsingGET(customerId, pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityViewById
     * @param {string} entityViewId entityViewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public getEntityViewByIdUsingGET(entityViewId: string, options?: any) {
        return EntityViewControllerApiFp(this.configuration).getEntityViewByIdUsingGET(entityViewId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityViewTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public getEntityViewTypesUsingGET(options?: any) {
        return EntityViewControllerApiFp(this.configuration).getEntityViewTypesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityViewsByEntityGroupId
     * @param {string} entityGroupId entityGroupId
     * @param {string} pageSize Page size
     * @param {string} page Page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public getEntityViewsByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return EntityViewControllerApiFp(this.configuration).getEntityViewsByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityViewsByIds
     * @param {string} entityViewIds entityViewIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public getEntityViewsByIdsUsingGET(entityViewIds: string, options?: any) {
        return EntityViewControllerApiFp(this.configuration).getEntityViewsByIdsUsingGET(entityViewIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantEntityView
     * @param {string} entityViewName entityViewName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public getTenantEntityViewUsingGET(entityViewName: string, options?: any) {
        return EntityViewControllerApiFp(this.configuration).getTenantEntityViewUsingGET(entityViewName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantEntityViews
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public getTenantEntityViewsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return EntityViewControllerApiFp(this.configuration).getTenantEntityViewsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserEntityViews
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public getUserEntityViewsUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return EntityViewControllerApiFp(this.configuration).getUserEntityViewsUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveEntityView
     * @param {EntityView} entityView entityView
     * @param {string} [entityGroupId] entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityViewControllerApi
     */
    public saveEntityViewUsingPOST(entityView: EntityView, entityGroupId?: string, options?: any) {
        return EntityViewControllerApiFp(this.configuration).saveEntityViewUsingPOST(entityView, entityGroupId, options)(this.fetch, this.basePath);
    }

}

/**
 * EventControllerApi - fetch parameter creator
 * @export
 */
export const EventControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getEvents
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} eventType eventType
         * @param {string} tenantId tenantId
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsingGET(entityType: string, entityId: string, eventType: string, tenantId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getEventsUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getEventsUsingGET.');
            }
            // verify required parameter 'eventType' is not null or undefined
            if (eventType === null || eventType === undefined) {
                throw new RequiredError('eventType','Required parameter eventType was null or undefined when calling getEventsUsingGET.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getEventsUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getEventsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getEventsUsingGET.');
            }
            const localVarPath = `/api/events/{entityType}/{entityId}/{eventType}{?tenantId,pageSize,page,textSearch,sortProperty,sortOrder,startTime,endTime}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEvents
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} tenantId tenantId
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsingGET1(entityType: string, entityId: string, tenantId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getEventsUsingGET1.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getEventsUsingGET1.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getEventsUsingGET1.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getEventsUsingGET1.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getEventsUsingGET1.');
            }
            const localVarPath = `/api/events/{entityType}/{entityId}{?tenantId,pageSize,page,textSearch,sortProperty,sortOrder,startTime,endTime}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventControllerApi - functional programming interface
 * @export
 */
export const EventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getEvents
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} eventType eventType
         * @param {string} tenantId tenantId
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsingGET(entityType: string, entityId: string, eventType: string, tenantId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataEvent> {
            const localVarFetchArgs = EventControllerApiFetchParamCreator(configuration).getEventsUsingGET(entityType, entityId, eventType, tenantId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEvents
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} tenantId tenantId
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsingGET1(entityType: string, entityId: string, tenantId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataEvent> {
            const localVarFetchArgs = EventControllerApiFetchParamCreator(configuration).getEventsUsingGET1(entityType, entityId, tenantId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventControllerApi - factory interface
 * @export
 */
export const EventControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getEvents
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} eventType eventType
         * @param {string} tenantId tenantId
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsingGET(entityType: string, entityId: string, eventType: string, tenantId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options?: any) {
            return EventControllerApiFp(configuration).getEventsUsingGET(entityType, entityId, eventType, tenantId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEvents
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} tenantId tenantId
         * @param {number} pageSize pageSize
         * @param {number} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {number} [startTime] startTime
         * @param {number} [endTime] endTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsingGET1(entityType: string, entityId: string, tenantId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options?: any) {
            return EventControllerApiFp(configuration).getEventsUsingGET1(entityType, entityId, tenantId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, options)(fetch, basePath);
        },
    };
};

/**
 * EventControllerApi - object-oriented interface
 * @export
 * @class EventControllerApi
 * @extends {BaseAPI}
 */
export class EventControllerApi extends BaseAPI {
    /**
     * 
     * @summary getEvents
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} eventType eventType
     * @param {string} tenantId tenantId
     * @param {number} pageSize pageSize
     * @param {number} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {number} [startTime] startTime
     * @param {number} [endTime] endTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public getEventsUsingGET(entityType: string, entityId: string, eventType: string, tenantId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options?: any) {
        return EventControllerApiFp(this.configuration).getEventsUsingGET(entityType, entityId, eventType, tenantId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEvents
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} tenantId tenantId
     * @param {number} pageSize pageSize
     * @param {number} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {number} [startTime] startTime
     * @param {number} [endTime] endTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public getEventsUsingGET1(entityType: string, entityId: string, tenantId: string, pageSize: number, page: number, textSearch?: string, sortProperty?: string, sortOrder?: string, startTime?: number, endTime?: number, options?: any) {
        return EventControllerApiFp(this.configuration).getEventsUsingGET1(entityType, entityId, tenantId, pageSize, page, textSearch, sortProperty, sortOrder, startTime, endTime, options)(this.fetch, this.basePath);
    }

}

/**
 * GroupPermissionControllerApi - fetch parameter creator
 * @export
 */
export const GroupPermissionControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteGroupPermission
         * @param {string} groupPermissionId groupPermissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupPermissionUsingDELETE(groupPermissionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupPermissionId' is not null or undefined
            if (groupPermissionId === null || groupPermissionId === undefined) {
                throw new RequiredError('groupPermissionId','Required parameter groupPermissionId was null or undefined when calling deleteGroupPermissionUsingDELETE.');
            }
            const localVarPath = `/api/groupPermission/{groupPermissionId}`
                .replace(`{${"groupPermissionId"}}`, encodeURIComponent(String(groupPermissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEntityGroupPermissions
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupPermissionsUsingGET(entityGroupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getEntityGroupPermissionsUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/groupPermissions`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGroupPermissionById
         * @param {string} groupPermissionId groupPermissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissionByIdUsingGET(groupPermissionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupPermissionId' is not null or undefined
            if (groupPermissionId === null || groupPermissionId === undefined) {
                throw new RequiredError('groupPermissionId','Required parameter groupPermissionId was null or undefined when calling getGroupPermissionByIdUsingGET.');
            }
            const localVarPath = `/api/groupPermission/{groupPermissionId}`
                .replace(`{${"groupPermissionId"}}`, encodeURIComponent(String(groupPermissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGroupPermissionInfoById
         * @param {string} groupPermissionId groupPermissionId
         * @param {boolean} isUserGroup isUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissionInfoByIdUsingGET(groupPermissionId: string, isUserGroup: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'groupPermissionId' is not null or undefined
            if (groupPermissionId === null || groupPermissionId === undefined) {
                throw new RequiredError('groupPermissionId','Required parameter groupPermissionId was null or undefined when calling getGroupPermissionInfoByIdUsingGET.');
            }
            // verify required parameter 'isUserGroup' is not null or undefined
            if (isUserGroup === null || isUserGroup === undefined) {
                throw new RequiredError('isUserGroup','Required parameter isUserGroup was null or undefined when calling getGroupPermissionInfoByIdUsingGET.');
            }
            const localVarPath = `/api/groupPermission/info/{groupPermissionId}{?isUserGroup}`
                .replace(`{${"groupPermissionId"}}`, encodeURIComponent(String(groupPermissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (isUserGroup !== undefined) {
                localVarQueryParameter['isUserGroup'] = isUserGroup;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserGroupPermissions
         * @param {string} userGroupId userGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupPermissionsUsingGET(userGroupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userGroupId' is not null or undefined
            if (userGroupId === null || userGroupId === undefined) {
                throw new RequiredError('userGroupId','Required parameter userGroupId was null or undefined when calling getUserGroupPermissionsUsingGET.');
            }
            const localVarPath = `/api/userGroup/{userGroupId}/groupPermissions`
                .replace(`{${"userGroupId"}}`, encodeURIComponent(String(userGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary loadUserGroupPermissionInfos
         * @param {Array<GroupPermission>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadUserGroupPermissionInfosUsingPOST(permissions: Array<GroupPermission>, options: any = {}): FetchArgs {
            // verify required parameter 'permissions' is not null or undefined
            if (permissions === null || permissions === undefined) {
                throw new RequiredError('permissions','Required parameter permissions was null or undefined when calling loadUserGroupPermissionInfosUsingPOST.');
            }
            const localVarPath = `/api/userGroup/groupPermissions/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;GroupPermission&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(permissions || {}) : (permissions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveGroupPermission
         * @param {GroupPermission} groupPermission groupPermission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroupPermissionUsingPOST(groupPermission: GroupPermission, options: any = {}): FetchArgs {
            // verify required parameter 'groupPermission' is not null or undefined
            if (groupPermission === null || groupPermission === undefined) {
                throw new RequiredError('groupPermission','Required parameter groupPermission was null or undefined when calling saveGroupPermissionUsingPOST.');
            }
            const localVarPath = `/api/groupPermission`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GroupPermission" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(groupPermission || {}) : (groupPermission || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupPermissionControllerApi - functional programming interface
 * @export
 */
export const GroupPermissionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteGroupPermission
         * @param {string} groupPermissionId groupPermissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupPermissionUsingDELETE(groupPermissionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GroupPermissionControllerApiFetchParamCreator(configuration).deleteGroupPermissionUsingDELETE(groupPermissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getEntityGroupPermissions
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupPermissionsUsingGET(entityGroupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupPermissionInfo>> {
            const localVarFetchArgs = GroupPermissionControllerApiFetchParamCreator(configuration).getEntityGroupPermissionsUsingGET(entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getGroupPermissionById
         * @param {string} groupPermissionId groupPermissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissionByIdUsingGET(groupPermissionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPermission> {
            const localVarFetchArgs = GroupPermissionControllerApiFetchParamCreator(configuration).getGroupPermissionByIdUsingGET(groupPermissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getGroupPermissionInfoById
         * @param {string} groupPermissionId groupPermissionId
         * @param {boolean} isUserGroup isUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissionInfoByIdUsingGET(groupPermissionId: string, isUserGroup: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPermissionInfo> {
            const localVarFetchArgs = GroupPermissionControllerApiFetchParamCreator(configuration).getGroupPermissionInfoByIdUsingGET(groupPermissionId, isUserGroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserGroupPermissions
         * @param {string} userGroupId userGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupPermissionsUsingGET(userGroupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupPermissionInfo>> {
            const localVarFetchArgs = GroupPermissionControllerApiFetchParamCreator(configuration).getUserGroupPermissionsUsingGET(userGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary loadUserGroupPermissionInfos
         * @param {Array<GroupPermission>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadUserGroupPermissionInfosUsingPOST(permissions: Array<GroupPermission>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupPermissionInfo>> {
            const localVarFetchArgs = GroupPermissionControllerApiFetchParamCreator(configuration).loadUserGroupPermissionInfosUsingPOST(permissions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveGroupPermission
         * @param {GroupPermission} groupPermission groupPermission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroupPermissionUsingPOST(groupPermission: GroupPermission, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupPermission> {
            const localVarFetchArgs = GroupPermissionControllerApiFetchParamCreator(configuration).saveGroupPermissionUsingPOST(groupPermission, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GroupPermissionControllerApi - factory interface
 * @export
 */
export const GroupPermissionControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteGroupPermission
         * @param {string} groupPermissionId groupPermissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupPermissionUsingDELETE(groupPermissionId: string, options?: any) {
            return GroupPermissionControllerApiFp(configuration).deleteGroupPermissionUsingDELETE(groupPermissionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getEntityGroupPermissions
         * @param {string} entityGroupId entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityGroupPermissionsUsingGET(entityGroupId: string, options?: any) {
            return GroupPermissionControllerApiFp(configuration).getEntityGroupPermissionsUsingGET(entityGroupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getGroupPermissionById
         * @param {string} groupPermissionId groupPermissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissionByIdUsingGET(groupPermissionId: string, options?: any) {
            return GroupPermissionControllerApiFp(configuration).getGroupPermissionByIdUsingGET(groupPermissionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getGroupPermissionInfoById
         * @param {string} groupPermissionId groupPermissionId
         * @param {boolean} isUserGroup isUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissionInfoByIdUsingGET(groupPermissionId: string, isUserGroup: boolean, options?: any) {
            return GroupPermissionControllerApiFp(configuration).getGroupPermissionInfoByIdUsingGET(groupPermissionId, isUserGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserGroupPermissions
         * @param {string} userGroupId userGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupPermissionsUsingGET(userGroupId: string, options?: any) {
            return GroupPermissionControllerApiFp(configuration).getUserGroupPermissionsUsingGET(userGroupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary loadUserGroupPermissionInfos
         * @param {Array<GroupPermission>} permissions permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadUserGroupPermissionInfosUsingPOST(permissions: Array<GroupPermission>, options?: any) {
            return GroupPermissionControllerApiFp(configuration).loadUserGroupPermissionInfosUsingPOST(permissions, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveGroupPermission
         * @param {GroupPermission} groupPermission groupPermission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroupPermissionUsingPOST(groupPermission: GroupPermission, options?: any) {
            return GroupPermissionControllerApiFp(configuration).saveGroupPermissionUsingPOST(groupPermission, options)(fetch, basePath);
        },
    };
};

/**
 * GroupPermissionControllerApi - object-oriented interface
 * @export
 * @class GroupPermissionControllerApi
 * @extends {BaseAPI}
 */
export class GroupPermissionControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteGroupPermission
     * @param {string} groupPermissionId groupPermissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPermissionControllerApi
     */
    public deleteGroupPermissionUsingDELETE(groupPermissionId: string, options?: any) {
        return GroupPermissionControllerApiFp(this.configuration).deleteGroupPermissionUsingDELETE(groupPermissionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getEntityGroupPermissions
     * @param {string} entityGroupId entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPermissionControllerApi
     */
    public getEntityGroupPermissionsUsingGET(entityGroupId: string, options?: any) {
        return GroupPermissionControllerApiFp(this.configuration).getEntityGroupPermissionsUsingGET(entityGroupId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getGroupPermissionById
     * @param {string} groupPermissionId groupPermissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPermissionControllerApi
     */
    public getGroupPermissionByIdUsingGET(groupPermissionId: string, options?: any) {
        return GroupPermissionControllerApiFp(this.configuration).getGroupPermissionByIdUsingGET(groupPermissionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getGroupPermissionInfoById
     * @param {string} groupPermissionId groupPermissionId
     * @param {boolean} isUserGroup isUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPermissionControllerApi
     */
    public getGroupPermissionInfoByIdUsingGET(groupPermissionId: string, isUserGroup: boolean, options?: any) {
        return GroupPermissionControllerApiFp(this.configuration).getGroupPermissionInfoByIdUsingGET(groupPermissionId, isUserGroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserGroupPermissions
     * @param {string} userGroupId userGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPermissionControllerApi
     */
    public getUserGroupPermissionsUsingGET(userGroupId: string, options?: any) {
        return GroupPermissionControllerApiFp(this.configuration).getUserGroupPermissionsUsingGET(userGroupId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary loadUserGroupPermissionInfos
     * @param {Array<GroupPermission>} permissions permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPermissionControllerApi
     */
    public loadUserGroupPermissionInfosUsingPOST(permissions: Array<GroupPermission>, options?: any) {
        return GroupPermissionControllerApiFp(this.configuration).loadUserGroupPermissionInfosUsingPOST(permissions, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveGroupPermission
     * @param {GroupPermission} groupPermission groupPermission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPermissionControllerApi
     */
    public saveGroupPermissionUsingPOST(groupPermission: GroupPermission, options?: any) {
        return GroupPermissionControllerApiFp(this.configuration).saveGroupPermissionUsingPOST(groupPermission, options)(this.fetch, this.basePath);
    }

}

/**
 * HttpIntegrationControllerApi - fetch parameter creator
 * @export
 */
export const HttpIntegrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkStatus
         * @param {string} routingKey routingKey
         * @param {any} requestParams requestParams
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkStatusUsingGET(routingKey: string, requestParams: any, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling checkStatusUsingGET.');
            }
            // verify required parameter 'requestParams' is not null or undefined
            if (requestParams === null || requestParams === undefined) {
                throw new RequiredError('requestParams','Required parameter requestParams was null or undefined when calling checkStatusUsingGET.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling checkStatusUsingGET.');
            }
            const localVarPath = `/api/v1/integrations/http/{routingKey}{?requestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestParams !== undefined) {
                localVarQueryParameter['requestParams'] = requestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} suffix suffix
         * @param {any} requestParams requestParams
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST3(routingKey: string, suffix: string, requestParams: any, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPOST3.');
            }
            // verify required parameter 'suffix' is not null or undefined
            if (suffix === null || suffix === undefined) {
                throw new RequiredError('suffix','Required parameter suffix was null or undefined when calling processRequestUsingPOST3.');
            }
            // verify required parameter 'requestParams' is not null or undefined
            if (requestParams === null || requestParams === undefined) {
                throw new RequiredError('requestParams','Required parameter requestParams was null or undefined when calling processRequestUsingPOST3.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPOST3.');
            }
            const localVarPath = `/api/v1/integrations/http/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)))
                .replace(`{${"suffix"}}`, encodeURIComponent(String(suffix)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            if (requestParams !== undefined) {
                localVarFormParams.set('requestParams', requestParams as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} suffix suffix
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST6(routingKey: string, suffix: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPOST6.');
            }
            // verify required parameter 'suffix' is not null or undefined
            if (suffix === null || suffix === undefined) {
                throw new RequiredError('suffix','Required parameter suffix was null or undefined when calling processRequestUsingPOST6.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPOST6.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPOST6.');
            }
            const localVarPath = `/api/v1/integrations/http/{routingKey}/{suffix}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)))
                .replace(`{${"suffix"}}`, encodeURIComponent(String(suffix)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HttpIntegrationControllerApi - functional programming interface
 * @export
 */
export const HttpIntegrationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkStatus
         * @param {string} routingKey routingKey
         * @param {any} requestParams requestParams
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkStatusUsingGET(routingKey: string, requestParams: any, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = HttpIntegrationControllerApiFetchParamCreator(configuration).checkStatusUsingGET(routingKey, requestParams, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} suffix suffix
         * @param {any} requestParams requestParams
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST3(routingKey: string, suffix: string, requestParams: any, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = HttpIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPOST3(routingKey, suffix, requestParams, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} suffix suffix
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST6(routingKey: string, suffix: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = HttpIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPOST6(routingKey, suffix, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HttpIntegrationControllerApi - factory interface
 * @export
 */
export const HttpIntegrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary checkStatus
         * @param {string} routingKey routingKey
         * @param {any} requestParams requestParams
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkStatusUsingGET(routingKey: string, requestParams: any, requestHeaders: any, options?: any) {
            return HttpIntegrationControllerApiFp(configuration).checkStatusUsingGET(routingKey, requestParams, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} suffix suffix
         * @param {any} requestParams requestParams
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST3(routingKey: string, suffix: string, requestParams: any, requestHeaders: any, options?: any) {
            return HttpIntegrationControllerApiFp(configuration).processRequestUsingPOST3(routingKey, suffix, requestParams, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} suffix suffix
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST6(routingKey: string, suffix: string, msg: string, requestHeaders: any, options?: any) {
            return HttpIntegrationControllerApiFp(configuration).processRequestUsingPOST6(routingKey, suffix, msg, requestHeaders, options)(fetch, basePath);
        },
    };
};

/**
 * HttpIntegrationControllerApi - object-oriented interface
 * @export
 * @class HttpIntegrationControllerApi
 * @extends {BaseAPI}
 */
export class HttpIntegrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary checkStatus
     * @param {string} routingKey routingKey
     * @param {any} requestParams requestParams
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HttpIntegrationControllerApi
     */
    public checkStatusUsingGET(routingKey: string, requestParams: any, requestHeaders: any, options?: any) {
        return HttpIntegrationControllerApiFp(this.configuration).checkStatusUsingGET(routingKey, requestParams, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} suffix suffix
     * @param {any} requestParams requestParams
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HttpIntegrationControllerApi
     */
    public processRequestUsingPOST3(routingKey: string, suffix: string, requestParams: any, requestHeaders: any, options?: any) {
        return HttpIntegrationControllerApiFp(this.configuration).processRequestUsingPOST3(routingKey, suffix, requestParams, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} suffix suffix
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HttpIntegrationControllerApi
     */
    public processRequestUsingPOST6(routingKey: string, suffix: string, msg: string, requestHeaders: any, options?: any) {
        return HttpIntegrationControllerApiFp(this.configuration).processRequestUsingPOST6(routingKey, suffix, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

}

/**
 * IntegrationControllerApi - fetch parameter creator
 * @export
 */
export const IntegrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkIntegrationConnection
         * @param {Integration} integration integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIntegrationConnectionUsingPOST(integration: Integration, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling checkIntegrationConnectionUsingPOST.');
            }
            const localVarPath = `/api/integration/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Integration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(integration || {}) : (integration || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteIntegration
         * @param {string} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegrationUsingDELETE(integrationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId','Required parameter integrationId was null or undefined when calling deleteIntegrationUsingDELETE.');
            }
            const localVarPath = `/api/integration/{integrationId}`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getIntegrationById
         * @param {string} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationByIdUsingGET(integrationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId','Required parameter integrationId was null or undefined when calling getIntegrationByIdUsingGET.');
            }
            const localVarPath = `/api/integration/{integrationId}`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getIntegrationByRoutingKey
         * @param {string} routingKey routingKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationByRoutingKeyUsingGET(routingKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling getIntegrationByRoutingKeyUsingGET.');
            }
            const localVarPath = `/api/integration/routingKey/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getIntegrationsByIds
         * @param {string} integrationIds integrationIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsByIdsUsingGET(integrationIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'integrationIds' is not null or undefined
            if (integrationIds === null || integrationIds === undefined) {
                throw new RequiredError('integrationIds','Required parameter integrationIds was null or undefined when calling getIntegrationsByIdsUsingGET.');
            }
            const localVarPath = `/api/integrations{?integrationIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (integrationIds !== undefined) {
                localVarQueryParameter['integrationIds'] = integrationIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getIntegrations
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getIntegrationsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getIntegrationsUsingGET.');
            }
            const localVarPath = `/api/integrations{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveIntegration
         * @param {Integration} integration integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveIntegrationUsingPOST(integration: Integration, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling saveIntegrationUsingPOST.');
            }
            const localVarPath = `/api/integration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Integration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(integration || {}) : (integration || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationControllerApi - functional programming interface
 * @export
 */
export const IntegrationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkIntegrationConnection
         * @param {Integration} integration integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIntegrationConnectionUsingPOST(integration: Integration, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).checkIntegrationConnectionUsingPOST(integration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteIntegration
         * @param {string} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegrationUsingDELETE(integrationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).deleteIntegrationUsingDELETE(integrationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getIntegrationById
         * @param {string} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationByIdUsingGET(integrationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Integration> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getIntegrationByIdUsingGET(integrationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getIntegrationByRoutingKey
         * @param {string} routingKey routingKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationByRoutingKeyUsingGET(routingKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Integration> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getIntegrationByRoutingKeyUsingGET(routingKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getIntegrationsByIds
         * @param {string} integrationIds integrationIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsByIdsUsingGET(integrationIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Integration>> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getIntegrationsByIdsUsingGET(integrationIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getIntegrations
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataIntegration> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getIntegrationsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveIntegration
         * @param {Integration} integration integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveIntegrationUsingPOST(integration: Integration, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Integration> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).saveIntegrationUsingPOST(integration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntegrationControllerApi - factory interface
 * @export
 */
export const IntegrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary checkIntegrationConnection
         * @param {Integration} integration integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIntegrationConnectionUsingPOST(integration: Integration, options?: any) {
            return IntegrationControllerApiFp(configuration).checkIntegrationConnectionUsingPOST(integration, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteIntegration
         * @param {string} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegrationUsingDELETE(integrationId: string, options?: any) {
            return IntegrationControllerApiFp(configuration).deleteIntegrationUsingDELETE(integrationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getIntegrationById
         * @param {string} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationByIdUsingGET(integrationId: string, options?: any) {
            return IntegrationControllerApiFp(configuration).getIntegrationByIdUsingGET(integrationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getIntegrationByRoutingKey
         * @param {string} routingKey routingKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationByRoutingKeyUsingGET(routingKey: string, options?: any) {
            return IntegrationControllerApiFp(configuration).getIntegrationByRoutingKeyUsingGET(routingKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getIntegrationsByIds
         * @param {string} integrationIds integrationIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsByIdsUsingGET(integrationIds: string, options?: any) {
            return IntegrationControllerApiFp(configuration).getIntegrationsByIdsUsingGET(integrationIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getIntegrations
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return IntegrationControllerApiFp(configuration).getIntegrationsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveIntegration
         * @param {Integration} integration integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveIntegrationUsingPOST(integration: Integration, options?: any) {
            return IntegrationControllerApiFp(configuration).saveIntegrationUsingPOST(integration, options)(fetch, basePath);
        },
    };
};

/**
 * IntegrationControllerApi - object-oriented interface
 * @export
 * @class IntegrationControllerApi
 * @extends {BaseAPI}
 */
export class IntegrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary checkIntegrationConnection
     * @param {Integration} integration integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public checkIntegrationConnectionUsingPOST(integration: Integration, options?: any) {
        return IntegrationControllerApiFp(this.configuration).checkIntegrationConnectionUsingPOST(integration, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteIntegration
     * @param {string} integrationId integrationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public deleteIntegrationUsingDELETE(integrationId: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).deleteIntegrationUsingDELETE(integrationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getIntegrationById
     * @param {string} integrationId integrationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getIntegrationByIdUsingGET(integrationId: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).getIntegrationByIdUsingGET(integrationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getIntegrationByRoutingKey
     * @param {string} routingKey routingKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getIntegrationByRoutingKeyUsingGET(routingKey: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).getIntegrationByRoutingKeyUsingGET(routingKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getIntegrationsByIds
     * @param {string} integrationIds integrationIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getIntegrationsByIdsUsingGET(integrationIds: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).getIntegrationsByIdsUsingGET(integrationIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getIntegrations
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getIntegrationsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).getIntegrationsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveIntegration
     * @param {Integration} integration integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public saveIntegrationUsingPOST(integration: Integration, options?: any) {
        return IntegrationControllerApiFp(this.configuration).saveIntegrationUsingPOST(integration, options)(this.fetch, this.basePath);
    }

}

/**
 * LoriotIntegrationControllerApi - fetch parameter creator
 * @export
 */
export const LoriotIntegrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE1(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingDELETE1.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingDELETE1.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingDELETE1.');
            }
            const localVarPath = `/api/v1/integrations/loriot/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET1(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingGET1.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingGET1.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingGET1.');
            }
            const localVarPath = `/api/v1/integrations/loriot/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD1(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingHEAD1.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingHEAD1.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingHEAD1.');
            }
            const localVarPath = `/api/v1/integrations/loriot/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS1(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingOPTIONS1.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingOPTIONS1.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingOPTIONS1.');
            }
            const localVarPath = `/api/v1/integrations/loriot/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH1(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPATCH1.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPATCH1.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPATCH1.');
            }
            const localVarPath = `/api/v1/integrations/loriot/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST7(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPOST7.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPOST7.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPOST7.');
            }
            const localVarPath = `/api/v1/integrations/loriot/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT1(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPUT1.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPUT1.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPUT1.');
            }
            const localVarPath = `/api/v1/integrations/loriot/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoriotIntegrationControllerApi - functional programming interface
 * @export
 */
export const LoriotIntegrationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE1(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = LoriotIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingDELETE1(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET1(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = LoriotIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingGET1(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD1(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = LoriotIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingHEAD1(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS1(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = LoriotIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingOPTIONS1(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH1(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = LoriotIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPATCH1(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST7(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = LoriotIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPOST7(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT1(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = LoriotIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPUT1(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LoriotIntegrationControllerApi - factory interface
 * @export
 */
export const LoriotIntegrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return LoriotIntegrationControllerApiFp(configuration).processRequestUsingDELETE1(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return LoriotIntegrationControllerApiFp(configuration).processRequestUsingGET1(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return LoriotIntegrationControllerApiFp(configuration).processRequestUsingHEAD1(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return LoriotIntegrationControllerApiFp(configuration).processRequestUsingOPTIONS1(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return LoriotIntegrationControllerApiFp(configuration).processRequestUsingPATCH1(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST7(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return LoriotIntegrationControllerApiFp(configuration).processRequestUsingPOST7(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return LoriotIntegrationControllerApiFp(configuration).processRequestUsingPUT1(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
    };
};

/**
 * LoriotIntegrationControllerApi - object-oriented interface
 * @export
 * @class LoriotIntegrationControllerApi
 * @extends {BaseAPI}
 */
export class LoriotIntegrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoriotIntegrationControllerApi
     */
    public processRequestUsingDELETE1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return LoriotIntegrationControllerApiFp(this.configuration).processRequestUsingDELETE1(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoriotIntegrationControllerApi
     */
    public processRequestUsingGET1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return LoriotIntegrationControllerApiFp(this.configuration).processRequestUsingGET1(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoriotIntegrationControllerApi
     */
    public processRequestUsingHEAD1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return LoriotIntegrationControllerApiFp(this.configuration).processRequestUsingHEAD1(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoriotIntegrationControllerApi
     */
    public processRequestUsingOPTIONS1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return LoriotIntegrationControllerApiFp(this.configuration).processRequestUsingOPTIONS1(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoriotIntegrationControllerApi
     */
    public processRequestUsingPATCH1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return LoriotIntegrationControllerApiFp(this.configuration).processRequestUsingPATCH1(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoriotIntegrationControllerApi
     */
    public processRequestUsingPOST7(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return LoriotIntegrationControllerApiFp(this.configuration).processRequestUsingPOST7(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoriotIntegrationControllerApi
     */
    public processRequestUsingPUT1(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return LoriotIntegrationControllerApiFp(this.configuration).processRequestUsingPUT1(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

}

/**
 * OAuth2ConfigTemplateControllerApi - fetch parameter creator
 * @export
 */
export const OAuth2ConfigTemplateControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteClientRegistrationTemplate
         * @param {string} clientRegistrationTemplateId clientRegistrationTemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientRegistrationTemplateUsingDELETE(clientRegistrationTemplateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'clientRegistrationTemplateId' is not null or undefined
            if (clientRegistrationTemplateId === null || clientRegistrationTemplateId === undefined) {
                throw new RequiredError('clientRegistrationTemplateId','Required parameter clientRegistrationTemplateId was null or undefined when calling deleteClientRegistrationTemplateUsingDELETE.');
            }
            const localVarPath = `/api/oauth2/config/template/{clientRegistrationTemplateId}`
                .replace(`{${"clientRegistrationTemplateId"}}`, encodeURIComponent(String(clientRegistrationTemplateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getClientRegistrationTemplates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientRegistrationTemplatesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/oauth2/config/template`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveClientRegistrationTemplate
         * @param {OAuth2ClientRegistrationTemplate} clientRegistrationTemplate clientRegistrationTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveClientRegistrationTemplateUsingPOST(clientRegistrationTemplate: OAuth2ClientRegistrationTemplate, options: any = {}): FetchArgs {
            // verify required parameter 'clientRegistrationTemplate' is not null or undefined
            if (clientRegistrationTemplate === null || clientRegistrationTemplate === undefined) {
                throw new RequiredError('clientRegistrationTemplate','Required parameter clientRegistrationTemplate was null or undefined when calling saveClientRegistrationTemplateUsingPOST.');
            }
            const localVarPath = `/api/oauth2/config/template`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OAuth2ClientRegistrationTemplate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(clientRegistrationTemplate || {}) : (clientRegistrationTemplate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2ConfigTemplateControllerApi - functional programming interface
 * @export
 */
export const OAuth2ConfigTemplateControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteClientRegistrationTemplate
         * @param {string} clientRegistrationTemplateId clientRegistrationTemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientRegistrationTemplateUsingDELETE(clientRegistrationTemplateId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OAuth2ConfigTemplateControllerApiFetchParamCreator(configuration).deleteClientRegistrationTemplateUsingDELETE(clientRegistrationTemplateId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getClientRegistrationTemplates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientRegistrationTemplatesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OAuth2ClientRegistrationTemplate>> {
            const localVarFetchArgs = OAuth2ConfigTemplateControllerApiFetchParamCreator(configuration).getClientRegistrationTemplatesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveClientRegistrationTemplate
         * @param {OAuth2ClientRegistrationTemplate} clientRegistrationTemplate clientRegistrationTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveClientRegistrationTemplateUsingPOST(clientRegistrationTemplate: OAuth2ClientRegistrationTemplate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OAuth2ClientRegistrationTemplate> {
            const localVarFetchArgs = OAuth2ConfigTemplateControllerApiFetchParamCreator(configuration).saveClientRegistrationTemplateUsingPOST(clientRegistrationTemplate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OAuth2ConfigTemplateControllerApi - factory interface
 * @export
 */
export const OAuth2ConfigTemplateControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteClientRegistrationTemplate
         * @param {string} clientRegistrationTemplateId clientRegistrationTemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientRegistrationTemplateUsingDELETE(clientRegistrationTemplateId: string, options?: any) {
            return OAuth2ConfigTemplateControllerApiFp(configuration).deleteClientRegistrationTemplateUsingDELETE(clientRegistrationTemplateId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getClientRegistrationTemplates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientRegistrationTemplatesUsingGET(options?: any) {
            return OAuth2ConfigTemplateControllerApiFp(configuration).getClientRegistrationTemplatesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveClientRegistrationTemplate
         * @param {OAuth2ClientRegistrationTemplate} clientRegistrationTemplate clientRegistrationTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveClientRegistrationTemplateUsingPOST(clientRegistrationTemplate: OAuth2ClientRegistrationTemplate, options?: any) {
            return OAuth2ConfigTemplateControllerApiFp(configuration).saveClientRegistrationTemplateUsingPOST(clientRegistrationTemplate, options)(fetch, basePath);
        },
    };
};

/**
 * OAuth2ConfigTemplateControllerApi - object-oriented interface
 * @export
 * @class OAuth2ConfigTemplateControllerApi
 * @extends {BaseAPI}
 */
export class OAuth2ConfigTemplateControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteClientRegistrationTemplate
     * @param {string} clientRegistrationTemplateId clientRegistrationTemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ConfigTemplateControllerApi
     */
    public deleteClientRegistrationTemplateUsingDELETE(clientRegistrationTemplateId: string, options?: any) {
        return OAuth2ConfigTemplateControllerApiFp(this.configuration).deleteClientRegistrationTemplateUsingDELETE(clientRegistrationTemplateId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getClientRegistrationTemplates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ConfigTemplateControllerApi
     */
    public getClientRegistrationTemplatesUsingGET(options?: any) {
        return OAuth2ConfigTemplateControllerApiFp(this.configuration).getClientRegistrationTemplatesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveClientRegistrationTemplate
     * @param {OAuth2ClientRegistrationTemplate} clientRegistrationTemplate clientRegistrationTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ConfigTemplateControllerApi
     */
    public saveClientRegistrationTemplateUsingPOST(clientRegistrationTemplate: OAuth2ClientRegistrationTemplate, options?: any) {
        return OAuth2ConfigTemplateControllerApiFp(this.configuration).saveClientRegistrationTemplateUsingPOST(clientRegistrationTemplate, options)(this.fetch, this.basePath);
    }

}

/**
 * OAuth2ControllerApi - fetch parameter creator
 * @export
 */
export const OAuth2ControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCurrentOAuth2Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOAuth2ParamsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/oauth2/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getLoginProcessingUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginProcessingUrlUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/oauth2/loginProcessingUrl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getOAuth2Clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuth2ClientsUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/api/noauth/oauth2Clients`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveOAuth2Params
         * @param {OAuth2ClientsParams} oauth2Params oauth2Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOAuth2ParamsUsingPOST(oauth2Params: OAuth2ClientsParams, options: any = {}): FetchArgs {
            // verify required parameter 'oauth2Params' is not null or undefined
            if (oauth2Params === null || oauth2Params === undefined) {
                throw new RequiredError('oauth2Params','Required parameter oauth2Params was null or undefined when calling saveOAuth2ParamsUsingPOST.');
            }
            const localVarPath = `/api/oauth2/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OAuth2ClientsParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(oauth2Params || {}) : (oauth2Params || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2ControllerApi - functional programming interface
 * @export
 */
export const OAuth2ControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCurrentOAuth2Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOAuth2ParamsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OAuth2ClientsParams> {
            const localVarFetchArgs = OAuth2ControllerApiFetchParamCreator(configuration).getCurrentOAuth2ParamsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getLoginProcessingUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginProcessingUrlUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = OAuth2ControllerApiFetchParamCreator(configuration).getLoginProcessingUrlUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getOAuth2Clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuth2ClientsUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OAuth2ClientInfo>> {
            const localVarFetchArgs = OAuth2ControllerApiFetchParamCreator(configuration).getOAuth2ClientsUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveOAuth2Params
         * @param {OAuth2ClientsParams} oauth2Params oauth2Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOAuth2ParamsUsingPOST(oauth2Params: OAuth2ClientsParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OAuth2ClientsParams> {
            const localVarFetchArgs = OAuth2ControllerApiFetchParamCreator(configuration).saveOAuth2ParamsUsingPOST(oauth2Params, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OAuth2ControllerApi - factory interface
 * @export
 */
export const OAuth2ControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getCurrentOAuth2Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOAuth2ParamsUsingGET(options?: any) {
            return OAuth2ControllerApiFp(configuration).getCurrentOAuth2ParamsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getLoginProcessingUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginProcessingUrlUsingGET(options?: any) {
            return OAuth2ControllerApiFp(configuration).getLoginProcessingUrlUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getOAuth2Clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuth2ClientsUsingPOST(options?: any) {
            return OAuth2ControllerApiFp(configuration).getOAuth2ClientsUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveOAuth2Params
         * @param {OAuth2ClientsParams} oauth2Params oauth2Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOAuth2ParamsUsingPOST(oauth2Params: OAuth2ClientsParams, options?: any) {
            return OAuth2ControllerApiFp(configuration).saveOAuth2ParamsUsingPOST(oauth2Params, options)(fetch, basePath);
        },
    };
};

/**
 * OAuth2ControllerApi - object-oriented interface
 * @export
 * @class OAuth2ControllerApi
 * @extends {BaseAPI}
 */
export class OAuth2ControllerApi extends BaseAPI {
    /**
     * 
     * @summary getCurrentOAuth2Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ControllerApi
     */
    public getCurrentOAuth2ParamsUsingGET(options?: any) {
        return OAuth2ControllerApiFp(this.configuration).getCurrentOAuth2ParamsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getLoginProcessingUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ControllerApi
     */
    public getLoginProcessingUrlUsingGET(options?: any) {
        return OAuth2ControllerApiFp(this.configuration).getLoginProcessingUrlUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getOAuth2Clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ControllerApi
     */
    public getOAuth2ClientsUsingPOST(options?: any) {
        return OAuth2ControllerApiFp(this.configuration).getOAuth2ClientsUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveOAuth2Params
     * @param {OAuth2ClientsParams} oauth2Params oauth2Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ControllerApi
     */
    public saveOAuth2ParamsUsingPOST(oauth2Params: OAuth2ClientsParams, options?: any) {
        return OAuth2ControllerApiFp(this.configuration).saveOAuth2ParamsUsingPOST(oauth2Params, options)(this.fetch, this.basePath);
    }

}

/**
 * OceanConnectIntegrationControllerApi - fetch parameter creator
 * @export
 */
export const OceanConnectIntegrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE2(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingDELETE2.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingDELETE2.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingDELETE2.');
            }
            const localVarPath = `/api/v1/integrations/oceanconnect/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET2(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingGET2.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingGET2.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingGET2.');
            }
            const localVarPath = `/api/v1/integrations/oceanconnect/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD2(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingHEAD2.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingHEAD2.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingHEAD2.');
            }
            const localVarPath = `/api/v1/integrations/oceanconnect/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS2(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingOPTIONS2.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingOPTIONS2.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingOPTIONS2.');
            }
            const localVarPath = `/api/v1/integrations/oceanconnect/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH2(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPATCH2.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPATCH2.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPATCH2.');
            }
            const localVarPath = `/api/v1/integrations/oceanconnect/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST8(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPOST8.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPOST8.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPOST8.');
            }
            const localVarPath = `/api/v1/integrations/oceanconnect/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT2(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPUT2.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPUT2.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPUT2.');
            }
            const localVarPath = `/api/v1/integrations/oceanconnect/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OceanConnectIntegrationControllerApi - functional programming interface
 * @export
 */
export const OceanConnectIntegrationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE2(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = OceanConnectIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingDELETE2(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET2(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = OceanConnectIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingGET2(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD2(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = OceanConnectIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingHEAD2(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS2(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = OceanConnectIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingOPTIONS2(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH2(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = OceanConnectIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPATCH2(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST8(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = OceanConnectIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPOST8(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT2(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = OceanConnectIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPUT2(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OceanConnectIntegrationControllerApi - factory interface
 * @export
 */
export const OceanConnectIntegrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return OceanConnectIntegrationControllerApiFp(configuration).processRequestUsingDELETE2(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return OceanConnectIntegrationControllerApiFp(configuration).processRequestUsingGET2(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return OceanConnectIntegrationControllerApiFp(configuration).processRequestUsingHEAD2(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return OceanConnectIntegrationControllerApiFp(configuration).processRequestUsingOPTIONS2(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return OceanConnectIntegrationControllerApiFp(configuration).processRequestUsingPATCH2(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST8(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return OceanConnectIntegrationControllerApiFp(configuration).processRequestUsingPOST8(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return OceanConnectIntegrationControllerApiFp(configuration).processRequestUsingPUT2(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
    };
};

/**
 * OceanConnectIntegrationControllerApi - object-oriented interface
 * @export
 * @class OceanConnectIntegrationControllerApi
 * @extends {BaseAPI}
 */
export class OceanConnectIntegrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OceanConnectIntegrationControllerApi
     */
    public processRequestUsingDELETE2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return OceanConnectIntegrationControllerApiFp(this.configuration).processRequestUsingDELETE2(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OceanConnectIntegrationControllerApi
     */
    public processRequestUsingGET2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return OceanConnectIntegrationControllerApiFp(this.configuration).processRequestUsingGET2(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OceanConnectIntegrationControllerApi
     */
    public processRequestUsingHEAD2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return OceanConnectIntegrationControllerApiFp(this.configuration).processRequestUsingHEAD2(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OceanConnectIntegrationControllerApi
     */
    public processRequestUsingOPTIONS2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return OceanConnectIntegrationControllerApiFp(this.configuration).processRequestUsingOPTIONS2(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OceanConnectIntegrationControllerApi
     */
    public processRequestUsingPATCH2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return OceanConnectIntegrationControllerApiFp(this.configuration).processRequestUsingPATCH2(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OceanConnectIntegrationControllerApi
     */
    public processRequestUsingPOST8(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return OceanConnectIntegrationControllerApiFp(this.configuration).processRequestUsingPOST8(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OceanConnectIntegrationControllerApi
     */
    public processRequestUsingPUT2(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return OceanConnectIntegrationControllerApiFp(this.configuration).processRequestUsingPUT2(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

}

/**
 * OwnerControllerApi - fetch parameter creator
 * @export
 */
export const OwnerControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary changeOwnerToCustomer
         * @param {string} ownerId ownerId
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnerToCustomerUsingPOST(ownerId: string, entityType: string, entityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'ownerId' is not null or undefined
            if (ownerId === null || ownerId === undefined) {
                throw new RequiredError('ownerId','Required parameter ownerId was null or undefined when calling changeOwnerToCustomerUsingPOST.');
            }
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling changeOwnerToCustomerUsingPOST.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling changeOwnerToCustomerUsingPOST.');
            }
            const localVarPath = `/api/owner/CUSTOMER/{ownerId}/{entityType}/{entityId}`
                .replace(`{${"ownerId"}}`, encodeURIComponent(String(ownerId)))
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary changeOwnerToTenant
         * @param {string} ownerId ownerId
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnerToTenantUsingPOST(ownerId: string, entityType: string, entityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'ownerId' is not null or undefined
            if (ownerId === null || ownerId === undefined) {
                throw new RequiredError('ownerId','Required parameter ownerId was null or undefined when calling changeOwnerToTenantUsingPOST.');
            }
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling changeOwnerToTenantUsingPOST.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling changeOwnerToTenantUsingPOST.');
            }
            const localVarPath = `/api/owner/TENANT/{ownerId}/{entityType}/{entityId}`
                .replace(`{${"ownerId"}}`, encodeURIComponent(String(ownerId)))
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OwnerControllerApi - functional programming interface
 * @export
 */
export const OwnerControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary changeOwnerToCustomer
         * @param {string} ownerId ownerId
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnerToCustomerUsingPOST(ownerId: string, entityType: string, entityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OwnerControllerApiFetchParamCreator(configuration).changeOwnerToCustomerUsingPOST(ownerId, entityType, entityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary changeOwnerToTenant
         * @param {string} ownerId ownerId
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnerToTenantUsingPOST(ownerId: string, entityType: string, entityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OwnerControllerApiFetchParamCreator(configuration).changeOwnerToTenantUsingPOST(ownerId, entityType, entityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OwnerControllerApi - factory interface
 * @export
 */
export const OwnerControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary changeOwnerToCustomer
         * @param {string} ownerId ownerId
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnerToCustomerUsingPOST(ownerId: string, entityType: string, entityId: string, options?: any) {
            return OwnerControllerApiFp(configuration).changeOwnerToCustomerUsingPOST(ownerId, entityType, entityId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary changeOwnerToTenant
         * @param {string} ownerId ownerId
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOwnerToTenantUsingPOST(ownerId: string, entityType: string, entityId: string, options?: any) {
            return OwnerControllerApiFp(configuration).changeOwnerToTenantUsingPOST(ownerId, entityType, entityId, options)(fetch, basePath);
        },
    };
};

/**
 * OwnerControllerApi - object-oriented interface
 * @export
 * @class OwnerControllerApi
 * @extends {BaseAPI}
 */
export class OwnerControllerApi extends BaseAPI {
    /**
     * 
     * @summary changeOwnerToCustomer
     * @param {string} ownerId ownerId
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OwnerControllerApi
     */
    public changeOwnerToCustomerUsingPOST(ownerId: string, entityType: string, entityId: string, options?: any) {
        return OwnerControllerApiFp(this.configuration).changeOwnerToCustomerUsingPOST(ownerId, entityType, entityId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary changeOwnerToTenant
     * @param {string} ownerId ownerId
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OwnerControllerApi
     */
    public changeOwnerToTenantUsingPOST(ownerId: string, entityType: string, entityId: string, options?: any) {
        return OwnerControllerApiFp(this.configuration).changeOwnerToTenantUsingPOST(ownerId, entityType, entityId, options)(this.fetch, this.basePath);
    }

}

/**
 * QueueControllerApi - fetch parameter creator
 * @export
 */
export const QueueControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getTenantQueuesByServiceType
         * @param {string} serviceType serviceType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantQueuesByServiceTypeUsingGET(serviceType: string, options: any = {}): FetchArgs {
            // verify required parameter 'serviceType' is not null or undefined
            if (serviceType === null || serviceType === undefined) {
                throw new RequiredError('serviceType','Required parameter serviceType was null or undefined when calling getTenantQueuesByServiceTypeUsingGET.');
            }
            const localVarPath = `/api/tenant/queues{?serviceType}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (serviceType !== undefined) {
                localVarQueryParameter['serviceType'] = serviceType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueueControllerApi - functional programming interface
 * @export
 */
export const QueueControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getTenantQueuesByServiceType
         * @param {string} serviceType serviceType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantQueuesByServiceTypeUsingGET(serviceType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = QueueControllerApiFetchParamCreator(configuration).getTenantQueuesByServiceTypeUsingGET(serviceType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueueControllerApi - factory interface
 * @export
 */
export const QueueControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getTenantQueuesByServiceType
         * @param {string} serviceType serviceType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantQueuesByServiceTypeUsingGET(serviceType: string, options?: any) {
            return QueueControllerApiFp(configuration).getTenantQueuesByServiceTypeUsingGET(serviceType, options)(fetch, basePath);
        },
    };
};

/**
 * QueueControllerApi - object-oriented interface
 * @export
 * @class QueueControllerApi
 * @extends {BaseAPI}
 */
export class QueueControllerApi extends BaseAPI {
    /**
     * 
     * @summary getTenantQueuesByServiceType
     * @param {string} serviceType serviceType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueControllerApi
     */
    public getTenantQueuesByServiceTypeUsingGET(serviceType: string, options?: any) {
        return QueueControllerApiFp(this.configuration).getTenantQueuesByServiceTypeUsingGET(serviceType, options)(this.fetch, this.basePath);
    }

}

/**
 * ReportControllerApi - fetch parameter creator
 * @export
 */
export const ReportControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary downloadDashboardReport
         * @param {string} dashboardId dashboardId
         * @param {string} reportParams reportParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDashboardReportUsingPOST(dashboardId: string, reportParams: string, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId','Required parameter dashboardId was null or undefined when calling downloadDashboardReportUsingPOST.');
            }
            // verify required parameter 'reportParams' is not null or undefined
            if (reportParams === null || reportParams === undefined) {
                throw new RequiredError('reportParams','Required parameter reportParams was null or undefined when calling downloadDashboardReportUsingPOST.');
            }
            const localVarPath = `/api/report/{dashboardId}/download`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(reportParams || {}) : (reportParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary downloadTestReport
         * @param {ReportConfig} reportConfig reportConfig
         * @param {string} [reportsServerEndpointUrl] reportsServerEndpointUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTestReportUsingPOST(reportConfig: ReportConfig, reportsServerEndpointUrl?: string, options: any = {}): FetchArgs {
            // verify required parameter 'reportConfig' is not null or undefined
            if (reportConfig === null || reportConfig === undefined) {
                throw new RequiredError('reportConfig','Required parameter reportConfig was null or undefined when calling downloadTestReportUsingPOST.');
            }
            const localVarPath = `/api/report/test{?reportsServerEndpointUrl}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (reportsServerEndpointUrl !== undefined) {
                localVarQueryParameter['reportsServerEndpointUrl'] = reportsServerEndpointUrl;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReportConfig" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(reportConfig || {}) : (reportConfig || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportControllerApi - functional programming interface
 * @export
 */
export const ReportControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary downloadDashboardReport
         * @param {string} dashboardId dashboardId
         * @param {string} reportParams reportParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDashboardReportUsingPOST(dashboardId: string, reportParams: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ReportControllerApiFetchParamCreator(configuration).downloadDashboardReportUsingPOST(dashboardId, reportParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary downloadTestReport
         * @param {ReportConfig} reportConfig reportConfig
         * @param {string} [reportsServerEndpointUrl] reportsServerEndpointUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTestReportUsingPOST(reportConfig: ReportConfig, reportsServerEndpointUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ReportControllerApiFetchParamCreator(configuration).downloadTestReportUsingPOST(reportConfig, reportsServerEndpointUrl, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ReportControllerApi - factory interface
 * @export
 */
export const ReportControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary downloadDashboardReport
         * @param {string} dashboardId dashboardId
         * @param {string} reportParams reportParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDashboardReportUsingPOST(dashboardId: string, reportParams: string, options?: any) {
            return ReportControllerApiFp(configuration).downloadDashboardReportUsingPOST(dashboardId, reportParams, options)(fetch, basePath);
        },
        /**
         * 
         * @summary downloadTestReport
         * @param {ReportConfig} reportConfig reportConfig
         * @param {string} [reportsServerEndpointUrl] reportsServerEndpointUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTestReportUsingPOST(reportConfig: ReportConfig, reportsServerEndpointUrl?: string, options?: any) {
            return ReportControllerApiFp(configuration).downloadTestReportUsingPOST(reportConfig, reportsServerEndpointUrl, options)(fetch, basePath);
        },
    };
};

/**
 * ReportControllerApi - object-oriented interface
 * @export
 * @class ReportControllerApi
 * @extends {BaseAPI}
 */
export class ReportControllerApi extends BaseAPI {
    /**
     * 
     * @summary downloadDashboardReport
     * @param {string} dashboardId dashboardId
     * @param {string} reportParams reportParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportControllerApi
     */
    public downloadDashboardReportUsingPOST(dashboardId: string, reportParams: string, options?: any) {
        return ReportControllerApiFp(this.configuration).downloadDashboardReportUsingPOST(dashboardId, reportParams, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary downloadTestReport
     * @param {ReportConfig} reportConfig reportConfig
     * @param {string} [reportsServerEndpointUrl] reportsServerEndpointUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportControllerApi
     */
    public downloadTestReportUsingPOST(reportConfig: ReportConfig, reportsServerEndpointUrl?: string, options?: any) {
        return ReportControllerApiFp(this.configuration).downloadTestReportUsingPOST(reportConfig, reportsServerEndpointUrl, options)(this.fetch, this.basePath);
    }

}

/**
 * RoleControllerApi - fetch parameter creator
 * @export
 */
export const RoleControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRole
         * @param {string} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleUsingDELETE(roleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling deleteRoleUsingDELETE.');
            }
            const localVarPath = `/api/role/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRoleById
         * @param {string} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleByIdUsingGET(roleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling getRoleByIdUsingGET.');
            }
            const localVarPath = `/api/role/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRolesByIds
         * @param {string} roleIds roleIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByIdsUsingGET(roleIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'roleIds' is not null or undefined
            if (roleIds === null || roleIds === undefined) {
                throw new RequiredError('roleIds','Required parameter roleIds was null or undefined when calling getRolesByIdsUsingGET.');
            }
            const localVarPath = `/api/roles{?roleIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (roleIds !== undefined) {
                localVarQueryParameter['roleIds'] = roleIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRoles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getRolesUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getRolesUsingGET.');
            }
            const localVarPath = `/api/roles{?type,textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveRole
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoleUsingPOST(role: Role, options: any = {}): FetchArgs {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling saveRoleUsingPOST.');
            }
            const localVarPath = `/api/role`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Role" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(role || {}) : (role || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleControllerApi - functional programming interface
 * @export
 */
export const RoleControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRole
         * @param {string} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleUsingDELETE(roleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RoleControllerApiFetchParamCreator(configuration).deleteRoleUsingDELETE(roleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRoleById
         * @param {string} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleByIdUsingGET(roleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
            const localVarFetchArgs = RoleControllerApiFetchParamCreator(configuration).getRoleByIdUsingGET(roleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRolesByIds
         * @param {string} roleIds roleIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByIdsUsingGET(roleIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Role>> {
            const localVarFetchArgs = RoleControllerApiFetchParamCreator(configuration).getRolesByIdsUsingGET(roleIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRoles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataRole> {
            const localVarFetchArgs = RoleControllerApiFetchParamCreator(configuration).getRolesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveRole
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoleUsingPOST(role: Role, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
            const localVarFetchArgs = RoleControllerApiFetchParamCreator(configuration).saveRoleUsingPOST(role, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RoleControllerApi - factory interface
 * @export
 */
export const RoleControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteRole
         * @param {string} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleUsingDELETE(roleId: string, options?: any) {
            return RoleControllerApiFp(configuration).deleteRoleUsingDELETE(roleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRoleById
         * @param {string} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleByIdUsingGET(roleId: string, options?: any) {
            return RoleControllerApiFp(configuration).getRoleByIdUsingGET(roleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRolesByIds
         * @param {string} roleIds roleIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByIdsUsingGET(roleIds: string, options?: any) {
            return RoleControllerApiFp(configuration).getRolesByIdsUsingGET(roleIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRoles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [type] type
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return RoleControllerApiFp(configuration).getRolesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveRole
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoleUsingPOST(role: Role, options?: any) {
            return RoleControllerApiFp(configuration).saveRoleUsingPOST(role, options)(fetch, basePath);
        },
    };
};

/**
 * RoleControllerApi - object-oriented interface
 * @export
 * @class RoleControllerApi
 * @extends {BaseAPI}
 */
export class RoleControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteRole
     * @param {string} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public deleteRoleUsingDELETE(roleId: string, options?: any) {
        return RoleControllerApiFp(this.configuration).deleteRoleUsingDELETE(roleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRoleById
     * @param {string} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public getRoleByIdUsingGET(roleId: string, options?: any) {
        return RoleControllerApiFp(this.configuration).getRoleByIdUsingGET(roleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRolesByIds
     * @param {string} roleIds roleIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public getRolesByIdsUsingGET(roleIds: string, options?: any) {
        return RoleControllerApiFp(this.configuration).getRolesByIdsUsingGET(roleIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRoles
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [type] type
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public getRolesUsingGET(pageSize: string, page: string, type?: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return RoleControllerApiFp(this.configuration).getRolesUsingGET(pageSize, page, type, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveRole
     * @param {Role} role role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public saveRoleUsingPOST(role: Role, options?: any) {
        return RoleControllerApiFp(this.configuration).saveRoleUsingPOST(role, options)(this.fetch, this.basePath);
    }

}

/**
 * RpcControllerApi - fetch parameter creator
 * @export
 */
export const RpcControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handleOneWayDeviceRPCRequest
         * @param {string} deviceId deviceId
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleOneWayDeviceRPCRequestUsingPOST(deviceId: string, requestBody: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling handleOneWayDeviceRPCRequestUsingPOST.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling handleOneWayDeviceRPCRequestUsingPOST.');
            }
            const localVarPath = `/api/plugins/rpc/oneway/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handleTwoWayDeviceRPCRequest
         * @param {string} deviceId deviceId
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleTwoWayDeviceRPCRequestUsingPOST(deviceId: string, requestBody: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling handleTwoWayDeviceRPCRequestUsingPOST.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling handleTwoWayDeviceRPCRequestUsingPOST.');
            }
            const localVarPath = `/api/plugins/rpc/twoway/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcControllerApi - functional programming interface
 * @export
 */
export const RpcControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handleOneWayDeviceRPCRequest
         * @param {string} deviceId deviceId
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleOneWayDeviceRPCRequestUsingPOST(deviceId: string, requestBody: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = RpcControllerApiFetchParamCreator(configuration).handleOneWayDeviceRPCRequestUsingPOST(deviceId, requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handleTwoWayDeviceRPCRequest
         * @param {string} deviceId deviceId
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleTwoWayDeviceRPCRequestUsingPOST(deviceId: string, requestBody: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = RpcControllerApiFetchParamCreator(configuration).handleTwoWayDeviceRPCRequestUsingPOST(deviceId, requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RpcControllerApi - factory interface
 * @export
 */
export const RpcControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary handleOneWayDeviceRPCRequest
         * @param {string} deviceId deviceId
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleOneWayDeviceRPCRequestUsingPOST(deviceId: string, requestBody: string, options?: any) {
            return RpcControllerApiFp(configuration).handleOneWayDeviceRPCRequestUsingPOST(deviceId, requestBody, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handleTwoWayDeviceRPCRequest
         * @param {string} deviceId deviceId
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleTwoWayDeviceRPCRequestUsingPOST(deviceId: string, requestBody: string, options?: any) {
            return RpcControllerApiFp(configuration).handleTwoWayDeviceRPCRequestUsingPOST(deviceId, requestBody, options)(fetch, basePath);
        },
    };
};

/**
 * RpcControllerApi - object-oriented interface
 * @export
 * @class RpcControllerApi
 * @extends {BaseAPI}
 */
export class RpcControllerApi extends BaseAPI {
    /**
     * 
     * @summary handleOneWayDeviceRPCRequest
     * @param {string} deviceId deviceId
     * @param {string} requestBody requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcControllerApi
     */
    public handleOneWayDeviceRPCRequestUsingPOST(deviceId: string, requestBody: string, options?: any) {
        return RpcControllerApiFp(this.configuration).handleOneWayDeviceRPCRequestUsingPOST(deviceId, requestBody, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handleTwoWayDeviceRPCRequest
     * @param {string} deviceId deviceId
     * @param {string} requestBody requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcControllerApi
     */
    public handleTwoWayDeviceRPCRequestUsingPOST(deviceId: string, requestBody: string, options?: any) {
        return RpcControllerApiFp(this.configuration).handleTwoWayDeviceRPCRequestUsingPOST(deviceId, requestBody, options)(this.fetch, this.basePath);
    }

}

/**
 * RuleChainControllerApi - fetch parameter creator
 * @export
 */
export const RuleChainControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRuleChain
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleChainUsingDELETE(ruleChainId: string, options: any = {}): FetchArgs {
            // verify required parameter 'ruleChainId' is not null or undefined
            if (ruleChainId === null || ruleChainId === undefined) {
                throw new RequiredError('ruleChainId','Required parameter ruleChainId was null or undefined when calling deleteRuleChainUsingDELETE.');
            }
            const localVarPath = `/api/ruleChain/{ruleChainId}`
                .replace(`{${"ruleChainId"}}`, encodeURIComponent(String(ruleChainId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary exportRuleChains
         * @param {string} limit limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRuleChainsUsingGET(limit: string, options: any = {}): FetchArgs {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling exportRuleChainsUsingGET.');
            }
            const localVarPath = `/api/ruleChains/export{?limit}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getLatestRuleNodeDebugInput
         * @param {string} ruleNodeId ruleNodeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestRuleNodeDebugInputUsingGET(ruleNodeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'ruleNodeId' is not null or undefined
            if (ruleNodeId === null || ruleNodeId === undefined) {
                throw new RequiredError('ruleNodeId','Required parameter ruleNodeId was null or undefined when calling getLatestRuleNodeDebugInputUsingGET.');
            }
            const localVarPath = `/api/ruleNode/{ruleNodeId}/debugIn`
                .replace(`{${"ruleNodeId"}}`, encodeURIComponent(String(ruleNodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRuleChainById
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleChainByIdUsingGET(ruleChainId: string, options: any = {}): FetchArgs {
            // verify required parameter 'ruleChainId' is not null or undefined
            if (ruleChainId === null || ruleChainId === undefined) {
                throw new RequiredError('ruleChainId','Required parameter ruleChainId was null or undefined when calling getRuleChainByIdUsingGET.');
            }
            const localVarPath = `/api/ruleChain/{ruleChainId}`
                .replace(`{${"ruleChainId"}}`, encodeURIComponent(String(ruleChainId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRuleChainMetaData
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleChainMetaDataUsingGET(ruleChainId: string, options: any = {}): FetchArgs {
            // verify required parameter 'ruleChainId' is not null or undefined
            if (ruleChainId === null || ruleChainId === undefined) {
                throw new RequiredError('ruleChainId','Required parameter ruleChainId was null or undefined when calling getRuleChainMetaDataUsingGET.');
            }
            const localVarPath = `/api/ruleChain/{ruleChainId}/metadata`
                .replace(`{${"ruleChainId"}}`, encodeURIComponent(String(ruleChainId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRuleChains
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleChainsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getRuleChainsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getRuleChainsUsingGET.');
            }
            const localVarPath = `/api/ruleChains{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary importRuleChains
         * @param {RuleChainData} ruleChainData ruleChainData
         * @param {boolean} [overwrite] overwrite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importRuleChainsUsingPOST(ruleChainData: RuleChainData, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'ruleChainData' is not null or undefined
            if (ruleChainData === null || ruleChainData === undefined) {
                throw new RequiredError('ruleChainData','Required parameter ruleChainData was null or undefined when calling importRuleChainsUsingPOST.');
            }
            const localVarPath = `/api/ruleChains/import{?overwrite}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RuleChainData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(ruleChainData || {}) : (ruleChainData || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveRuleChainMetaData
         * @param {RuleChainMetaData} ruleChainMetaData ruleChainMetaData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRuleChainMetaDataUsingPOST(ruleChainMetaData: RuleChainMetaData, options: any = {}): FetchArgs {
            // verify required parameter 'ruleChainMetaData' is not null or undefined
            if (ruleChainMetaData === null || ruleChainMetaData === undefined) {
                throw new RequiredError('ruleChainMetaData','Required parameter ruleChainMetaData was null or undefined when calling saveRuleChainMetaDataUsingPOST.');
            }
            const localVarPath = `/api/ruleChain/metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RuleChainMetaData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(ruleChainMetaData || {}) : (ruleChainMetaData || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveRuleChain
         * @param {DefaultRuleChainCreateRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRuleChainUsingPOST(request: DefaultRuleChainCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling saveRuleChainUsingPOST.');
            }
            const localVarPath = `/api/ruleChain/device/default`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefaultRuleChainCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveRuleChain
         * @param {RuleChain} ruleChain ruleChain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRuleChainUsingPOST1(ruleChain: RuleChain, options: any = {}): FetchArgs {
            // verify required parameter 'ruleChain' is not null or undefined
            if (ruleChain === null || ruleChain === undefined) {
                throw new RequiredError('ruleChain','Required parameter ruleChain was null or undefined when calling saveRuleChainUsingPOST1.');
            }
            const localVarPath = `/api/ruleChain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RuleChain" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(ruleChain || {}) : (ruleChain || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setRootRuleChain
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRootRuleChainUsingPOST(ruleChainId: string, options: any = {}): FetchArgs {
            // verify required parameter 'ruleChainId' is not null or undefined
            if (ruleChainId === null || ruleChainId === undefined) {
                throw new RequiredError('ruleChainId','Required parameter ruleChainId was null or undefined when calling setRootRuleChainUsingPOST.');
            }
            const localVarPath = `/api/ruleChain/{ruleChainId}/root`
                .replace(`{${"ruleChainId"}}`, encodeURIComponent(String(ruleChainId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary testScript
         * @param {string} inputParams inputParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testScriptUsingPOST(inputParams: string, options: any = {}): FetchArgs {
            // verify required parameter 'inputParams' is not null or undefined
            if (inputParams === null || inputParams === undefined) {
                throw new RequiredError('inputParams','Required parameter inputParams was null or undefined when calling testScriptUsingPOST.');
            }
            const localVarPath = `/api/ruleChain/testScript`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inputParams || {}) : (inputParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleChainControllerApi - functional programming interface
 * @export
 */
export const RuleChainControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRuleChain
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleChainUsingDELETE(ruleChainId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).deleteRuleChainUsingDELETE(ruleChainId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary exportRuleChains
         * @param {string} limit limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRuleChainsUsingGET(limit: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RuleChainData> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).exportRuleChainsUsingGET(limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getLatestRuleNodeDebugInput
         * @param {string} ruleNodeId ruleNodeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestRuleNodeDebugInputUsingGET(ruleNodeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).getLatestRuleNodeDebugInputUsingGET(ruleNodeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRuleChainById
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleChainByIdUsingGET(ruleChainId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RuleChain> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).getRuleChainByIdUsingGET(ruleChainId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRuleChainMetaData
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleChainMetaDataUsingGET(ruleChainId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RuleChainMetaData> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).getRuleChainMetaDataUsingGET(ruleChainId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRuleChains
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleChainsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataRuleChain> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).getRuleChainsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary importRuleChains
         * @param {RuleChainData} ruleChainData ruleChainData
         * @param {boolean} [overwrite] overwrite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importRuleChainsUsingPOST(ruleChainData: RuleChainData, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).importRuleChainsUsingPOST(ruleChainData, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveRuleChainMetaData
         * @param {RuleChainMetaData} ruleChainMetaData ruleChainMetaData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRuleChainMetaDataUsingPOST(ruleChainMetaData: RuleChainMetaData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RuleChainMetaData> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).saveRuleChainMetaDataUsingPOST(ruleChainMetaData, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveRuleChain
         * @param {DefaultRuleChainCreateRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRuleChainUsingPOST(request: DefaultRuleChainCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RuleChain> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).saveRuleChainUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveRuleChain
         * @param {RuleChain} ruleChain ruleChain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRuleChainUsingPOST1(ruleChain: RuleChain, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RuleChain> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).saveRuleChainUsingPOST1(ruleChain, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary setRootRuleChain
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRootRuleChainUsingPOST(ruleChainId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RuleChain> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).setRootRuleChainUsingPOST(ruleChainId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary testScript
         * @param {string} inputParams inputParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testScriptUsingPOST(inputParams: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RuleChainControllerApiFetchParamCreator(configuration).testScriptUsingPOST(inputParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RuleChainControllerApi - factory interface
 * @export
 */
export const RuleChainControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteRuleChain
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleChainUsingDELETE(ruleChainId: string, options?: any) {
            return RuleChainControllerApiFp(configuration).deleteRuleChainUsingDELETE(ruleChainId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary exportRuleChains
         * @param {string} limit limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRuleChainsUsingGET(limit: string, options?: any) {
            return RuleChainControllerApiFp(configuration).exportRuleChainsUsingGET(limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getLatestRuleNodeDebugInput
         * @param {string} ruleNodeId ruleNodeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestRuleNodeDebugInputUsingGET(ruleNodeId: string, options?: any) {
            return RuleChainControllerApiFp(configuration).getLatestRuleNodeDebugInputUsingGET(ruleNodeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRuleChainById
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleChainByIdUsingGET(ruleChainId: string, options?: any) {
            return RuleChainControllerApiFp(configuration).getRuleChainByIdUsingGET(ruleChainId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRuleChainMetaData
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleChainMetaDataUsingGET(ruleChainId: string, options?: any) {
            return RuleChainControllerApiFp(configuration).getRuleChainMetaDataUsingGET(ruleChainId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRuleChains
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleChainsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return RuleChainControllerApiFp(configuration).getRuleChainsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary importRuleChains
         * @param {RuleChainData} ruleChainData ruleChainData
         * @param {boolean} [overwrite] overwrite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importRuleChainsUsingPOST(ruleChainData: RuleChainData, overwrite?: boolean, options?: any) {
            return RuleChainControllerApiFp(configuration).importRuleChainsUsingPOST(ruleChainData, overwrite, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveRuleChainMetaData
         * @param {RuleChainMetaData} ruleChainMetaData ruleChainMetaData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRuleChainMetaDataUsingPOST(ruleChainMetaData: RuleChainMetaData, options?: any) {
            return RuleChainControllerApiFp(configuration).saveRuleChainMetaDataUsingPOST(ruleChainMetaData, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveRuleChain
         * @param {DefaultRuleChainCreateRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRuleChainUsingPOST(request: DefaultRuleChainCreateRequest, options?: any) {
            return RuleChainControllerApiFp(configuration).saveRuleChainUsingPOST(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveRuleChain
         * @param {RuleChain} ruleChain ruleChain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRuleChainUsingPOST1(ruleChain: RuleChain, options?: any) {
            return RuleChainControllerApiFp(configuration).saveRuleChainUsingPOST1(ruleChain, options)(fetch, basePath);
        },
        /**
         * 
         * @summary setRootRuleChain
         * @param {string} ruleChainId ruleChainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRootRuleChainUsingPOST(ruleChainId: string, options?: any) {
            return RuleChainControllerApiFp(configuration).setRootRuleChainUsingPOST(ruleChainId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary testScript
         * @param {string} inputParams inputParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testScriptUsingPOST(inputParams: string, options?: any) {
            return RuleChainControllerApiFp(configuration).testScriptUsingPOST(inputParams, options)(fetch, basePath);
        },
    };
};

/**
 * RuleChainControllerApi - object-oriented interface
 * @export
 * @class RuleChainControllerApi
 * @extends {BaseAPI}
 */
export class RuleChainControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteRuleChain
     * @param {string} ruleChainId ruleChainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public deleteRuleChainUsingDELETE(ruleChainId: string, options?: any) {
        return RuleChainControllerApiFp(this.configuration).deleteRuleChainUsingDELETE(ruleChainId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary exportRuleChains
     * @param {string} limit limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public exportRuleChainsUsingGET(limit: string, options?: any) {
        return RuleChainControllerApiFp(this.configuration).exportRuleChainsUsingGET(limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getLatestRuleNodeDebugInput
     * @param {string} ruleNodeId ruleNodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public getLatestRuleNodeDebugInputUsingGET(ruleNodeId: string, options?: any) {
        return RuleChainControllerApiFp(this.configuration).getLatestRuleNodeDebugInputUsingGET(ruleNodeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRuleChainById
     * @param {string} ruleChainId ruleChainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public getRuleChainByIdUsingGET(ruleChainId: string, options?: any) {
        return RuleChainControllerApiFp(this.configuration).getRuleChainByIdUsingGET(ruleChainId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRuleChainMetaData
     * @param {string} ruleChainId ruleChainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public getRuleChainMetaDataUsingGET(ruleChainId: string, options?: any) {
        return RuleChainControllerApiFp(this.configuration).getRuleChainMetaDataUsingGET(ruleChainId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRuleChains
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public getRuleChainsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return RuleChainControllerApiFp(this.configuration).getRuleChainsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary importRuleChains
     * @param {RuleChainData} ruleChainData ruleChainData
     * @param {boolean} [overwrite] overwrite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public importRuleChainsUsingPOST(ruleChainData: RuleChainData, overwrite?: boolean, options?: any) {
        return RuleChainControllerApiFp(this.configuration).importRuleChainsUsingPOST(ruleChainData, overwrite, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveRuleChainMetaData
     * @param {RuleChainMetaData} ruleChainMetaData ruleChainMetaData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public saveRuleChainMetaDataUsingPOST(ruleChainMetaData: RuleChainMetaData, options?: any) {
        return RuleChainControllerApiFp(this.configuration).saveRuleChainMetaDataUsingPOST(ruleChainMetaData, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveRuleChain
     * @param {DefaultRuleChainCreateRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public saveRuleChainUsingPOST(request: DefaultRuleChainCreateRequest, options?: any) {
        return RuleChainControllerApiFp(this.configuration).saveRuleChainUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveRuleChain
     * @param {RuleChain} ruleChain ruleChain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public saveRuleChainUsingPOST1(ruleChain: RuleChain, options?: any) {
        return RuleChainControllerApiFp(this.configuration).saveRuleChainUsingPOST1(ruleChain, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary setRootRuleChain
     * @param {string} ruleChainId ruleChainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public setRootRuleChainUsingPOST(ruleChainId: string, options?: any) {
        return RuleChainControllerApiFp(this.configuration).setRootRuleChainUsingPOST(ruleChainId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary testScript
     * @param {string} inputParams inputParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleChainControllerApi
     */
    public testScriptUsingPOST(inputParams: string, options?: any) {
        return RuleChainControllerApiFp(this.configuration).testScriptUsingPOST(inputParams, options)(this.fetch, this.basePath);
    }

}

/**
 * RuleEngineControllerApi - fetch parameter creator
 * @export
 */
export const RuleEngineControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handleRuleEngineRequest
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRuleEngineRequestUsingPOST(requestBody: string, options: any = {}): FetchArgs {
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling handleRuleEngineRequestUsingPOST.');
            }
            const localVarPath = `/api/rule-engine/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handleRuleEngineRequest
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {number} timeout timeout
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRuleEngineRequestUsingPOST1(entityType: string, entityId: string, timeout: number, requestBody: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling handleRuleEngineRequestUsingPOST1.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling handleRuleEngineRequestUsingPOST1.');
            }
            // verify required parameter 'timeout' is not null or undefined
            if (timeout === null || timeout === undefined) {
                throw new RequiredError('timeout','Required parameter timeout was null or undefined when calling handleRuleEngineRequestUsingPOST1.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling handleRuleEngineRequestUsingPOST1.');
            }
            const localVarPath = `/api/rule-engine/{entityType}/{entityId}/{timeout}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"timeout"}}`, encodeURIComponent(String(timeout)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handleRuleEngineRequest
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRuleEngineRequestUsingPOST2(entityType: string, entityId: string, requestBody: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling handleRuleEngineRequestUsingPOST2.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling handleRuleEngineRequestUsingPOST2.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling handleRuleEngineRequestUsingPOST2.');
            }
            const localVarPath = `/api/rule-engine/{entityType}/{entityId}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleEngineControllerApi - functional programming interface
 * @export
 */
export const RuleEngineControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handleRuleEngineRequest
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRuleEngineRequestUsingPOST(requestBody: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = RuleEngineControllerApiFetchParamCreator(configuration).handleRuleEngineRequestUsingPOST(requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handleRuleEngineRequest
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {number} timeout timeout
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRuleEngineRequestUsingPOST1(entityType: string, entityId: string, timeout: number, requestBody: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = RuleEngineControllerApiFetchParamCreator(configuration).handleRuleEngineRequestUsingPOST1(entityType, entityId, timeout, requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handleRuleEngineRequest
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRuleEngineRequestUsingPOST2(entityType: string, entityId: string, requestBody: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = RuleEngineControllerApiFetchParamCreator(configuration).handleRuleEngineRequestUsingPOST2(entityType, entityId, requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RuleEngineControllerApi - factory interface
 * @export
 */
export const RuleEngineControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary handleRuleEngineRequest
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRuleEngineRequestUsingPOST(requestBody: string, options?: any) {
            return RuleEngineControllerApiFp(configuration).handleRuleEngineRequestUsingPOST(requestBody, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handleRuleEngineRequest
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {number} timeout timeout
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRuleEngineRequestUsingPOST1(entityType: string, entityId: string, timeout: number, requestBody: string, options?: any) {
            return RuleEngineControllerApiFp(configuration).handleRuleEngineRequestUsingPOST1(entityType, entityId, timeout, requestBody, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handleRuleEngineRequest
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRuleEngineRequestUsingPOST2(entityType: string, entityId: string, requestBody: string, options?: any) {
            return RuleEngineControllerApiFp(configuration).handleRuleEngineRequestUsingPOST2(entityType, entityId, requestBody, options)(fetch, basePath);
        },
    };
};

/**
 * RuleEngineControllerApi - object-oriented interface
 * @export
 * @class RuleEngineControllerApi
 * @extends {BaseAPI}
 */
export class RuleEngineControllerApi extends BaseAPI {
    /**
     * 
     * @summary handleRuleEngineRequest
     * @param {string} requestBody requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleEngineControllerApi
     */
    public handleRuleEngineRequestUsingPOST(requestBody: string, options?: any) {
        return RuleEngineControllerApiFp(this.configuration).handleRuleEngineRequestUsingPOST(requestBody, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handleRuleEngineRequest
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {number} timeout timeout
     * @param {string} requestBody requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleEngineControllerApi
     */
    public handleRuleEngineRequestUsingPOST1(entityType: string, entityId: string, timeout: number, requestBody: string, options?: any) {
        return RuleEngineControllerApiFp(this.configuration).handleRuleEngineRequestUsingPOST1(entityType, entityId, timeout, requestBody, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handleRuleEngineRequest
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} requestBody requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleEngineControllerApi
     */
    public handleRuleEngineRequestUsingPOST2(entityType: string, entityId: string, requestBody: string, options?: any) {
        return RuleEngineControllerApiFp(this.configuration).handleRuleEngineRequestUsingPOST2(entityType, entityId, requestBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SchedulerEventControllerApi - fetch parameter creator
 * @export
 */
export const SchedulerEventControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteSchedulerEvent
         * @param {string} schedulerEventId schedulerEventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedulerEventUsingDELETE(schedulerEventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'schedulerEventId' is not null or undefined
            if (schedulerEventId === null || schedulerEventId === undefined) {
                throw new RequiredError('schedulerEventId','Required parameter schedulerEventId was null or undefined when calling deleteSchedulerEventUsingDELETE.');
            }
            const localVarPath = `/api/schedulerEvent/{schedulerEventId}`
                .replace(`{${"schedulerEventId"}}`, encodeURIComponent(String(schedulerEventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSchedulerEventById
         * @param {string} schedulerEventId schedulerEventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventByIdUsingGET(schedulerEventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'schedulerEventId' is not null or undefined
            if (schedulerEventId === null || schedulerEventId === undefined) {
                throw new RequiredError('schedulerEventId','Required parameter schedulerEventId was null or undefined when calling getSchedulerEventByIdUsingGET.');
            }
            const localVarPath = `/api/schedulerEvent/{schedulerEventId}`
                .replace(`{${"schedulerEventId"}}`, encodeURIComponent(String(schedulerEventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSchedulerEventInfoById
         * @param {string} schedulerEventId schedulerEventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventInfoByIdUsingGET(schedulerEventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'schedulerEventId' is not null or undefined
            if (schedulerEventId === null || schedulerEventId === undefined) {
                throw new RequiredError('schedulerEventId','Required parameter schedulerEventId was null or undefined when calling getSchedulerEventInfoByIdUsingGET.');
            }
            const localVarPath = `/api/schedulerEvent/info/{schedulerEventId}`
                .replace(`{${"schedulerEventId"}}`, encodeURIComponent(String(schedulerEventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSchedulerEventsByIds
         * @param {string} schedulerEventIds schedulerEventIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventsByIdsUsingGET(schedulerEventIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'schedulerEventIds' is not null or undefined
            if (schedulerEventIds === null || schedulerEventIds === undefined) {
                throw new RequiredError('schedulerEventIds','Required parameter schedulerEventIds was null or undefined when calling getSchedulerEventsByIdsUsingGET.');
            }
            const localVarPath = `/api/schedulerEvents{?schedulerEventIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (schedulerEventIds !== undefined) {
                localVarQueryParameter['schedulerEventIds'] = schedulerEventIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSchedulerEvents
         * @param {string} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventsUsingGET(type?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/schedulerEvents{?type}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveSchedulerEvent
         * @param {SchedulerEvent} schedulerEvent schedulerEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSchedulerEventUsingPOST(schedulerEvent: SchedulerEvent, options: any = {}): FetchArgs {
            // verify required parameter 'schedulerEvent' is not null or undefined
            if (schedulerEvent === null || schedulerEvent === undefined) {
                throw new RequiredError('schedulerEvent','Required parameter schedulerEvent was null or undefined when calling saveSchedulerEventUsingPOST.');
            }
            const localVarPath = `/api/schedulerEvent`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SchedulerEvent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(schedulerEvent || {}) : (schedulerEvent || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulerEventControllerApi - functional programming interface
 * @export
 */
export const SchedulerEventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteSchedulerEvent
         * @param {string} schedulerEventId schedulerEventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedulerEventUsingDELETE(schedulerEventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SchedulerEventControllerApiFetchParamCreator(configuration).deleteSchedulerEventUsingDELETE(schedulerEventId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSchedulerEventById
         * @param {string} schedulerEventId schedulerEventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventByIdUsingGET(schedulerEventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SchedulerEvent> {
            const localVarFetchArgs = SchedulerEventControllerApiFetchParamCreator(configuration).getSchedulerEventByIdUsingGET(schedulerEventId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSchedulerEventInfoById
         * @param {string} schedulerEventId schedulerEventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventInfoByIdUsingGET(schedulerEventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SchedulerEventWithCustomerInfo> {
            const localVarFetchArgs = SchedulerEventControllerApiFetchParamCreator(configuration).getSchedulerEventInfoByIdUsingGET(schedulerEventId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSchedulerEventsByIds
         * @param {string} schedulerEventIds schedulerEventIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventsByIdsUsingGET(schedulerEventIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SchedulerEventInfo>> {
            const localVarFetchArgs = SchedulerEventControllerApiFetchParamCreator(configuration).getSchedulerEventsByIdsUsingGET(schedulerEventIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSchedulerEvents
         * @param {string} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventsUsingGET(type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SchedulerEventWithCustomerInfo>> {
            const localVarFetchArgs = SchedulerEventControllerApiFetchParamCreator(configuration).getSchedulerEventsUsingGET(type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveSchedulerEvent
         * @param {SchedulerEvent} schedulerEvent schedulerEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSchedulerEventUsingPOST(schedulerEvent: SchedulerEvent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SchedulerEvent> {
            const localVarFetchArgs = SchedulerEventControllerApiFetchParamCreator(configuration).saveSchedulerEventUsingPOST(schedulerEvent, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SchedulerEventControllerApi - factory interface
 * @export
 */
export const SchedulerEventControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteSchedulerEvent
         * @param {string} schedulerEventId schedulerEventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedulerEventUsingDELETE(schedulerEventId: string, options?: any) {
            return SchedulerEventControllerApiFp(configuration).deleteSchedulerEventUsingDELETE(schedulerEventId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSchedulerEventById
         * @param {string} schedulerEventId schedulerEventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventByIdUsingGET(schedulerEventId: string, options?: any) {
            return SchedulerEventControllerApiFp(configuration).getSchedulerEventByIdUsingGET(schedulerEventId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSchedulerEventInfoById
         * @param {string} schedulerEventId schedulerEventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventInfoByIdUsingGET(schedulerEventId: string, options?: any) {
            return SchedulerEventControllerApiFp(configuration).getSchedulerEventInfoByIdUsingGET(schedulerEventId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSchedulerEventsByIds
         * @param {string} schedulerEventIds schedulerEventIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventsByIdsUsingGET(schedulerEventIds: string, options?: any) {
            return SchedulerEventControllerApiFp(configuration).getSchedulerEventsByIdsUsingGET(schedulerEventIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSchedulerEvents
         * @param {string} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulerEventsUsingGET(type?: string, options?: any) {
            return SchedulerEventControllerApiFp(configuration).getSchedulerEventsUsingGET(type, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveSchedulerEvent
         * @param {SchedulerEvent} schedulerEvent schedulerEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSchedulerEventUsingPOST(schedulerEvent: SchedulerEvent, options?: any) {
            return SchedulerEventControllerApiFp(configuration).saveSchedulerEventUsingPOST(schedulerEvent, options)(fetch, basePath);
        },
    };
};

/**
 * SchedulerEventControllerApi - object-oriented interface
 * @export
 * @class SchedulerEventControllerApi
 * @extends {BaseAPI}
 */
export class SchedulerEventControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteSchedulerEvent
     * @param {string} schedulerEventId schedulerEventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerEventControllerApi
     */
    public deleteSchedulerEventUsingDELETE(schedulerEventId: string, options?: any) {
        return SchedulerEventControllerApiFp(this.configuration).deleteSchedulerEventUsingDELETE(schedulerEventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSchedulerEventById
     * @param {string} schedulerEventId schedulerEventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerEventControllerApi
     */
    public getSchedulerEventByIdUsingGET(schedulerEventId: string, options?: any) {
        return SchedulerEventControllerApiFp(this.configuration).getSchedulerEventByIdUsingGET(schedulerEventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSchedulerEventInfoById
     * @param {string} schedulerEventId schedulerEventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerEventControllerApi
     */
    public getSchedulerEventInfoByIdUsingGET(schedulerEventId: string, options?: any) {
        return SchedulerEventControllerApiFp(this.configuration).getSchedulerEventInfoByIdUsingGET(schedulerEventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSchedulerEventsByIds
     * @param {string} schedulerEventIds schedulerEventIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerEventControllerApi
     */
    public getSchedulerEventsByIdsUsingGET(schedulerEventIds: string, options?: any) {
        return SchedulerEventControllerApiFp(this.configuration).getSchedulerEventsByIdsUsingGET(schedulerEventIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSchedulerEvents
     * @param {string} [type] type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerEventControllerApi
     */
    public getSchedulerEventsUsingGET(type?: string, options?: any) {
        return SchedulerEventControllerApiFp(this.configuration).getSchedulerEventsUsingGET(type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveSchedulerEvent
     * @param {SchedulerEvent} schedulerEvent schedulerEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerEventControllerApi
     */
    public saveSchedulerEventUsingPOST(schedulerEvent: SchedulerEvent, options?: any) {
        return SchedulerEventControllerApiFp(this.configuration).saveSchedulerEventUsingPOST(schedulerEvent, options)(this.fetch, this.basePath);
    }

}

/**
 * SelfRegistrationControllerApi - fetch parameter creator
 * @export
 */
export const SelfRegistrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getPrivacyPolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivacyPolicyUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/noauth/selfRegistration/privacyPolicy`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSelfRegistrationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfRegistrationParamsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/selfRegistration/selfRegistrationParams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSignUpSelfRegistrationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUpSelfRegistrationParamsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/noauth/selfRegistration/signUpSelfRegistrationParams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveSelfRegistrationParams
         * @param {SelfRegistrationParams} selfRegistrationParams selfRegistrationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSelfRegistrationParamsUsingPOST(selfRegistrationParams: SelfRegistrationParams, options: any = {}): FetchArgs {
            // verify required parameter 'selfRegistrationParams' is not null or undefined
            if (selfRegistrationParams === null || selfRegistrationParams === undefined) {
                throw new RequiredError('selfRegistrationParams','Required parameter selfRegistrationParams was null or undefined when calling saveSelfRegistrationParamsUsingPOST.');
            }
            const localVarPath = `/api/selfRegistration/selfRegistrationParams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SelfRegistrationParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(selfRegistrationParams || {}) : (selfRegistrationParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SelfRegistrationControllerApi - functional programming interface
 * @export
 */
export const SelfRegistrationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getPrivacyPolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivacyPolicyUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SelfRegistrationControllerApiFetchParamCreator(configuration).getPrivacyPolicyUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSelfRegistrationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfRegistrationParamsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SelfRegistrationParams> {
            const localVarFetchArgs = SelfRegistrationControllerApiFetchParamCreator(configuration).getSelfRegistrationParamsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSignUpSelfRegistrationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUpSelfRegistrationParamsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SignUpSelfRegistrationParams> {
            const localVarFetchArgs = SelfRegistrationControllerApiFetchParamCreator(configuration).getSignUpSelfRegistrationParamsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveSelfRegistrationParams
         * @param {SelfRegistrationParams} selfRegistrationParams selfRegistrationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSelfRegistrationParamsUsingPOST(selfRegistrationParams: SelfRegistrationParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SelfRegistrationParams> {
            const localVarFetchArgs = SelfRegistrationControllerApiFetchParamCreator(configuration).saveSelfRegistrationParamsUsingPOST(selfRegistrationParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SelfRegistrationControllerApi - factory interface
 * @export
 */
export const SelfRegistrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getPrivacyPolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivacyPolicyUsingGET(options?: any) {
            return SelfRegistrationControllerApiFp(configuration).getPrivacyPolicyUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSelfRegistrationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfRegistrationParamsUsingGET(options?: any) {
            return SelfRegistrationControllerApiFp(configuration).getSelfRegistrationParamsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSignUpSelfRegistrationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUpSelfRegistrationParamsUsingGET(options?: any) {
            return SelfRegistrationControllerApiFp(configuration).getSignUpSelfRegistrationParamsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveSelfRegistrationParams
         * @param {SelfRegistrationParams} selfRegistrationParams selfRegistrationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSelfRegistrationParamsUsingPOST(selfRegistrationParams: SelfRegistrationParams, options?: any) {
            return SelfRegistrationControllerApiFp(configuration).saveSelfRegistrationParamsUsingPOST(selfRegistrationParams, options)(fetch, basePath);
        },
    };
};

/**
 * SelfRegistrationControllerApi - object-oriented interface
 * @export
 * @class SelfRegistrationControllerApi
 * @extends {BaseAPI}
 */
export class SelfRegistrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary getPrivacyPolicy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SelfRegistrationControllerApi
     */
    public getPrivacyPolicyUsingGET(options?: any) {
        return SelfRegistrationControllerApiFp(this.configuration).getPrivacyPolicyUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSelfRegistrationParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SelfRegistrationControllerApi
     */
    public getSelfRegistrationParamsUsingGET(options?: any) {
        return SelfRegistrationControllerApiFp(this.configuration).getSelfRegistrationParamsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSignUpSelfRegistrationParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SelfRegistrationControllerApi
     */
    public getSignUpSelfRegistrationParamsUsingGET(options?: any) {
        return SelfRegistrationControllerApiFp(this.configuration).getSignUpSelfRegistrationParamsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveSelfRegistrationParams
     * @param {SelfRegistrationParams} selfRegistrationParams selfRegistrationParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SelfRegistrationControllerApi
     */
    public saveSelfRegistrationParamsUsingPOST(selfRegistrationParams: SelfRegistrationParams, options?: any) {
        return SelfRegistrationControllerApiFp(this.configuration).saveSelfRegistrationParamsUsingPOST(selfRegistrationParams, options)(this.fetch, this.basePath);
    }

}

/**
 * SigFoxIntegrationControllerApi - fetch parameter creator
 * @export
 */
export const SigFoxIntegrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE3(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingDELETE3.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingDELETE3.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingDELETE3.');
            }
            const localVarPath = `/api/v1/integrations/sigfox/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET3(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingGET3.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingGET3.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingGET3.');
            }
            const localVarPath = `/api/v1/integrations/sigfox/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD3(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingHEAD3.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingHEAD3.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingHEAD3.');
            }
            const localVarPath = `/api/v1/integrations/sigfox/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS3(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingOPTIONS3.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingOPTIONS3.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingOPTIONS3.');
            }
            const localVarPath = `/api/v1/integrations/sigfox/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH3(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPATCH3.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPATCH3.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPATCH3.');
            }
            const localVarPath = `/api/v1/integrations/sigfox/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST9(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPOST9.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPOST9.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPOST9.');
            }
            const localVarPath = `/api/v1/integrations/sigfox/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT3(routingKey: string, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPUT3.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPUT3.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPUT3.');
            }
            const localVarPath = `/api/v1/integrations/sigfox/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SigFoxIntegrationControllerApi - functional programming interface
 * @export
 */
export const SigFoxIntegrationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE3(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = SigFoxIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingDELETE3(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET3(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = SigFoxIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingGET3(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD3(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = SigFoxIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingHEAD3(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS3(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = SigFoxIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingOPTIONS3(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH3(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = SigFoxIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPATCH3(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST9(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = SigFoxIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPOST9(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT3(routingKey: string, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = SigFoxIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPUT3(routingKey, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SigFoxIntegrationControllerApi - factory interface
 * @export
 */
export const SigFoxIntegrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return SigFoxIntegrationControllerApiFp(configuration).processRequestUsingDELETE3(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return SigFoxIntegrationControllerApiFp(configuration).processRequestUsingGET3(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return SigFoxIntegrationControllerApiFp(configuration).processRequestUsingHEAD3(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return SigFoxIntegrationControllerApiFp(configuration).processRequestUsingOPTIONS3(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return SigFoxIntegrationControllerApiFp(configuration).processRequestUsingPATCH3(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST9(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return SigFoxIntegrationControllerApiFp(configuration).processRequestUsingPOST9(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
            return SigFoxIntegrationControllerApiFp(configuration).processRequestUsingPUT3(routingKey, msg, requestHeaders, options)(fetch, basePath);
        },
    };
};

/**
 * SigFoxIntegrationControllerApi - object-oriented interface
 * @export
 * @class SigFoxIntegrationControllerApi
 * @extends {BaseAPI}
 */
export class SigFoxIntegrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigFoxIntegrationControllerApi
     */
    public processRequestUsingDELETE3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return SigFoxIntegrationControllerApiFp(this.configuration).processRequestUsingDELETE3(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigFoxIntegrationControllerApi
     */
    public processRequestUsingGET3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return SigFoxIntegrationControllerApiFp(this.configuration).processRequestUsingGET3(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigFoxIntegrationControllerApi
     */
    public processRequestUsingHEAD3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return SigFoxIntegrationControllerApiFp(this.configuration).processRequestUsingHEAD3(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigFoxIntegrationControllerApi
     */
    public processRequestUsingOPTIONS3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return SigFoxIntegrationControllerApiFp(this.configuration).processRequestUsingOPTIONS3(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigFoxIntegrationControllerApi
     */
    public processRequestUsingPATCH3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return SigFoxIntegrationControllerApiFp(this.configuration).processRequestUsingPATCH3(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigFoxIntegrationControllerApi
     */
    public processRequestUsingPOST9(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return SigFoxIntegrationControllerApiFp(this.configuration).processRequestUsingPOST9(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigFoxIntegrationControllerApi
     */
    public processRequestUsingPUT3(routingKey: string, msg: string, requestHeaders: any, options?: any) {
        return SigFoxIntegrationControllerApiFp(this.configuration).processRequestUsingPUT3(routingKey, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

}

/**
 * SignUpControllerApi - fetch parameter creator
 * @export
 */
export const SignUpControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary acceptPrivacyPolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptPrivacyPolicyUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/api/signup/acceptPrivacyPolicy`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary activateEmail
         * @param {string} emailCode emailCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEmailUsingGET(emailCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailCode' is not null or undefined
            if (emailCode === null || emailCode === undefined) {
                throw new RequiredError('emailCode','Required parameter emailCode was null or undefined when calling activateEmailUsingGET.');
            }
            const localVarPath = `/api/noauth/activateEmail{?emailCode}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (emailCode !== undefined) {
                localVarQueryParameter['emailCode'] = emailCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary activateUserByEmailCode
         * @param {string} emailCode emailCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUserByEmailCodeUsingPOST(emailCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailCode' is not null or undefined
            if (emailCode === null || emailCode === undefined) {
                throw new RequiredError('emailCode','Required parameter emailCode was null or undefined when calling activateUserByEmailCodeUsingPOST.');
            }
            const localVarPath = `/api/noauth/activateByEmailCode{?emailCode}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (emailCode !== undefined) {
                localVarQueryParameter['emailCode'] = emailCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary privacyPolicyAccepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyPolicyAcceptedUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/signup/privacyPolicyAccepted`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary resendEmailActivation
         * @param {string} email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmailActivationUsingPOST(email: string, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling resendEmailActivationUsingPOST.');
            }
            const localVarPath = `/api/noauth/resendEmailActivation{?email}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signUp
         * @param {SignUpRequest} signUpRequest signUpRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(signUpRequest: SignUpRequest, options: any = {}): FetchArgs {
            // verify required parameter 'signUpRequest' is not null or undefined
            if (signUpRequest === null || signUpRequest === undefined) {
                throw new RequiredError('signUpRequest','Required parameter signUpRequest was null or undefined when calling signUpUsingPOST.');
            }
            const localVarPath = `/api/noauth/signup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignUpRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(signUpRequest || {}) : (signUpRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignUpControllerApi - functional programming interface
 * @export
 */
export const SignUpControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary acceptPrivacyPolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptPrivacyPolicyUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SignUpControllerApiFetchParamCreator(configuration).acceptPrivacyPolicyUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary activateEmail
         * @param {string} emailCode emailCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEmailUsingGET(emailCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SignUpControllerApiFetchParamCreator(configuration).activateEmailUsingGET(emailCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary activateUserByEmailCode
         * @param {string} emailCode emailCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUserByEmailCodeUsingPOST(emailCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SignUpControllerApiFetchParamCreator(configuration).activateUserByEmailCodeUsingPOST(emailCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary privacyPolicyAccepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyPolicyAcceptedUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SignUpControllerApiFetchParamCreator(configuration).privacyPolicyAcceptedUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary resendEmailActivation
         * @param {string} email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmailActivationUsingPOST(email: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SignUpControllerApiFetchParamCreator(configuration).resendEmailActivationUsingPOST(email, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary signUp
         * @param {SignUpRequest} signUpRequest signUpRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(signUpRequest: SignUpRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SignUpControllerApiFetchParamCreator(configuration).signUpUsingPOST(signUpRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SignUpControllerApi - factory interface
 * @export
 */
export const SignUpControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary acceptPrivacyPolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptPrivacyPolicyUsingPOST(options?: any) {
            return SignUpControllerApiFp(configuration).acceptPrivacyPolicyUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary activateEmail
         * @param {string} emailCode emailCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEmailUsingGET(emailCode: string, options?: any) {
            return SignUpControllerApiFp(configuration).activateEmailUsingGET(emailCode, options)(fetch, basePath);
        },
        /**
         * 
         * @summary activateUserByEmailCode
         * @param {string} emailCode emailCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUserByEmailCodeUsingPOST(emailCode: string, options?: any) {
            return SignUpControllerApiFp(configuration).activateUserByEmailCodeUsingPOST(emailCode, options)(fetch, basePath);
        },
        /**
         * 
         * @summary privacyPolicyAccepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyPolicyAcceptedUsingGET(options?: any) {
            return SignUpControllerApiFp(configuration).privacyPolicyAcceptedUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary resendEmailActivation
         * @param {string} email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmailActivationUsingPOST(email: string, options?: any) {
            return SignUpControllerApiFp(configuration).resendEmailActivationUsingPOST(email, options)(fetch, basePath);
        },
        /**
         * 
         * @summary signUp
         * @param {SignUpRequest} signUpRequest signUpRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(signUpRequest: SignUpRequest, options?: any) {
            return SignUpControllerApiFp(configuration).signUpUsingPOST(signUpRequest, options)(fetch, basePath);
        },
    };
};

/**
 * SignUpControllerApi - object-oriented interface
 * @export
 * @class SignUpControllerApi
 * @extends {BaseAPI}
 */
export class SignUpControllerApi extends BaseAPI {
    /**
     * 
     * @summary acceptPrivacyPolicy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignUpControllerApi
     */
    public acceptPrivacyPolicyUsingPOST(options?: any) {
        return SignUpControllerApiFp(this.configuration).acceptPrivacyPolicyUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary activateEmail
     * @param {string} emailCode emailCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignUpControllerApi
     */
    public activateEmailUsingGET(emailCode: string, options?: any) {
        return SignUpControllerApiFp(this.configuration).activateEmailUsingGET(emailCode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary activateUserByEmailCode
     * @param {string} emailCode emailCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignUpControllerApi
     */
    public activateUserByEmailCodeUsingPOST(emailCode: string, options?: any) {
        return SignUpControllerApiFp(this.configuration).activateUserByEmailCodeUsingPOST(emailCode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary privacyPolicyAccepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignUpControllerApi
     */
    public privacyPolicyAcceptedUsingGET(options?: any) {
        return SignUpControllerApiFp(this.configuration).privacyPolicyAcceptedUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary resendEmailActivation
     * @param {string} email email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignUpControllerApi
     */
    public resendEmailActivationUsingPOST(email: string, options?: any) {
        return SignUpControllerApiFp(this.configuration).resendEmailActivationUsingPOST(email, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary signUp
     * @param {SignUpRequest} signUpRequest signUpRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignUpControllerApi
     */
    public signUpUsingPOST(signUpRequest: SignUpRequest, options?: any) {
        return SignUpControllerApiFp(this.configuration).signUpUsingPOST(signUpRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * TMobileIotCdpIntegrationControllerApi - fetch parameter creator
 * @export
 */
export const TMobileIotCdpIntegrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingDELETE(routingKey: string, requestHeaders?: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processCheckUsingDELETE.');
            }
            const localVarPath = `/api/v1/integrations/tmobile_iot_cdp/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingGET(routingKey: string, requestHeaders?: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processCheckUsingGET.');
            }
            const localVarPath = `/api/v1/integrations/tmobile_iot_cdp/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingHEAD(routingKey: string, requestHeaders?: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processCheckUsingHEAD.');
            }
            const localVarPath = `/api/v1/integrations/tmobile_iot_cdp/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingOPTIONS(routingKey: string, requestHeaders?: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processCheckUsingOPTIONS.');
            }
            const localVarPath = `/api/v1/integrations/tmobile_iot_cdp/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingPATCH(routingKey: string, requestHeaders?: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processCheckUsingPATCH.');
            }
            const localVarPath = `/api/v1/integrations/tmobile_iot_cdp/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingPOST(routingKey: string, requestHeaders?: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processCheckUsingPOST.');
            }
            const localVarPath = `/api/v1/integrations/tmobile_iot_cdp/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingPUT(routingKey: string, requestHeaders?: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processCheckUsingPUT.');
            }
            const localVarPath = `/api/v1/integrations/tmobile_iot_cdp/{routingKey}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TMobileIotCdpIntegrationControllerApi - functional programming interface
 * @export
 */
export const TMobileIotCdpIntegrationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingDELETE(routingKey: string, requestHeaders?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TMobileIotCdpIntegrationControllerApiFetchParamCreator(configuration).processCheckUsingDELETE(routingKey, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingGET(routingKey: string, requestHeaders?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TMobileIotCdpIntegrationControllerApiFetchParamCreator(configuration).processCheckUsingGET(routingKey, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingHEAD(routingKey: string, requestHeaders?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TMobileIotCdpIntegrationControllerApiFetchParamCreator(configuration).processCheckUsingHEAD(routingKey, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingOPTIONS(routingKey: string, requestHeaders?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TMobileIotCdpIntegrationControllerApiFetchParamCreator(configuration).processCheckUsingOPTIONS(routingKey, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingPATCH(routingKey: string, requestHeaders?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TMobileIotCdpIntegrationControllerApiFetchParamCreator(configuration).processCheckUsingPATCH(routingKey, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingPOST(routingKey: string, requestHeaders?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TMobileIotCdpIntegrationControllerApiFetchParamCreator(configuration).processCheckUsingPOST(routingKey, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingPUT(routingKey: string, requestHeaders?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TMobileIotCdpIntegrationControllerApiFetchParamCreator(configuration).processCheckUsingPUT(routingKey, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TMobileIotCdpIntegrationControllerApi - factory interface
 * @export
 */
export const TMobileIotCdpIntegrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingDELETE(routingKey: string, requestHeaders?: any, options?: any) {
            return TMobileIotCdpIntegrationControllerApiFp(configuration).processCheckUsingDELETE(routingKey, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingGET(routingKey: string, requestHeaders?: any, options?: any) {
            return TMobileIotCdpIntegrationControllerApiFp(configuration).processCheckUsingGET(routingKey, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingHEAD(routingKey: string, requestHeaders?: any, options?: any) {
            return TMobileIotCdpIntegrationControllerApiFp(configuration).processCheckUsingHEAD(routingKey, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingOPTIONS(routingKey: string, requestHeaders?: any, options?: any) {
            return TMobileIotCdpIntegrationControllerApiFp(configuration).processCheckUsingOPTIONS(routingKey, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingPATCH(routingKey: string, requestHeaders?: any, options?: any) {
            return TMobileIotCdpIntegrationControllerApiFp(configuration).processCheckUsingPATCH(routingKey, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingPOST(routingKey: string, requestHeaders?: any, options?: any) {
            return TMobileIotCdpIntegrationControllerApiFp(configuration).processCheckUsingPOST(routingKey, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processCheck
         * @param {string} routingKey routingKey
         * @param {any} [requestHeaders] requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processCheckUsingPUT(routingKey: string, requestHeaders?: any, options?: any) {
            return TMobileIotCdpIntegrationControllerApiFp(configuration).processCheckUsingPUT(routingKey, requestHeaders, options)(fetch, basePath);
        },
    };
};

/**
 * TMobileIotCdpIntegrationControllerApi - object-oriented interface
 * @export
 * @class TMobileIotCdpIntegrationControllerApi
 * @extends {BaseAPI}
 */
export class TMobileIotCdpIntegrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary processCheck
     * @param {string} routingKey routingKey
     * @param {any} [requestHeaders] requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TMobileIotCdpIntegrationControllerApi
     */
    public processCheckUsingDELETE(routingKey: string, requestHeaders?: any, options?: any) {
        return TMobileIotCdpIntegrationControllerApiFp(this.configuration).processCheckUsingDELETE(routingKey, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processCheck
     * @param {string} routingKey routingKey
     * @param {any} [requestHeaders] requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TMobileIotCdpIntegrationControllerApi
     */
    public processCheckUsingGET(routingKey: string, requestHeaders?: any, options?: any) {
        return TMobileIotCdpIntegrationControllerApiFp(this.configuration).processCheckUsingGET(routingKey, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processCheck
     * @param {string} routingKey routingKey
     * @param {any} [requestHeaders] requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TMobileIotCdpIntegrationControllerApi
     */
    public processCheckUsingHEAD(routingKey: string, requestHeaders?: any, options?: any) {
        return TMobileIotCdpIntegrationControllerApiFp(this.configuration).processCheckUsingHEAD(routingKey, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processCheck
     * @param {string} routingKey routingKey
     * @param {any} [requestHeaders] requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TMobileIotCdpIntegrationControllerApi
     */
    public processCheckUsingOPTIONS(routingKey: string, requestHeaders?: any, options?: any) {
        return TMobileIotCdpIntegrationControllerApiFp(this.configuration).processCheckUsingOPTIONS(routingKey, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processCheck
     * @param {string} routingKey routingKey
     * @param {any} [requestHeaders] requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TMobileIotCdpIntegrationControllerApi
     */
    public processCheckUsingPATCH(routingKey: string, requestHeaders?: any, options?: any) {
        return TMobileIotCdpIntegrationControllerApiFp(this.configuration).processCheckUsingPATCH(routingKey, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processCheck
     * @param {string} routingKey routingKey
     * @param {any} [requestHeaders] requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TMobileIotCdpIntegrationControllerApi
     */
    public processCheckUsingPOST(routingKey: string, requestHeaders?: any, options?: any) {
        return TMobileIotCdpIntegrationControllerApiFp(this.configuration).processCheckUsingPOST(routingKey, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processCheck
     * @param {string} routingKey routingKey
     * @param {any} [requestHeaders] requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TMobileIotCdpIntegrationControllerApi
     */
    public processCheckUsingPUT(routingKey: string, requestHeaders?: any, options?: any) {
        return TMobileIotCdpIntegrationControllerApiFp(this.configuration).processCheckUsingPUT(routingKey, requestHeaders, options)(this.fetch, this.basePath);
    }

}

/**
 * TelemetryControllerApi - fetch parameter creator
 * @export
 */
export const TelemetryControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteEntityAttributes
         * @param {string} deviceId deviceId
         * @param {string} scope scope
         * @param {string} keys keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributesUsingDELETE(deviceId: string, scope: string, keys: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling deleteEntityAttributesUsingDELETE.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling deleteEntityAttributesUsingDELETE.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling deleteEntityAttributesUsingDELETE.');
            }
            const localVarPath = `/api/plugins/telemetry/{deviceId}/{scope}{?keys}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (keys !== undefined) {
                localVarQueryParameter['keys'] = keys;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteEntityAttributes
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} keys keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributesUsingDELETE1(entityType: string, entityId: string, scope: string, keys: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling deleteEntityAttributesUsingDELETE1.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling deleteEntityAttributesUsingDELETE1.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling deleteEntityAttributesUsingDELETE1.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling deleteEntityAttributesUsingDELETE1.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/{scope}{?keys}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (keys !== undefined) {
                localVarQueryParameter['keys'] = keys;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteEntityTimeseries
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} keys keys
         * @param {boolean} [deleteAllDataForKeys] deleteAllDataForKeys
         * @param {number} [startTs] startTs
         * @param {number} [endTs] endTs
         * @param {boolean} [rewriteLatestIfDeleted] rewriteLatestIfDeleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityTimeseriesUsingDELETE(entityType: string, entityId: string, keys: string, deleteAllDataForKeys?: boolean, startTs?: number, endTs?: number, rewriteLatestIfDeleted?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling deleteEntityTimeseriesUsingDELETE.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling deleteEntityTimeseriesUsingDELETE.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling deleteEntityTimeseriesUsingDELETE.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/timeseries/delete{?keys,deleteAllDataForKeys,startTs,endTs,rewriteLatestIfDeleted}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (keys !== undefined) {
                localVarQueryParameter['keys'] = keys;
            }

            if (deleteAllDataForKeys !== undefined) {
                localVarQueryParameter['deleteAllDataForKeys'] = deleteAllDataForKeys;
            }

            if (startTs !== undefined) {
                localVarQueryParameter['startTs'] = startTs;
            }

            if (endTs !== undefined) {
                localVarQueryParameter['endTs'] = endTs;
            }

            if (rewriteLatestIfDeleted !== undefined) {
                localVarQueryParameter['rewriteLatestIfDeleted'] = rewriteLatestIfDeleted;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAttributeKeysByScope
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysByScopeUsingGET(entityType: string, entityId: string, scope: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getAttributeKeysByScopeUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getAttributeKeysByScopeUsingGET.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling getAttributeKeysByScopeUsingGET.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/keys/attributes/{scope}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAttributeKeys
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET(entityType: string, entityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getAttributeKeysUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getAttributeKeysUsingGET.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/keys/attributes`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAttributesByScope
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} [keys] keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesByScopeUsingGET(entityType: string, entityId: string, scope: string, keys?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getAttributesByScopeUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getAttributesByScopeUsingGET.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling getAttributesByScopeUsingGET.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/values/attributes/{scope}{?keys}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (keys !== undefined) {
                localVarQueryParameter['keys'] = keys;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAttributes
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} [keys] keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesUsingGET(entityType: string, entityId: string, keys?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getAttributesUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getAttributesUsingGET.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/values/attributes{?keys}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (keys !== undefined) {
                localVarQueryParameter['keys'] = keys;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getLatestTimeseries
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} [keys] keys
         * @param {boolean} [useStrictDataTypes] useStrictDataTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTimeseriesUsingGET(entityType: string, entityId: string, keys?: string, useStrictDataTypes?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getLatestTimeseriesUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getLatestTimeseriesUsingGET.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/values/timeseries{?keys,useStrictDataTypes}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (keys !== undefined) {
                localVarQueryParameter['keys'] = keys;
            }

            if (useStrictDataTypes !== undefined) {
                localVarQueryParameter['useStrictDataTypes'] = useStrictDataTypes;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTimeseriesKeys
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseriesKeysUsingGET1(entityType: string, entityId: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getTimeseriesKeysUsingGET1.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getTimeseriesKeysUsingGET1.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/keys/timeseries`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTimeseries
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} keys keys
         * @param {string} startTs startTs
         * @param {string} endTs endTs
         * @param {number} [interval] interval
         * @param {number} [limit] limit
         * @param {string} [agg] agg
         * @param {string} [orderBy] orderBy
         * @param {boolean} [useStrictDataTypes] useStrictDataTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseriesUsingGET(entityType: string, entityId: string, keys: string, startTs: string, endTs: string, interval?: number, limit?: number, agg?: string, orderBy?: string, useStrictDataTypes?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling getTimeseriesUsingGET.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling getTimeseriesUsingGET.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling getTimeseriesUsingGET.');
            }
            // verify required parameter 'startTs' is not null or undefined
            if (startTs === null || startTs === undefined) {
                throw new RequiredError('startTs','Required parameter startTs was null or undefined when calling getTimeseriesUsingGET.');
            }
            // verify required parameter 'endTs' is not null or undefined
            if (endTs === null || endTs === undefined) {
                throw new RequiredError('endTs','Required parameter endTs was null or undefined when calling getTimeseriesUsingGET.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/values/timeseries{?interval,limit,agg,orderBy,useStrictDataTypes,keys,startTs,endTs}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (agg !== undefined) {
                localVarQueryParameter['agg'] = agg;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (useStrictDataTypes !== undefined) {
                localVarQueryParameter['useStrictDataTypes'] = useStrictDataTypes;
            }

            if (keys !== undefined) {
                localVarQueryParameter['keys'] = keys;
            }

            if (startTs !== undefined) {
                localVarQueryParameter['startTs'] = startTs;
            }

            if (endTs !== undefined) {
                localVarQueryParameter['endTs'] = endTs;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveDeviceAttributes
         * @param {string} deviceId deviceId
         * @param {string} scope scope
         * @param {string} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceAttributesUsingPOST(deviceId: string, scope: string, request: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling saveDeviceAttributesUsingPOST.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling saveDeviceAttributesUsingPOST.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling saveDeviceAttributesUsingPOST.');
            }
            const localVarPath = `/api/plugins/telemetry/{deviceId}/{scope}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveEntityAttributesV1
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityAttributesV1UsingPOST(entityType: string, entityId: string, scope: string, request: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling saveEntityAttributesV1UsingPOST.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling saveEntityAttributesV1UsingPOST.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling saveEntityAttributesV1UsingPOST.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling saveEntityAttributesV1UsingPOST.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/{scope}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveEntityAttributesV2
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityAttributesV2UsingPOST(entityType: string, entityId: string, scope: string, request: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling saveEntityAttributesV2UsingPOST.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling saveEntityAttributesV2UsingPOST.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling saveEntityAttributesV2UsingPOST.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling saveEntityAttributesV2UsingPOST.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/attributes/{scope}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveEntityTelemetry
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityTelemetryUsingPOST(entityType: string, entityId: string, scope: string, requestBody: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling saveEntityTelemetryUsingPOST.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling saveEntityTelemetryUsingPOST.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling saveEntityTelemetryUsingPOST.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling saveEntityTelemetryUsingPOST.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/timeseries/{scope}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveEntityTelemetryWithTTL
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {number} ttl ttl
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityTelemetryWithTTLUsingPOST(entityType: string, entityId: string, scope: string, ttl: number, requestBody: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityType' is not null or undefined
            if (entityType === null || entityType === undefined) {
                throw new RequiredError('entityType','Required parameter entityType was null or undefined when calling saveEntityTelemetryWithTTLUsingPOST.');
            }
            // verify required parameter 'entityId' is not null or undefined
            if (entityId === null || entityId === undefined) {
                throw new RequiredError('entityId','Required parameter entityId was null or undefined when calling saveEntityTelemetryWithTTLUsingPOST.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling saveEntityTelemetryWithTTLUsingPOST.');
            }
            // verify required parameter 'ttl' is not null or undefined
            if (ttl === null || ttl === undefined) {
                throw new RequiredError('ttl','Required parameter ttl was null or undefined when calling saveEntityTelemetryWithTTLUsingPOST.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling saveEntityTelemetryWithTTLUsingPOST.');
            }
            const localVarPath = `/api/plugins/telemetry/{entityType}/{entityId}/timeseries/{scope}/{ttl}`
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"ttl"}}`, encodeURIComponent(String(ttl)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelemetryControllerApi - functional programming interface
 * @export
 */
export const TelemetryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteEntityAttributes
         * @param {string} deviceId deviceId
         * @param {string} scope scope
         * @param {string} keys keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributesUsingDELETE(deviceId: string, scope: string, keys: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).deleteEntityAttributesUsingDELETE(deviceId, scope, keys, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteEntityAttributes
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} keys keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributesUsingDELETE1(entityType: string, entityId: string, scope: string, keys: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).deleteEntityAttributesUsingDELETE1(entityType, entityId, scope, keys, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteEntityTimeseries
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} keys keys
         * @param {boolean} [deleteAllDataForKeys] deleteAllDataForKeys
         * @param {number} [startTs] startTs
         * @param {number} [endTs] endTs
         * @param {boolean} [rewriteLatestIfDeleted] rewriteLatestIfDeleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityTimeseriesUsingDELETE(entityType: string, entityId: string, keys: string, deleteAllDataForKeys?: boolean, startTs?: number, endTs?: number, rewriteLatestIfDeleted?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).deleteEntityTimeseriesUsingDELETE(entityType, entityId, keys, deleteAllDataForKeys, startTs, endTs, rewriteLatestIfDeleted, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAttributeKeysByScope
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysByScopeUsingGET(entityType: string, entityId: string, scope: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).getAttributeKeysByScopeUsingGET(entityType, entityId, scope, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAttributeKeys
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET(entityType: string, entityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).getAttributeKeysUsingGET(entityType, entityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAttributesByScope
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} [keys] keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesByScopeUsingGET(entityType: string, entityId: string, scope: string, keys?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).getAttributesByScopeUsingGET(entityType, entityId, scope, keys, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAttributes
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} [keys] keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesUsingGET(entityType: string, entityId: string, keys?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).getAttributesUsingGET(entityType, entityId, keys, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getLatestTimeseries
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} [keys] keys
         * @param {boolean} [useStrictDataTypes] useStrictDataTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTimeseriesUsingGET(entityType: string, entityId: string, keys?: string, useStrictDataTypes?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).getLatestTimeseriesUsingGET(entityType, entityId, keys, useStrictDataTypes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTimeseriesKeys
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseriesKeysUsingGET1(entityType: string, entityId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).getTimeseriesKeysUsingGET1(entityType, entityId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTimeseries
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} keys keys
         * @param {string} startTs startTs
         * @param {string} endTs endTs
         * @param {number} [interval] interval
         * @param {number} [limit] limit
         * @param {string} [agg] agg
         * @param {string} [orderBy] orderBy
         * @param {boolean} [useStrictDataTypes] useStrictDataTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseriesUsingGET(entityType: string, entityId: string, keys: string, startTs: string, endTs: string, interval?: number, limit?: number, agg?: string, orderBy?: string, useStrictDataTypes?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).getTimeseriesUsingGET(entityType, entityId, keys, startTs, endTs, interval, limit, agg, orderBy, useStrictDataTypes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveDeviceAttributes
         * @param {string} deviceId deviceId
         * @param {string} scope scope
         * @param {string} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceAttributesUsingPOST(deviceId: string, scope: string, request: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).saveDeviceAttributesUsingPOST(deviceId, scope, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveEntityAttributesV1
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityAttributesV1UsingPOST(entityType: string, entityId: string, scope: string, request: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).saveEntityAttributesV1UsingPOST(entityType, entityId, scope, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveEntityAttributesV2
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityAttributesV2UsingPOST(entityType: string, entityId: string, scope: string, request: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).saveEntityAttributesV2UsingPOST(entityType, entityId, scope, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveEntityTelemetry
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityTelemetryUsingPOST(entityType: string, entityId: string, scope: string, requestBody: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).saveEntityTelemetryUsingPOST(entityType, entityId, scope, requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveEntityTelemetryWithTTL
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {number} ttl ttl
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityTelemetryWithTTLUsingPOST(entityType: string, entityId: string, scope: string, ttl: number, requestBody: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = TelemetryControllerApiFetchParamCreator(configuration).saveEntityTelemetryWithTTLUsingPOST(entityType, entityId, scope, ttl, requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TelemetryControllerApi - factory interface
 * @export
 */
export const TelemetryControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteEntityAttributes
         * @param {string} deviceId deviceId
         * @param {string} scope scope
         * @param {string} keys keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributesUsingDELETE(deviceId: string, scope: string, keys: string, options?: any) {
            return TelemetryControllerApiFp(configuration).deleteEntityAttributesUsingDELETE(deviceId, scope, keys, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteEntityAttributes
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} keys keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributesUsingDELETE1(entityType: string, entityId: string, scope: string, keys: string, options?: any) {
            return TelemetryControllerApiFp(configuration).deleteEntityAttributesUsingDELETE1(entityType, entityId, scope, keys, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteEntityTimeseries
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} keys keys
         * @param {boolean} [deleteAllDataForKeys] deleteAllDataForKeys
         * @param {number} [startTs] startTs
         * @param {number} [endTs] endTs
         * @param {boolean} [rewriteLatestIfDeleted] rewriteLatestIfDeleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityTimeseriesUsingDELETE(entityType: string, entityId: string, keys: string, deleteAllDataForKeys?: boolean, startTs?: number, endTs?: number, rewriteLatestIfDeleted?: boolean, options?: any) {
            return TelemetryControllerApiFp(configuration).deleteEntityTimeseriesUsingDELETE(entityType, entityId, keys, deleteAllDataForKeys, startTs, endTs, rewriteLatestIfDeleted, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAttributeKeysByScope
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysByScopeUsingGET(entityType: string, entityId: string, scope: string, options?: any) {
            return TelemetryControllerApiFp(configuration).getAttributeKeysByScopeUsingGET(entityType, entityId, scope, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAttributeKeys
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET(entityType: string, entityId: string, options?: any) {
            return TelemetryControllerApiFp(configuration).getAttributeKeysUsingGET(entityType, entityId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAttributesByScope
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} [keys] keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesByScopeUsingGET(entityType: string, entityId: string, scope: string, keys?: string, options?: any) {
            return TelemetryControllerApiFp(configuration).getAttributesByScopeUsingGET(entityType, entityId, scope, keys, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAttributes
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} [keys] keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesUsingGET(entityType: string, entityId: string, keys?: string, options?: any) {
            return TelemetryControllerApiFp(configuration).getAttributesUsingGET(entityType, entityId, keys, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getLatestTimeseries
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} [keys] keys
         * @param {boolean} [useStrictDataTypes] useStrictDataTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTimeseriesUsingGET(entityType: string, entityId: string, keys?: string, useStrictDataTypes?: boolean, options?: any) {
            return TelemetryControllerApiFp(configuration).getLatestTimeseriesUsingGET(entityType, entityId, keys, useStrictDataTypes, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTimeseriesKeys
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseriesKeysUsingGET1(entityType: string, entityId: string, options?: any) {
            return TelemetryControllerApiFp(configuration).getTimeseriesKeysUsingGET1(entityType, entityId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTimeseries
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} keys keys
         * @param {string} startTs startTs
         * @param {string} endTs endTs
         * @param {number} [interval] interval
         * @param {number} [limit] limit
         * @param {string} [agg] agg
         * @param {string} [orderBy] orderBy
         * @param {boolean} [useStrictDataTypes] useStrictDataTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseriesUsingGET(entityType: string, entityId: string, keys: string, startTs: string, endTs: string, interval?: number, limit?: number, agg?: string, orderBy?: string, useStrictDataTypes?: boolean, options?: any) {
            return TelemetryControllerApiFp(configuration).getTimeseriesUsingGET(entityType, entityId, keys, startTs, endTs, interval, limit, agg, orderBy, useStrictDataTypes, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveDeviceAttributes
         * @param {string} deviceId deviceId
         * @param {string} scope scope
         * @param {string} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDeviceAttributesUsingPOST(deviceId: string, scope: string, request: string, options?: any) {
            return TelemetryControllerApiFp(configuration).saveDeviceAttributesUsingPOST(deviceId, scope, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveEntityAttributesV1
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityAttributesV1UsingPOST(entityType: string, entityId: string, scope: string, request: string, options?: any) {
            return TelemetryControllerApiFp(configuration).saveEntityAttributesV1UsingPOST(entityType, entityId, scope, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveEntityAttributesV2
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityAttributesV2UsingPOST(entityType: string, entityId: string, scope: string, request: string, options?: any) {
            return TelemetryControllerApiFp(configuration).saveEntityAttributesV2UsingPOST(entityType, entityId, scope, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveEntityTelemetry
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityTelemetryUsingPOST(entityType: string, entityId: string, scope: string, requestBody: string, options?: any) {
            return TelemetryControllerApiFp(configuration).saveEntityTelemetryUsingPOST(entityType, entityId, scope, requestBody, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveEntityTelemetryWithTTL
         * @param {string} entityType entityType
         * @param {string} entityId entityId
         * @param {string} scope scope
         * @param {number} ttl ttl
         * @param {string} requestBody requestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEntityTelemetryWithTTLUsingPOST(entityType: string, entityId: string, scope: string, ttl: number, requestBody: string, options?: any) {
            return TelemetryControllerApiFp(configuration).saveEntityTelemetryWithTTLUsingPOST(entityType, entityId, scope, ttl, requestBody, options)(fetch, basePath);
        },
    };
};

/**
 * TelemetryControllerApi - object-oriented interface
 * @export
 * @class TelemetryControllerApi
 * @extends {BaseAPI}
 */
export class TelemetryControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteEntityAttributes
     * @param {string} deviceId deviceId
     * @param {string} scope scope
     * @param {string} keys keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public deleteEntityAttributesUsingDELETE(deviceId: string, scope: string, keys: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).deleteEntityAttributesUsingDELETE(deviceId, scope, keys, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteEntityAttributes
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} scope scope
     * @param {string} keys keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public deleteEntityAttributesUsingDELETE1(entityType: string, entityId: string, scope: string, keys: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).deleteEntityAttributesUsingDELETE1(entityType, entityId, scope, keys, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteEntityTimeseries
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} keys keys
     * @param {boolean} [deleteAllDataForKeys] deleteAllDataForKeys
     * @param {number} [startTs] startTs
     * @param {number} [endTs] endTs
     * @param {boolean} [rewriteLatestIfDeleted] rewriteLatestIfDeleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public deleteEntityTimeseriesUsingDELETE(entityType: string, entityId: string, keys: string, deleteAllDataForKeys?: boolean, startTs?: number, endTs?: number, rewriteLatestIfDeleted?: boolean, options?: any) {
        return TelemetryControllerApiFp(this.configuration).deleteEntityTimeseriesUsingDELETE(entityType, entityId, keys, deleteAllDataForKeys, startTs, endTs, rewriteLatestIfDeleted, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAttributeKeysByScope
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} scope scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public getAttributeKeysByScopeUsingGET(entityType: string, entityId: string, scope: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).getAttributeKeysByScopeUsingGET(entityType, entityId, scope, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAttributeKeys
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public getAttributeKeysUsingGET(entityType: string, entityId: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).getAttributeKeysUsingGET(entityType, entityId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAttributesByScope
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} scope scope
     * @param {string} [keys] keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public getAttributesByScopeUsingGET(entityType: string, entityId: string, scope: string, keys?: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).getAttributesByScopeUsingGET(entityType, entityId, scope, keys, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAttributes
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} [keys] keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public getAttributesUsingGET(entityType: string, entityId: string, keys?: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).getAttributesUsingGET(entityType, entityId, keys, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getLatestTimeseries
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} [keys] keys
     * @param {boolean} [useStrictDataTypes] useStrictDataTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public getLatestTimeseriesUsingGET(entityType: string, entityId: string, keys?: string, useStrictDataTypes?: boolean, options?: any) {
        return TelemetryControllerApiFp(this.configuration).getLatestTimeseriesUsingGET(entityType, entityId, keys, useStrictDataTypes, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTimeseriesKeys
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public getTimeseriesKeysUsingGET1(entityType: string, entityId: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).getTimeseriesKeysUsingGET1(entityType, entityId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTimeseries
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} keys keys
     * @param {string} startTs startTs
     * @param {string} endTs endTs
     * @param {number} [interval] interval
     * @param {number} [limit] limit
     * @param {string} [agg] agg
     * @param {string} [orderBy] orderBy
     * @param {boolean} [useStrictDataTypes] useStrictDataTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public getTimeseriesUsingGET(entityType: string, entityId: string, keys: string, startTs: string, endTs: string, interval?: number, limit?: number, agg?: string, orderBy?: string, useStrictDataTypes?: boolean, options?: any) {
        return TelemetryControllerApiFp(this.configuration).getTimeseriesUsingGET(entityType, entityId, keys, startTs, endTs, interval, limit, agg, orderBy, useStrictDataTypes, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveDeviceAttributes
     * @param {string} deviceId deviceId
     * @param {string} scope scope
     * @param {string} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public saveDeviceAttributesUsingPOST(deviceId: string, scope: string, request: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).saveDeviceAttributesUsingPOST(deviceId, scope, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveEntityAttributesV1
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} scope scope
     * @param {string} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public saveEntityAttributesV1UsingPOST(entityType: string, entityId: string, scope: string, request: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).saveEntityAttributesV1UsingPOST(entityType, entityId, scope, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveEntityAttributesV2
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} scope scope
     * @param {string} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public saveEntityAttributesV2UsingPOST(entityType: string, entityId: string, scope: string, request: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).saveEntityAttributesV2UsingPOST(entityType, entityId, scope, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveEntityTelemetry
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} scope scope
     * @param {string} requestBody requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public saveEntityTelemetryUsingPOST(entityType: string, entityId: string, scope: string, requestBody: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).saveEntityTelemetryUsingPOST(entityType, entityId, scope, requestBody, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveEntityTelemetryWithTTL
     * @param {string} entityType entityType
     * @param {string} entityId entityId
     * @param {string} scope scope
     * @param {number} ttl ttl
     * @param {string} requestBody requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryControllerApi
     */
    public saveEntityTelemetryWithTTLUsingPOST(entityType: string, entityId: string, scope: string, ttl: number, requestBody: string, options?: any) {
        return TelemetryControllerApiFp(this.configuration).saveEntityTelemetryWithTTLUsingPOST(entityType, entityId, scope, ttl, requestBody, options)(this.fetch, this.basePath);
    }

}

/**
 * TenantControllerApi - fetch parameter creator
 * @export
 */
export const TenantControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteTenant
         * @param {string} tenantId tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantUsingDELETE(tenantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling deleteTenantUsingDELETE.');
            }
            const localVarPath = `/api/tenant/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantById
         * @param {string} tenantId tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByIdUsingGET(tenantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getTenantByIdUsingGET.');
            }
            const localVarPath = `/api/tenant/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantInfoById
         * @param {string} tenantId tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInfoByIdUsingGET(tenantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getTenantInfoByIdUsingGET.');
            }
            const localVarPath = `/api/tenant/info/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantInfos
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantInfosUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantInfosUsingGET.');
            }
            const localVarPath = `/api/tenantInfos{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantsByIds
         * @param {string} tenantIds tenantIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantsByIdsUsingGET(tenantIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantIds' is not null or undefined
            if (tenantIds === null || tenantIds === undefined) {
                throw new RequiredError('tenantIds','Required parameter tenantIds was null or undefined when calling getTenantsByIdsUsingGET.');
            }
            const localVarPath = `/api/tenants{?tenantIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (tenantIds !== undefined) {
                localVarQueryParameter['tenantIds'] = tenantIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenants
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantsUsingGET.');
            }
            const localVarPath = `/api/tenants{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveTenant
         * @param {Tenant} tenant tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTenantUsingPOST(tenant: Tenant, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling saveTenantUsingPOST.');
            }
            const localVarPath = `/api/tenant`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tenant" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tenant || {}) : (tenant || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantControllerApi - functional programming interface
 * @export
 */
export const TenantControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteTenant
         * @param {string} tenantId tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantUsingDELETE(tenantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TenantControllerApiFetchParamCreator(configuration).deleteTenantUsingDELETE(tenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantById
         * @param {string} tenantId tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByIdUsingGET(tenantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tenant> {
            const localVarFetchArgs = TenantControllerApiFetchParamCreator(configuration).getTenantByIdUsingGET(tenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantInfoById
         * @param {string} tenantId tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInfoByIdUsingGET(tenantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TenantInfo> {
            const localVarFetchArgs = TenantControllerApiFetchParamCreator(configuration).getTenantInfoByIdUsingGET(tenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantInfos
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataTenantInfo> {
            const localVarFetchArgs = TenantControllerApiFetchParamCreator(configuration).getTenantInfosUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantsByIds
         * @param {string} tenantIds tenantIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantsByIdsUsingGET(tenantIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tenant>> {
            const localVarFetchArgs = TenantControllerApiFetchParamCreator(configuration).getTenantsByIdsUsingGET(tenantIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenants
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataTenant> {
            const localVarFetchArgs = TenantControllerApiFetchParamCreator(configuration).getTenantsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveTenant
         * @param {Tenant} tenant tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTenantUsingPOST(tenant: Tenant, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tenant> {
            const localVarFetchArgs = TenantControllerApiFetchParamCreator(configuration).saveTenantUsingPOST(tenant, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TenantControllerApi - factory interface
 * @export
 */
export const TenantControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteTenant
         * @param {string} tenantId tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantUsingDELETE(tenantId: string, options?: any) {
            return TenantControllerApiFp(configuration).deleteTenantUsingDELETE(tenantId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantById
         * @param {string} tenantId tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByIdUsingGET(tenantId: string, options?: any) {
            return TenantControllerApiFp(configuration).getTenantByIdUsingGET(tenantId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantInfoById
         * @param {string} tenantId tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInfoByIdUsingGET(tenantId: string, options?: any) {
            return TenantControllerApiFp(configuration).getTenantInfoByIdUsingGET(tenantId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantInfos
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return TenantControllerApiFp(configuration).getTenantInfosUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantsByIds
         * @param {string} tenantIds tenantIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantsByIdsUsingGET(tenantIds: string, options?: any) {
            return TenantControllerApiFp(configuration).getTenantsByIdsUsingGET(tenantIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenants
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return TenantControllerApiFp(configuration).getTenantsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveTenant
         * @param {Tenant} tenant tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTenantUsingPOST(tenant: Tenant, options?: any) {
            return TenantControllerApiFp(configuration).saveTenantUsingPOST(tenant, options)(fetch, basePath);
        },
    };
};

/**
 * TenantControllerApi - object-oriented interface
 * @export
 * @class TenantControllerApi
 * @extends {BaseAPI}
 */
export class TenantControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteTenant
     * @param {string} tenantId tenantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantControllerApi
     */
    public deleteTenantUsingDELETE(tenantId: string, options?: any) {
        return TenantControllerApiFp(this.configuration).deleteTenantUsingDELETE(tenantId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantById
     * @param {string} tenantId tenantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantControllerApi
     */
    public getTenantByIdUsingGET(tenantId: string, options?: any) {
        return TenantControllerApiFp(this.configuration).getTenantByIdUsingGET(tenantId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantInfoById
     * @param {string} tenantId tenantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantControllerApi
     */
    public getTenantInfoByIdUsingGET(tenantId: string, options?: any) {
        return TenantControllerApiFp(this.configuration).getTenantInfoByIdUsingGET(tenantId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantInfos
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantControllerApi
     */
    public getTenantInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return TenantControllerApiFp(this.configuration).getTenantInfosUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantsByIds
     * @param {string} tenantIds tenantIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantControllerApi
     */
    public getTenantsByIdsUsingGET(tenantIds: string, options?: any) {
        return TenantControllerApiFp(this.configuration).getTenantsByIdsUsingGET(tenantIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenants
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantControllerApi
     */
    public getTenantsUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return TenantControllerApiFp(this.configuration).getTenantsUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveTenant
     * @param {Tenant} tenant tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantControllerApi
     */
    public saveTenantUsingPOST(tenant: Tenant, options?: any) {
        return TenantControllerApiFp(this.configuration).saveTenantUsingPOST(tenant, options)(this.fetch, this.basePath);
    }

}

/**
 * TenantProfileControllerApi - fetch parameter creator
 * @export
 */
export const TenantProfileControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteTenantProfile
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantProfileUsingDELETE(tenantProfileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantProfileId' is not null or undefined
            if (tenantProfileId === null || tenantProfileId === undefined) {
                throw new RequiredError('tenantProfileId','Required parameter tenantProfileId was null or undefined when calling deleteTenantProfileUsingDELETE.');
            }
            const localVarPath = `/api/tenantProfile/{tenantProfileId}`
                .replace(`{${"tenantProfileId"}}`, encodeURIComponent(String(tenantProfileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDefaultTenantProfileInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTenantProfileInfoUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/tenantProfileInfo/default`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantProfileById
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfileByIdUsingGET(tenantProfileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantProfileId' is not null or undefined
            if (tenantProfileId === null || tenantProfileId === undefined) {
                throw new RequiredError('tenantProfileId','Required parameter tenantProfileId was null or undefined when calling getTenantProfileByIdUsingGET.');
            }
            const localVarPath = `/api/tenantProfile/{tenantProfileId}`
                .replace(`{${"tenantProfileId"}}`, encodeURIComponent(String(tenantProfileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantProfileInfoById
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfileInfoByIdUsingGET(tenantProfileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantProfileId' is not null or undefined
            if (tenantProfileId === null || tenantProfileId === undefined) {
                throw new RequiredError('tenantProfileId','Required parameter tenantProfileId was null or undefined when calling getTenantProfileInfoByIdUsingGET.');
            }
            const localVarPath = `/api/tenantProfileInfo/{tenantProfileId}`
                .replace(`{${"tenantProfileId"}}`, encodeURIComponent(String(tenantProfileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantProfileInfos
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfileInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantProfileInfosUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantProfileInfosUsingGET.');
            }
            const localVarPath = `/api/tenantProfileInfos{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantProfiles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfilesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantProfilesUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantProfilesUsingGET.');
            }
            const localVarPath = `/api/tenantProfiles{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveTenantProfile
         * @param {TenantProfile} tenantProfile tenantProfile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTenantProfileUsingPOST(tenantProfile: TenantProfile, options: any = {}): FetchArgs {
            // verify required parameter 'tenantProfile' is not null or undefined
            if (tenantProfile === null || tenantProfile === undefined) {
                throw new RequiredError('tenantProfile','Required parameter tenantProfile was null or undefined when calling saveTenantProfileUsingPOST.');
            }
            const localVarPath = `/api/tenantProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TenantProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tenantProfile || {}) : (tenantProfile || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setDefaultTenantProfile
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultTenantProfileUsingPOST(tenantProfileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantProfileId' is not null or undefined
            if (tenantProfileId === null || tenantProfileId === undefined) {
                throw new RequiredError('tenantProfileId','Required parameter tenantProfileId was null or undefined when calling setDefaultTenantProfileUsingPOST.');
            }
            const localVarPath = `/api/tenantProfile/{tenantProfileId}/default`
                .replace(`{${"tenantProfileId"}}`, encodeURIComponent(String(tenantProfileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantProfileControllerApi - functional programming interface
 * @export
 */
export const TenantProfileControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteTenantProfile
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantProfileUsingDELETE(tenantProfileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TenantProfileControllerApiFetchParamCreator(configuration).deleteTenantProfileUsingDELETE(tenantProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDefaultTenantProfileInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTenantProfileInfoUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityInfo> {
            const localVarFetchArgs = TenantProfileControllerApiFetchParamCreator(configuration).getDefaultTenantProfileInfoUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantProfileById
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfileByIdUsingGET(tenantProfileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TenantProfile> {
            const localVarFetchArgs = TenantProfileControllerApiFetchParamCreator(configuration).getTenantProfileByIdUsingGET(tenantProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantProfileInfoById
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfileInfoByIdUsingGET(tenantProfileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntityInfo> {
            const localVarFetchArgs = TenantProfileControllerApiFetchParamCreator(configuration).getTenantProfileInfoByIdUsingGET(tenantProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantProfileInfos
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfileInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataEntityInfo> {
            const localVarFetchArgs = TenantProfileControllerApiFetchParamCreator(configuration).getTenantProfileInfosUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantProfiles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfilesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataTenantProfile> {
            const localVarFetchArgs = TenantProfileControllerApiFetchParamCreator(configuration).getTenantProfilesUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveTenantProfile
         * @param {TenantProfile} tenantProfile tenantProfile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTenantProfileUsingPOST(tenantProfile: TenantProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TenantProfile> {
            const localVarFetchArgs = TenantProfileControllerApiFetchParamCreator(configuration).saveTenantProfileUsingPOST(tenantProfile, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary setDefaultTenantProfile
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultTenantProfileUsingPOST(tenantProfileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TenantProfile> {
            const localVarFetchArgs = TenantProfileControllerApiFetchParamCreator(configuration).setDefaultTenantProfileUsingPOST(tenantProfileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TenantProfileControllerApi - factory interface
 * @export
 */
export const TenantProfileControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteTenantProfile
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantProfileUsingDELETE(tenantProfileId: string, options?: any) {
            return TenantProfileControllerApiFp(configuration).deleteTenantProfileUsingDELETE(tenantProfileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDefaultTenantProfileInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTenantProfileInfoUsingGET(options?: any) {
            return TenantProfileControllerApiFp(configuration).getDefaultTenantProfileInfoUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantProfileById
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfileByIdUsingGET(tenantProfileId: string, options?: any) {
            return TenantProfileControllerApiFp(configuration).getTenantProfileByIdUsingGET(tenantProfileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantProfileInfoById
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfileInfoByIdUsingGET(tenantProfileId: string, options?: any) {
            return TenantProfileControllerApiFp(configuration).getTenantProfileInfoByIdUsingGET(tenantProfileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantProfileInfos
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfileInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return TenantProfileControllerApiFp(configuration).getTenantProfileInfosUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantProfiles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantProfilesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return TenantProfileControllerApiFp(configuration).getTenantProfilesUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveTenantProfile
         * @param {TenantProfile} tenantProfile tenantProfile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTenantProfileUsingPOST(tenantProfile: TenantProfile, options?: any) {
            return TenantProfileControllerApiFp(configuration).saveTenantProfileUsingPOST(tenantProfile, options)(fetch, basePath);
        },
        /**
         * 
         * @summary setDefaultTenantProfile
         * @param {string} tenantProfileId tenantProfileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultTenantProfileUsingPOST(tenantProfileId: string, options?: any) {
            return TenantProfileControllerApiFp(configuration).setDefaultTenantProfileUsingPOST(tenantProfileId, options)(fetch, basePath);
        },
    };
};

/**
 * TenantProfileControllerApi - object-oriented interface
 * @export
 * @class TenantProfileControllerApi
 * @extends {BaseAPI}
 */
export class TenantProfileControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteTenantProfile
     * @param {string} tenantProfileId tenantProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantProfileControllerApi
     */
    public deleteTenantProfileUsingDELETE(tenantProfileId: string, options?: any) {
        return TenantProfileControllerApiFp(this.configuration).deleteTenantProfileUsingDELETE(tenantProfileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDefaultTenantProfileInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantProfileControllerApi
     */
    public getDefaultTenantProfileInfoUsingGET(options?: any) {
        return TenantProfileControllerApiFp(this.configuration).getDefaultTenantProfileInfoUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantProfileById
     * @param {string} tenantProfileId tenantProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantProfileControllerApi
     */
    public getTenantProfileByIdUsingGET(tenantProfileId: string, options?: any) {
        return TenantProfileControllerApiFp(this.configuration).getTenantProfileByIdUsingGET(tenantProfileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantProfileInfoById
     * @param {string} tenantProfileId tenantProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantProfileControllerApi
     */
    public getTenantProfileInfoByIdUsingGET(tenantProfileId: string, options?: any) {
        return TenantProfileControllerApiFp(this.configuration).getTenantProfileInfoByIdUsingGET(tenantProfileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantProfileInfos
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantProfileControllerApi
     */
    public getTenantProfileInfosUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return TenantProfileControllerApiFp(this.configuration).getTenantProfileInfosUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantProfiles
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantProfileControllerApi
     */
    public getTenantProfilesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return TenantProfileControllerApiFp(this.configuration).getTenantProfilesUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveTenantProfile
     * @param {TenantProfile} tenantProfile tenantProfile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantProfileControllerApi
     */
    public saveTenantProfileUsingPOST(tenantProfile: TenantProfile, options?: any) {
        return TenantProfileControllerApiFp(this.configuration).saveTenantProfileUsingPOST(tenantProfile, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary setDefaultTenantProfile
     * @param {string} tenantProfileId tenantProfileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantProfileControllerApi
     */
    public setDefaultTenantProfileUsingPOST(tenantProfileId: string, options?: any) {
        return TenantProfileControllerApiFp(this.configuration).setDefaultTenantProfileUsingPOST(tenantProfileId, options)(this.fetch, this.basePath);
    }

}

/**
 * ThingParkIntegrationControllerApi - fetch parameter creator
 * @export
 */
export const ThingParkIntegrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingDELETE(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestTPEUsingDELETE.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestTPEUsingDELETE.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestTPEUsingDELETE.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestTPEUsingDELETE.');
            }
            const localVarPath = `/api/v1/integrations/tpe/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingGET(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestTPEUsingGET.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestTPEUsingGET.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestTPEUsingGET.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestTPEUsingGET.');
            }
            const localVarPath = `/api/v1/integrations/tpe/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingHEAD(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestTPEUsingHEAD.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestTPEUsingHEAD.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestTPEUsingHEAD.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestTPEUsingHEAD.');
            }
            const localVarPath = `/api/v1/integrations/tpe/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingOPTIONS(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestTPEUsingOPTIONS.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestTPEUsingOPTIONS.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestTPEUsingOPTIONS.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestTPEUsingOPTIONS.');
            }
            const localVarPath = `/api/v1/integrations/tpe/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingPATCH(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestTPEUsingPATCH.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestTPEUsingPATCH.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestTPEUsingPATCH.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestTPEUsingPATCH.');
            }
            const localVarPath = `/api/v1/integrations/tpe/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingPOST(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestTPEUsingPOST.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestTPEUsingPOST.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestTPEUsingPOST.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestTPEUsingPOST.');
            }
            const localVarPath = `/api/v1/integrations/tpe/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingPUT(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestTPEUsingPUT.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestTPEUsingPUT.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestTPEUsingPUT.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestTPEUsingPUT.');
            }
            const localVarPath = `/api/v1/integrations/tpe/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingDELETE5.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestUsingDELETE5.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingDELETE5.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingDELETE5.');
            }
            const localVarPath = `/api/v1/integrations/thingpark/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingGET5.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestUsingGET5.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingGET5.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingGET5.');
            }
            const localVarPath = `/api/v1/integrations/thingpark/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingHEAD5.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestUsingHEAD5.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingHEAD5.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingHEAD5.');
            }
            const localVarPath = `/api/v1/integrations/thingpark/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingOPTIONS5.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestUsingOPTIONS5.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingOPTIONS5.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingOPTIONS5.');
            }
            const localVarPath = `/api/v1/integrations/thingpark/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPATCH5.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestUsingPATCH5.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPATCH5.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPATCH5.');
            }
            const localVarPath = `/api/v1/integrations/thingpark/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST11(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPOST11.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestUsingPOST11.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPOST11.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPOST11.');
            }
            const localVarPath = `/api/v1/integrations/thingpark/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options: any = {}): FetchArgs {
            // verify required parameter 'routingKey' is not null or undefined
            if (routingKey === null || routingKey === undefined) {
                throw new RequiredError('routingKey','Required parameter routingKey was null or undefined when calling processRequestUsingPUT5.');
            }
            // verify required parameter 'allRequestParams' is not null or undefined
            if (allRequestParams === null || allRequestParams === undefined) {
                throw new RequiredError('allRequestParams','Required parameter allRequestParams was null or undefined when calling processRequestUsingPUT5.');
            }
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling processRequestUsingPUT5.');
            }
            // verify required parameter 'requestHeaders' is not null or undefined
            if (requestHeaders === null || requestHeaders === undefined) {
                throw new RequiredError('requestHeaders','Required parameter requestHeaders was null or undefined when calling processRequestUsingPUT5.');
            }
            const localVarPath = `/api/v1/integrations/thingpark/{routingKey}{?allRequestParams}`
                .replace(`{${"routingKey"}}`, encodeURIComponent(String(routingKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (allRequestParams !== undefined) {
                localVarQueryParameter['allRequestParams'] = allRequestParams;
            }

            if (requestHeaders !== undefined && requestHeaders !== null) {
                localVarHeaderParameter['requestHeaders'] = String(requestHeaders);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThingParkIntegrationControllerApi - functional programming interface
 * @export
 */
export const ThingParkIntegrationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingDELETE(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestTPEUsingDELETE(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingGET(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestTPEUsingGET(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingHEAD(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestTPEUsingHEAD(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingOPTIONS(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestTPEUsingOPTIONS(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingPATCH(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestTPEUsingPATCH(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingPOST(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestTPEUsingPOST(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingPUT(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestTPEUsingPUT(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingDELETE5(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingGET5(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingHEAD5(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingOPTIONS5(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPATCH5(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST11(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPOST11(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeferredResultResponseEntity> {
            const localVarFetchArgs = ThingParkIntegrationControllerApiFetchParamCreator(configuration).processRequestUsingPUT5(routingKey, allRequestParams, msg, requestHeaders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ThingParkIntegrationControllerApi - factory interface
 * @export
 */
export const ThingParkIntegrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingDELETE(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestTPEUsingDELETE(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingGET(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestTPEUsingGET(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingHEAD(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestTPEUsingHEAD(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingOPTIONS(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestTPEUsingOPTIONS(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingPATCH(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestTPEUsingPATCH(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingPOST(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestTPEUsingPOST(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequestTPE
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestTPEUsingPUT(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestTPEUsingPUT(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingDELETE5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestUsingDELETE5(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingGET5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestUsingGET5(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingHEAD5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestUsingHEAD5(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingOPTIONS5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestUsingOPTIONS5(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPATCH5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestUsingPATCH5(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPOST11(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestUsingPOST11(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
        /**
         * 
         * @summary processRequest
         * @param {string} routingKey routingKey
         * @param {any} allRequestParams allRequestParams
         * @param {string} msg msg
         * @param {any} requestHeaders requestHeaders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequestUsingPUT5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
            return ThingParkIntegrationControllerApiFp(configuration).processRequestUsingPUT5(routingKey, allRequestParams, msg, requestHeaders, options)(fetch, basePath);
        },
    };
};

/**
 * ThingParkIntegrationControllerApi - object-oriented interface
 * @export
 * @class ThingParkIntegrationControllerApi
 * @extends {BaseAPI}
 */
export class ThingParkIntegrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary processRequestTPE
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestTPEUsingDELETE(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestTPEUsingDELETE(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequestTPE
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestTPEUsingGET(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestTPEUsingGET(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequestTPE
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestTPEUsingHEAD(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestTPEUsingHEAD(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequestTPE
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestTPEUsingOPTIONS(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestTPEUsingOPTIONS(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequestTPE
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestTPEUsingPATCH(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestTPEUsingPATCH(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequestTPE
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestTPEUsingPOST(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestTPEUsingPOST(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequestTPE
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestTPEUsingPUT(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestTPEUsingPUT(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestUsingDELETE5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestUsingDELETE5(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestUsingGET5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestUsingGET5(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestUsingHEAD5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestUsingHEAD5(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestUsingOPTIONS5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestUsingOPTIONS5(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestUsingPATCH5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestUsingPATCH5(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestUsingPOST11(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestUsingPOST11(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary processRequest
     * @param {string} routingKey routingKey
     * @param {any} allRequestParams allRequestParams
     * @param {string} msg msg
     * @param {any} requestHeaders requestHeaders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThingParkIntegrationControllerApi
     */
    public processRequestUsingPUT5(routingKey: string, allRequestParams: any, msg: string, requestHeaders: any, options?: any) {
        return ThingParkIntegrationControllerApiFp(this.configuration).processRequestUsingPUT5(routingKey, allRequestParams, msg, requestHeaders, options)(this.fetch, this.basePath);
    }

}

/**
 * UserControllerApi - fetch parameter creator
 * @export
 */
export const UserControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteUser
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserUsingDELETE.');
            }
            const localVarPath = `/api/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getActivationLink
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivationLinkUsingGET(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getActivationLinkUsingGET.');
            }
            const localVarPath = `/api/user/{userId}/activationLink`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllCustomerUsers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomerUsersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getAllCustomerUsersUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAllCustomerUsersUsingGET.');
            }
            const localVarPath = `/api/customer/users{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCustomerUsers
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerUsersUsingGET(customerId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomerUsersUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getCustomerUsersUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getCustomerUsersUsingGET.');
            }
            const localVarPath = `/api/customer/{customerId}/users{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTenantAdmins
         * @param {string} tenantId tenantId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAdminsUsingGET(tenantId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getTenantAdminsUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getTenantAdminsUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getTenantAdminsUsingGET.');
            }
            const localVarPath = `/api/tenant/{tenantId}/users{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserById
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdUsingGET(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserByIdUsingGET.');
            }
            const localVarPath = `/api/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserToken
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenUsingGET(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserTokenUsingGET.');
            }
            const localVarPath = `/api/user/{userId}/token`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserUsers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getUserUsersUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserUsersUsingGET.');
            }
            const localVarPath = `/api/user/users{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUsersByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'entityGroupId' is not null or undefined
            if (entityGroupId === null || entityGroupId === undefined) {
                throw new RequiredError('entityGroupId','Required parameter entityGroupId was null or undefined when calling getUsersByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getUsersByEntityGroupIdUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUsersByEntityGroupIdUsingGET.');
            }
            const localVarPath = `/api/entityGroup/{entityGroupId}/users{?textSearch,sortProperty,sortOrder,pageSize,page}`
                .replace(`{${"entityGroupId"}}`, encodeURIComponent(String(entityGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUsersByIds
         * @param {string} userIds userIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdsUsingGET(userIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'userIds' is not null or undefined
            if (userIds === null || userIds === undefined) {
                throw new RequiredError('userIds','Required parameter userIds was null or undefined when calling getUsersByIdsUsingGET.');
            }
            const localVarPath = `/api/users{?userIds}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (userIds !== undefined) {
                localVarQueryParameter['userIds'] = userIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary isUserTokenAccessEnabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserTokenAccessEnabledUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/user/tokenAccessEnabled`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveUser
         * @param {User} user user
         * @param {boolean} [sendActivationMail] sendActivationMail
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUserUsingPOST(user: User, sendActivationMail?: boolean, entityGroupId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling saveUserUsingPOST.');
            }
            const localVarPath = `/api/user{?sendActivationMail,entityGroupId}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (sendActivationMail !== undefined) {
                localVarQueryParameter['sendActivationMail'] = sendActivationMail;
            }

            if (entityGroupId !== undefined) {
                localVarQueryParameter['entityGroupId'] = entityGroupId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sendActivationEmail
         * @param {string} email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendActivationEmailUsingPOST(email: string, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling sendActivationEmailUsingPOST.');
            }
            const localVarPath = `/api/user/sendActivationMail{?email}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setUserCredentialsEnabled
         * @param {string} userId userId
         * @param {boolean} [userCredentialsEnabled] userCredentialsEnabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserCredentialsEnabledUsingPOST(userId: string, userCredentialsEnabled?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setUserCredentialsEnabledUsingPOST.');
            }
            const localVarPath = `/api/user/{userId}/userCredentialsEnabled{?userCredentialsEnabled}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (userCredentialsEnabled !== undefined) {
                localVarQueryParameter['userCredentialsEnabled'] = userCredentialsEnabled;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteUser
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).deleteUserUsingDELETE(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getActivationLink
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivationLinkUsingGET(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getActivationLinkUsingGET(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllCustomerUsers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomerUsersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataUser> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getAllCustomerUsersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCustomerUsers
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerUsersUsingGET(customerId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataUser> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getCustomerUsersUsingGET(customerId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTenantAdmins
         * @param {string} tenantId tenantId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAdminsUsingGET(tenantId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataUser> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getTenantAdminsUsingGET(tenantId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserById
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdUsingGET(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUserByIdUsingGET(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserToken
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenUsingGET(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUserTokenUsingGET(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserUsers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataUser> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUserUsersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUsersByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataUser> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUsersByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUsersByIds
         * @param {string} userIds userIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdsUsingGET(userIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUsersByIdsUsingGET(userIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary isUserTokenAccessEnabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserTokenAccessEnabledUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).isUserTokenAccessEnabledUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveUser
         * @param {User} user user
         * @param {boolean} [sendActivationMail] sendActivationMail
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUserUsingPOST(user: User, sendActivationMail?: boolean, entityGroupId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).saveUserUsingPOST(user, sendActivationMail, entityGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary sendActivationEmail
         * @param {string} email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendActivationEmailUsingPOST(email: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).sendActivationEmailUsingPOST(email, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary setUserCredentialsEnabled
         * @param {string} userId userId
         * @param {boolean} [userCredentialsEnabled] userCredentialsEnabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserCredentialsEnabledUsingPOST(userId: string, userCredentialsEnabled?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).setUserCredentialsEnabledUsingPOST(userId, userCredentialsEnabled, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteUser
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE(userId: string, options?: any) {
            return UserControllerApiFp(configuration).deleteUserUsingDELETE(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getActivationLink
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivationLinkUsingGET(userId: string, options?: any) {
            return UserControllerApiFp(configuration).getActivationLinkUsingGET(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllCustomerUsers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomerUsersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return UserControllerApiFp(configuration).getAllCustomerUsersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCustomerUsers
         * @param {string} customerId customerId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerUsersUsingGET(customerId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return UserControllerApiFp(configuration).getCustomerUsersUsingGET(customerId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTenantAdmins
         * @param {string} tenantId tenantId
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAdminsUsingGET(tenantId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return UserControllerApiFp(configuration).getTenantAdminsUsingGET(tenantId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserById
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdUsingGET(userId: string, options?: any) {
            return UserControllerApiFp(configuration).getUserByIdUsingGET(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserToken
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenUsingGET(userId: string, options?: any) {
            return UserControllerApiFp(configuration).getUserTokenUsingGET(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserUsers
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return UserControllerApiFp(configuration).getUserUsersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUsersByEntityGroupId
         * @param {string} entityGroupId entityGroupId
         * @param {string} pageSize Page size
         * @param {string} page Page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return UserControllerApiFp(configuration).getUsersByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUsersByIds
         * @param {string} userIds userIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdsUsingGET(userIds: string, options?: any) {
            return UserControllerApiFp(configuration).getUsersByIdsUsingGET(userIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary isUserTokenAccessEnabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserTokenAccessEnabledUsingGET(options?: any) {
            return UserControllerApiFp(configuration).isUserTokenAccessEnabledUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveUser
         * @param {User} user user
         * @param {boolean} [sendActivationMail] sendActivationMail
         * @param {string} [entityGroupId] entityGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUserUsingPOST(user: User, sendActivationMail?: boolean, entityGroupId?: string, options?: any) {
            return UserControllerApiFp(configuration).saveUserUsingPOST(user, sendActivationMail, entityGroupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary sendActivationEmail
         * @param {string} email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendActivationEmailUsingPOST(email: string, options?: any) {
            return UserControllerApiFp(configuration).sendActivationEmailUsingPOST(email, options)(fetch, basePath);
        },
        /**
         * 
         * @summary setUserCredentialsEnabled
         * @param {string} userId userId
         * @param {boolean} [userCredentialsEnabled] userCredentialsEnabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserCredentialsEnabledUsingPOST(userId: string, userCredentialsEnabled?: boolean, options?: any) {
            return UserControllerApiFp(configuration).setUserCredentialsEnabledUsingPOST(userId, userCredentialsEnabled, options)(fetch, basePath);
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteUser
     * @param {string} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public deleteUserUsingDELETE(userId: string, options?: any) {
        return UserControllerApiFp(this.configuration).deleteUserUsingDELETE(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getActivationLink
     * @param {string} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getActivationLinkUsingGET(userId: string, options?: any) {
        return UserControllerApiFp(this.configuration).getActivationLinkUsingGET(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllCustomerUsers
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getAllCustomerUsersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return UserControllerApiFp(this.configuration).getAllCustomerUsersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCustomerUsers
     * @param {string} customerId customerId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getCustomerUsersUsingGET(customerId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return UserControllerApiFp(this.configuration).getCustomerUsersUsingGET(customerId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTenantAdmins
     * @param {string} tenantId tenantId
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getTenantAdminsUsingGET(tenantId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return UserControllerApiFp(this.configuration).getTenantAdminsUsingGET(tenantId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserById
     * @param {string} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserByIdUsingGET(userId: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUserByIdUsingGET(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserToken
     * @param {string} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserTokenUsingGET(userId: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUserTokenUsingGET(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserUsers
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserUsersUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUserUsersUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUsersByEntityGroupId
     * @param {string} entityGroupId entityGroupId
     * @param {string} pageSize Page size
     * @param {string} page Page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUsersByEntityGroupIdUsingGET(entityGroupId: string, pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUsersByEntityGroupIdUsingGET(entityGroupId, pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUsersByIds
     * @param {string} userIds userIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUsersByIdsUsingGET(userIds: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUsersByIdsUsingGET(userIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary isUserTokenAccessEnabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public isUserTokenAccessEnabledUsingGET(options?: any) {
        return UserControllerApiFp(this.configuration).isUserTokenAccessEnabledUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveUser
     * @param {User} user user
     * @param {boolean} [sendActivationMail] sendActivationMail
     * @param {string} [entityGroupId] entityGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public saveUserUsingPOST(user: User, sendActivationMail?: boolean, entityGroupId?: string, options?: any) {
        return UserControllerApiFp(this.configuration).saveUserUsingPOST(user, sendActivationMail, entityGroupId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary sendActivationEmail
     * @param {string} email email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public sendActivationEmailUsingPOST(email: string, options?: any) {
        return UserControllerApiFp(this.configuration).sendActivationEmailUsingPOST(email, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary setUserCredentialsEnabled
     * @param {string} userId userId
     * @param {boolean} [userCredentialsEnabled] userCredentialsEnabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public setUserCredentialsEnabledUsingPOST(userId: string, userCredentialsEnabled?: boolean, options?: any) {
        return UserControllerApiFp(this.configuration).setUserCredentialsEnabledUsingPOST(userId, userCredentialsEnabled, options)(this.fetch, this.basePath);
    }

}

/**
 * UserPermissionsControllerApi - fetch parameter creator
 * @export
 */
export const UserPermissionsControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllowedPermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedPermissionsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/permissions/allowedPermissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPermissionsControllerApi - functional programming interface
 * @export
 */
export const UserPermissionsControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllowedPermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedPermissionsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllowedPermissionsInfo> {
            const localVarFetchArgs = UserPermissionsControllerApiFetchParamCreator(configuration).getAllowedPermissionsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserPermissionsControllerApi - factory interface
 * @export
 */
export const UserPermissionsControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getAllowedPermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedPermissionsUsingGET(options?: any) {
            return UserPermissionsControllerApiFp(configuration).getAllowedPermissionsUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * UserPermissionsControllerApi - object-oriented interface
 * @export
 * @class UserPermissionsControllerApi
 * @extends {BaseAPI}
 */
export class UserPermissionsControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAllowedPermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPermissionsControllerApi
     */
    public getAllowedPermissionsUsingGET(options?: any) {
        return UserPermissionsControllerApiFp(this.configuration).getAllowedPermissionsUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * WhiteLabelingControllerApi - fetch parameter creator
 * @export
 */
export const WhiteLabelingControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAppThemeCss
         * @param {PaletteSettings} paletteSettings paletteSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppThemeCssUsingPOST(paletteSettings: PaletteSettings, options: any = {}): FetchArgs {
            // verify required parameter 'paletteSettings' is not null or undefined
            if (paletteSettings === null || paletteSettings === undefined) {
                throw new RequiredError('paletteSettings','Required parameter paletteSettings was null or undefined when calling getAppThemeCssUsingPOST.');
            }
            const localVarPath = `/api/whiteLabel/appThemeCss`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaletteSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(paletteSettings || {}) : (paletteSettings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCurrentLoginWhiteLabelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentLoginWhiteLabelParamsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/whiteLabel/currentLoginWhiteLabelParams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCurrentWhiteLabelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentWhiteLabelParamsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/whiteLabel/currentWhiteLabelParams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getLoginThemeCss
         * @param {PaletteSettings} paletteSettings paletteSettings
         * @param {boolean} [darkForeground] darkForeground
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginThemeCssUsingPOST(paletteSettings: PaletteSettings, darkForeground?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'paletteSettings' is not null or undefined
            if (paletteSettings === null || paletteSettings === undefined) {
                throw new RequiredError('paletteSettings','Required parameter paletteSettings was null or undefined when calling getLoginThemeCssUsingPOST.');
            }
            const localVarPath = `/api/noauth/whiteLabel/loginThemeCss{?darkForeground}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (darkForeground !== undefined) {
                localVarQueryParameter['darkForeground'] = darkForeground;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaletteSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(paletteSettings || {}) : (paletteSettings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getLoginWhiteLabelParams
         * @param {string} [logoImageChecksum] logoImageChecksum
         * @param {string} [faviconChecksum] faviconChecksum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginWhiteLabelParamsUsingGET(logoImageChecksum?: string, faviconChecksum?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/noauth/whiteLabel/loginWhiteLabelParams{?logoImageChecksum,faviconChecksum}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (logoImageChecksum !== undefined) {
                localVarQueryParameter['logoImageChecksum'] = logoImageChecksum;
            }

            if (faviconChecksum !== undefined) {
                localVarQueryParameter['faviconChecksum'] = faviconChecksum;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWhiteLabelParams
         * @param {string} [logoImageChecksum] logoImageChecksum
         * @param {string} [faviconChecksum] faviconChecksum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhiteLabelParamsUsingGET(logoImageChecksum?: string, faviconChecksum?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/whiteLabel/whiteLabelParams{?logoImageChecksum,faviconChecksum}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (logoImageChecksum !== undefined) {
                localVarQueryParameter['logoImageChecksum'] = logoImageChecksum;
            }

            if (faviconChecksum !== undefined) {
                localVarQueryParameter['faviconChecksum'] = faviconChecksum;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary isCustomerWhiteLabelingAllowed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isCustomerWhiteLabelingAllowedUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/whiteLabel/isCustomerWhiteLabelingAllowed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary isWhiteLabelingAllowed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isWhiteLabelingAllowedUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/whiteLabel/isWhiteLabelingAllowed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary previewWhiteLabelParams
         * @param {WhiteLabelingParams} whiteLabelingParams whiteLabelingParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewWhiteLabelParamsUsingPOST(whiteLabelingParams: WhiteLabelingParams, options: any = {}): FetchArgs {
            // verify required parameter 'whiteLabelingParams' is not null or undefined
            if (whiteLabelingParams === null || whiteLabelingParams === undefined) {
                throw new RequiredError('whiteLabelingParams','Required parameter whiteLabelingParams was null or undefined when calling previewWhiteLabelParamsUsingPOST.');
            }
            const localVarPath = `/api/whiteLabel/previewWhiteLabelParams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WhiteLabelingParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(whiteLabelingParams || {}) : (whiteLabelingParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveLoginWhiteLabelParams
         * @param {LoginWhiteLabelingParams} loginWhiteLabelingParams loginWhiteLabelingParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLoginWhiteLabelParamsUsingPOST(loginWhiteLabelingParams: LoginWhiteLabelingParams, options: any = {}): FetchArgs {
            // verify required parameter 'loginWhiteLabelingParams' is not null or undefined
            if (loginWhiteLabelingParams === null || loginWhiteLabelingParams === undefined) {
                throw new RequiredError('loginWhiteLabelingParams','Required parameter loginWhiteLabelingParams was null or undefined when calling saveLoginWhiteLabelParamsUsingPOST.');
            }
            const localVarPath = `/api/whiteLabel/loginWhiteLabelParams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginWhiteLabelingParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(loginWhiteLabelingParams || {}) : (loginWhiteLabelingParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveWhiteLabelParams
         * @param {WhiteLabelingParams} whiteLabelingParams whiteLabelingParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWhiteLabelParamsUsingPOST(whiteLabelingParams: WhiteLabelingParams, options: any = {}): FetchArgs {
            // verify required parameter 'whiteLabelingParams' is not null or undefined
            if (whiteLabelingParams === null || whiteLabelingParams === undefined) {
                throw new RequiredError('whiteLabelingParams','Required parameter whiteLabelingParams was null or undefined when calling saveWhiteLabelParamsUsingPOST.');
            }
            const localVarPath = `/api/whiteLabel/whiteLabelParams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WhiteLabelingParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(whiteLabelingParams || {}) : (whiteLabelingParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WhiteLabelingControllerApi - functional programming interface
 * @export
 */
export const WhiteLabelingControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAppThemeCss
         * @param {PaletteSettings} paletteSettings paletteSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppThemeCssUsingPOST(paletteSettings: PaletteSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).getAppThemeCssUsingPOST(paletteSettings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCurrentLoginWhiteLabelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentLoginWhiteLabelParamsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginWhiteLabelingParams> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).getCurrentLoginWhiteLabelParamsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCurrentWhiteLabelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentWhiteLabelParamsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WhiteLabelingParams> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).getCurrentWhiteLabelParamsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getLoginThemeCss
         * @param {PaletteSettings} paletteSettings paletteSettings
         * @param {boolean} [darkForeground] darkForeground
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginThemeCssUsingPOST(paletteSettings: PaletteSettings, darkForeground?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).getLoginThemeCssUsingPOST(paletteSettings, darkForeground, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getLoginWhiteLabelParams
         * @param {string} [logoImageChecksum] logoImageChecksum
         * @param {string} [faviconChecksum] faviconChecksum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginWhiteLabelParamsUsingGET(logoImageChecksum?: string, faviconChecksum?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginWhiteLabelingParams> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).getLoginWhiteLabelParamsUsingGET(logoImageChecksum, faviconChecksum, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getWhiteLabelParams
         * @param {string} [logoImageChecksum] logoImageChecksum
         * @param {string} [faviconChecksum] faviconChecksum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhiteLabelParamsUsingGET(logoImageChecksum?: string, faviconChecksum?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WhiteLabelingParams> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).getWhiteLabelParamsUsingGET(logoImageChecksum, faviconChecksum, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary isCustomerWhiteLabelingAllowed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isCustomerWhiteLabelingAllowedUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).isCustomerWhiteLabelingAllowedUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary isWhiteLabelingAllowed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isWhiteLabelingAllowedUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).isWhiteLabelingAllowedUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary previewWhiteLabelParams
         * @param {WhiteLabelingParams} whiteLabelingParams whiteLabelingParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewWhiteLabelParamsUsingPOST(whiteLabelingParams: WhiteLabelingParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WhiteLabelingParams> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).previewWhiteLabelParamsUsingPOST(whiteLabelingParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveLoginWhiteLabelParams
         * @param {LoginWhiteLabelingParams} loginWhiteLabelingParams loginWhiteLabelingParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLoginWhiteLabelParamsUsingPOST(loginWhiteLabelingParams: LoginWhiteLabelingParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginWhiteLabelingParams> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).saveLoginWhiteLabelParamsUsingPOST(loginWhiteLabelingParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveWhiteLabelParams
         * @param {WhiteLabelingParams} whiteLabelingParams whiteLabelingParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWhiteLabelParamsUsingPOST(whiteLabelingParams: WhiteLabelingParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WhiteLabelingParams> {
            const localVarFetchArgs = WhiteLabelingControllerApiFetchParamCreator(configuration).saveWhiteLabelParamsUsingPOST(whiteLabelingParams, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WhiteLabelingControllerApi - factory interface
 * @export
 */
export const WhiteLabelingControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getAppThemeCss
         * @param {PaletteSettings} paletteSettings paletteSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppThemeCssUsingPOST(paletteSettings: PaletteSettings, options?: any) {
            return WhiteLabelingControllerApiFp(configuration).getAppThemeCssUsingPOST(paletteSettings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCurrentLoginWhiteLabelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentLoginWhiteLabelParamsUsingGET(options?: any) {
            return WhiteLabelingControllerApiFp(configuration).getCurrentLoginWhiteLabelParamsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCurrentWhiteLabelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentWhiteLabelParamsUsingGET(options?: any) {
            return WhiteLabelingControllerApiFp(configuration).getCurrentWhiteLabelParamsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getLoginThemeCss
         * @param {PaletteSettings} paletteSettings paletteSettings
         * @param {boolean} [darkForeground] darkForeground
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginThemeCssUsingPOST(paletteSettings: PaletteSettings, darkForeground?: boolean, options?: any) {
            return WhiteLabelingControllerApiFp(configuration).getLoginThemeCssUsingPOST(paletteSettings, darkForeground, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getLoginWhiteLabelParams
         * @param {string} [logoImageChecksum] logoImageChecksum
         * @param {string} [faviconChecksum] faviconChecksum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginWhiteLabelParamsUsingGET(logoImageChecksum?: string, faviconChecksum?: string, options?: any) {
            return WhiteLabelingControllerApiFp(configuration).getLoginWhiteLabelParamsUsingGET(logoImageChecksum, faviconChecksum, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getWhiteLabelParams
         * @param {string} [logoImageChecksum] logoImageChecksum
         * @param {string} [faviconChecksum] faviconChecksum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhiteLabelParamsUsingGET(logoImageChecksum?: string, faviconChecksum?: string, options?: any) {
            return WhiteLabelingControllerApiFp(configuration).getWhiteLabelParamsUsingGET(logoImageChecksum, faviconChecksum, options)(fetch, basePath);
        },
        /**
         * 
         * @summary isCustomerWhiteLabelingAllowed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isCustomerWhiteLabelingAllowedUsingGET(options?: any) {
            return WhiteLabelingControllerApiFp(configuration).isCustomerWhiteLabelingAllowedUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary isWhiteLabelingAllowed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isWhiteLabelingAllowedUsingGET(options?: any) {
            return WhiteLabelingControllerApiFp(configuration).isWhiteLabelingAllowedUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary previewWhiteLabelParams
         * @param {WhiteLabelingParams} whiteLabelingParams whiteLabelingParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewWhiteLabelParamsUsingPOST(whiteLabelingParams: WhiteLabelingParams, options?: any) {
            return WhiteLabelingControllerApiFp(configuration).previewWhiteLabelParamsUsingPOST(whiteLabelingParams, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveLoginWhiteLabelParams
         * @param {LoginWhiteLabelingParams} loginWhiteLabelingParams loginWhiteLabelingParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLoginWhiteLabelParamsUsingPOST(loginWhiteLabelingParams: LoginWhiteLabelingParams, options?: any) {
            return WhiteLabelingControllerApiFp(configuration).saveLoginWhiteLabelParamsUsingPOST(loginWhiteLabelingParams, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveWhiteLabelParams
         * @param {WhiteLabelingParams} whiteLabelingParams whiteLabelingParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWhiteLabelParamsUsingPOST(whiteLabelingParams: WhiteLabelingParams, options?: any) {
            return WhiteLabelingControllerApiFp(configuration).saveWhiteLabelParamsUsingPOST(whiteLabelingParams, options)(fetch, basePath);
        },
    };
};

/**
 * WhiteLabelingControllerApi - object-oriented interface
 * @export
 * @class WhiteLabelingControllerApi
 * @extends {BaseAPI}
 */
export class WhiteLabelingControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAppThemeCss
     * @param {PaletteSettings} paletteSettings paletteSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public getAppThemeCssUsingPOST(paletteSettings: PaletteSettings, options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).getAppThemeCssUsingPOST(paletteSettings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCurrentLoginWhiteLabelParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public getCurrentLoginWhiteLabelParamsUsingGET(options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).getCurrentLoginWhiteLabelParamsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCurrentWhiteLabelParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public getCurrentWhiteLabelParamsUsingGET(options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).getCurrentWhiteLabelParamsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getLoginThemeCss
     * @param {PaletteSettings} paletteSettings paletteSettings
     * @param {boolean} [darkForeground] darkForeground
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public getLoginThemeCssUsingPOST(paletteSettings: PaletteSettings, darkForeground?: boolean, options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).getLoginThemeCssUsingPOST(paletteSettings, darkForeground, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getLoginWhiteLabelParams
     * @param {string} [logoImageChecksum] logoImageChecksum
     * @param {string} [faviconChecksum] faviconChecksum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public getLoginWhiteLabelParamsUsingGET(logoImageChecksum?: string, faviconChecksum?: string, options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).getLoginWhiteLabelParamsUsingGET(logoImageChecksum, faviconChecksum, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getWhiteLabelParams
     * @param {string} [logoImageChecksum] logoImageChecksum
     * @param {string} [faviconChecksum] faviconChecksum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public getWhiteLabelParamsUsingGET(logoImageChecksum?: string, faviconChecksum?: string, options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).getWhiteLabelParamsUsingGET(logoImageChecksum, faviconChecksum, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary isCustomerWhiteLabelingAllowed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public isCustomerWhiteLabelingAllowedUsingGET(options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).isCustomerWhiteLabelingAllowedUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary isWhiteLabelingAllowed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public isWhiteLabelingAllowedUsingGET(options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).isWhiteLabelingAllowedUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary previewWhiteLabelParams
     * @param {WhiteLabelingParams} whiteLabelingParams whiteLabelingParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public previewWhiteLabelParamsUsingPOST(whiteLabelingParams: WhiteLabelingParams, options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).previewWhiteLabelParamsUsingPOST(whiteLabelingParams, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveLoginWhiteLabelParams
     * @param {LoginWhiteLabelingParams} loginWhiteLabelingParams loginWhiteLabelingParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public saveLoginWhiteLabelParamsUsingPOST(loginWhiteLabelingParams: LoginWhiteLabelingParams, options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).saveLoginWhiteLabelParamsUsingPOST(loginWhiteLabelingParams, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveWhiteLabelParams
     * @param {WhiteLabelingParams} whiteLabelingParams whiteLabelingParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhiteLabelingControllerApi
     */
    public saveWhiteLabelParamsUsingPOST(whiteLabelingParams: WhiteLabelingParams, options?: any) {
        return WhiteLabelingControllerApiFp(this.configuration).saveWhiteLabelParamsUsingPOST(whiteLabelingParams, options)(this.fetch, this.basePath);
    }

}

/**
 * WidgetTypeControllerApi - fetch parameter creator
 * @export
 */
export const WidgetTypeControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteWidgetType
         * @param {string} widgetTypeId widgetTypeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWidgetTypeUsingDELETE(widgetTypeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'widgetTypeId' is not null or undefined
            if (widgetTypeId === null || widgetTypeId === undefined) {
                throw new RequiredError('widgetTypeId','Required parameter widgetTypeId was null or undefined when calling deleteWidgetTypeUsingDELETE.');
            }
            const localVarPath = `/api/widgetType/{widgetTypeId}`
                .replace(`{${"widgetTypeId"}}`, encodeURIComponent(String(widgetTypeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBundleWidgetTypesDetails
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleWidgetTypesDetailsUsingGET(isSystem: string, bundleAlias: string, options: any = {}): FetchArgs {
            // verify required parameter 'isSystem' is not null or undefined
            if (isSystem === null || isSystem === undefined) {
                throw new RequiredError('isSystem','Required parameter isSystem was null or undefined when calling getBundleWidgetTypesDetailsUsingGET.');
            }
            // verify required parameter 'bundleAlias' is not null or undefined
            if (bundleAlias === null || bundleAlias === undefined) {
                throw new RequiredError('bundleAlias','Required parameter bundleAlias was null or undefined when calling getBundleWidgetTypesDetailsUsingGET.');
            }
            const localVarPath = `/api/widgetTypesDetails{?isSystem,bundleAlias}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (isSystem !== undefined) {
                localVarQueryParameter['isSystem'] = isSystem;
            }

            if (bundleAlias !== undefined) {
                localVarQueryParameter['bundleAlias'] = bundleAlias;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBundleWidgetTypesInfos
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleWidgetTypesInfosUsingGET(isSystem: string, bundleAlias: string, options: any = {}): FetchArgs {
            // verify required parameter 'isSystem' is not null or undefined
            if (isSystem === null || isSystem === undefined) {
                throw new RequiredError('isSystem','Required parameter isSystem was null or undefined when calling getBundleWidgetTypesInfosUsingGET.');
            }
            // verify required parameter 'bundleAlias' is not null or undefined
            if (bundleAlias === null || bundleAlias === undefined) {
                throw new RequiredError('bundleAlias','Required parameter bundleAlias was null or undefined when calling getBundleWidgetTypesInfosUsingGET.');
            }
            const localVarPath = `/api/widgetTypesInfos{?isSystem,bundleAlias}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (isSystem !== undefined) {
                localVarQueryParameter['isSystem'] = isSystem;
            }

            if (bundleAlias !== undefined) {
                localVarQueryParameter['bundleAlias'] = bundleAlias;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBundleWidgetTypes
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleWidgetTypesUsingGET(isSystem: string, bundleAlias: string, options: any = {}): FetchArgs {
            // verify required parameter 'isSystem' is not null or undefined
            if (isSystem === null || isSystem === undefined) {
                throw new RequiredError('isSystem','Required parameter isSystem was null or undefined when calling getBundleWidgetTypesUsingGET.');
            }
            // verify required parameter 'bundleAlias' is not null or undefined
            if (bundleAlias === null || bundleAlias === undefined) {
                throw new RequiredError('bundleAlias','Required parameter bundleAlias was null or undefined when calling getBundleWidgetTypesUsingGET.');
            }
            const localVarPath = `/api/widgetTypes{?isSystem,bundleAlias}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (isSystem !== undefined) {
                localVarQueryParameter['isSystem'] = isSystem;
            }

            if (bundleAlias !== undefined) {
                localVarQueryParameter['bundleAlias'] = bundleAlias;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWidgetTypeById
         * @param {string} widgetTypeId widgetTypeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetTypeByIdUsingGET(widgetTypeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'widgetTypeId' is not null or undefined
            if (widgetTypeId === null || widgetTypeId === undefined) {
                throw new RequiredError('widgetTypeId','Required parameter widgetTypeId was null or undefined when calling getWidgetTypeByIdUsingGET.');
            }
            const localVarPath = `/api/widgetType/{widgetTypeId}`
                .replace(`{${"widgetTypeId"}}`, encodeURIComponent(String(widgetTypeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWidgetType
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {string} alias alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetTypeUsingGET(isSystem: string, bundleAlias: string, alias: string, options: any = {}): FetchArgs {
            // verify required parameter 'isSystem' is not null or undefined
            if (isSystem === null || isSystem === undefined) {
                throw new RequiredError('isSystem','Required parameter isSystem was null or undefined when calling getWidgetTypeUsingGET.');
            }
            // verify required parameter 'bundleAlias' is not null or undefined
            if (bundleAlias === null || bundleAlias === undefined) {
                throw new RequiredError('bundleAlias','Required parameter bundleAlias was null or undefined when calling getWidgetTypeUsingGET.');
            }
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling getWidgetTypeUsingGET.');
            }
            const localVarPath = `/api/widgetType{?isSystem,bundleAlias,alias}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (isSystem !== undefined) {
                localVarQueryParameter['isSystem'] = isSystem;
            }

            if (bundleAlias !== undefined) {
                localVarQueryParameter['bundleAlias'] = bundleAlias;
            }

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = alias;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveWidgetType
         * @param {WidgetTypeDetails} widgetTypeDetails widgetTypeDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWidgetTypeUsingPOST(widgetTypeDetails: WidgetTypeDetails, options: any = {}): FetchArgs {
            // verify required parameter 'widgetTypeDetails' is not null or undefined
            if (widgetTypeDetails === null || widgetTypeDetails === undefined) {
                throw new RequiredError('widgetTypeDetails','Required parameter widgetTypeDetails was null or undefined when calling saveWidgetTypeUsingPOST.');
            }
            const localVarPath = `/api/widgetType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WidgetTypeDetails" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(widgetTypeDetails || {}) : (widgetTypeDetails || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WidgetTypeControllerApi - functional programming interface
 * @export
 */
export const WidgetTypeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteWidgetType
         * @param {string} widgetTypeId widgetTypeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWidgetTypeUsingDELETE(widgetTypeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WidgetTypeControllerApiFetchParamCreator(configuration).deleteWidgetTypeUsingDELETE(widgetTypeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getBundleWidgetTypesDetails
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleWidgetTypesDetailsUsingGET(isSystem: string, bundleAlias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WidgetTypeDetails>> {
            const localVarFetchArgs = WidgetTypeControllerApiFetchParamCreator(configuration).getBundleWidgetTypesDetailsUsingGET(isSystem, bundleAlias, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getBundleWidgetTypesInfos
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleWidgetTypesInfosUsingGET(isSystem: string, bundleAlias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WidgetTypeInfo>> {
            const localVarFetchArgs = WidgetTypeControllerApiFetchParamCreator(configuration).getBundleWidgetTypesInfosUsingGET(isSystem, bundleAlias, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getBundleWidgetTypes
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleWidgetTypesUsingGET(isSystem: string, bundleAlias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WidgetType>> {
            const localVarFetchArgs = WidgetTypeControllerApiFetchParamCreator(configuration).getBundleWidgetTypesUsingGET(isSystem, bundleAlias, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getWidgetTypeById
         * @param {string} widgetTypeId widgetTypeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetTypeByIdUsingGET(widgetTypeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WidgetTypeDetails> {
            const localVarFetchArgs = WidgetTypeControllerApiFetchParamCreator(configuration).getWidgetTypeByIdUsingGET(widgetTypeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getWidgetType
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {string} alias alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetTypeUsingGET(isSystem: string, bundleAlias: string, alias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WidgetType> {
            const localVarFetchArgs = WidgetTypeControllerApiFetchParamCreator(configuration).getWidgetTypeUsingGET(isSystem, bundleAlias, alias, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveWidgetType
         * @param {WidgetTypeDetails} widgetTypeDetails widgetTypeDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWidgetTypeUsingPOST(widgetTypeDetails: WidgetTypeDetails, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WidgetTypeDetails> {
            const localVarFetchArgs = WidgetTypeControllerApiFetchParamCreator(configuration).saveWidgetTypeUsingPOST(widgetTypeDetails, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WidgetTypeControllerApi - factory interface
 * @export
 */
export const WidgetTypeControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteWidgetType
         * @param {string} widgetTypeId widgetTypeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWidgetTypeUsingDELETE(widgetTypeId: string, options?: any) {
            return WidgetTypeControllerApiFp(configuration).deleteWidgetTypeUsingDELETE(widgetTypeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getBundleWidgetTypesDetails
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleWidgetTypesDetailsUsingGET(isSystem: string, bundleAlias: string, options?: any) {
            return WidgetTypeControllerApiFp(configuration).getBundleWidgetTypesDetailsUsingGET(isSystem, bundleAlias, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getBundleWidgetTypesInfos
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleWidgetTypesInfosUsingGET(isSystem: string, bundleAlias: string, options?: any) {
            return WidgetTypeControllerApiFp(configuration).getBundleWidgetTypesInfosUsingGET(isSystem, bundleAlias, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getBundleWidgetTypes
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleWidgetTypesUsingGET(isSystem: string, bundleAlias: string, options?: any) {
            return WidgetTypeControllerApiFp(configuration).getBundleWidgetTypesUsingGET(isSystem, bundleAlias, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getWidgetTypeById
         * @param {string} widgetTypeId widgetTypeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetTypeByIdUsingGET(widgetTypeId: string, options?: any) {
            return WidgetTypeControllerApiFp(configuration).getWidgetTypeByIdUsingGET(widgetTypeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getWidgetType
         * @param {string} isSystem isSystem
         * @param {string} bundleAlias bundleAlias
         * @param {string} alias alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetTypeUsingGET(isSystem: string, bundleAlias: string, alias: string, options?: any) {
            return WidgetTypeControllerApiFp(configuration).getWidgetTypeUsingGET(isSystem, bundleAlias, alias, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveWidgetType
         * @param {WidgetTypeDetails} widgetTypeDetails widgetTypeDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWidgetTypeUsingPOST(widgetTypeDetails: WidgetTypeDetails, options?: any) {
            return WidgetTypeControllerApiFp(configuration).saveWidgetTypeUsingPOST(widgetTypeDetails, options)(fetch, basePath);
        },
    };
};

/**
 * WidgetTypeControllerApi - object-oriented interface
 * @export
 * @class WidgetTypeControllerApi
 * @extends {BaseAPI}
 */
export class WidgetTypeControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteWidgetType
     * @param {string} widgetTypeId widgetTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetTypeControllerApi
     */
    public deleteWidgetTypeUsingDELETE(widgetTypeId: string, options?: any) {
        return WidgetTypeControllerApiFp(this.configuration).deleteWidgetTypeUsingDELETE(widgetTypeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getBundleWidgetTypesDetails
     * @param {string} isSystem isSystem
     * @param {string} bundleAlias bundleAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetTypeControllerApi
     */
    public getBundleWidgetTypesDetailsUsingGET(isSystem: string, bundleAlias: string, options?: any) {
        return WidgetTypeControllerApiFp(this.configuration).getBundleWidgetTypesDetailsUsingGET(isSystem, bundleAlias, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getBundleWidgetTypesInfos
     * @param {string} isSystem isSystem
     * @param {string} bundleAlias bundleAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetTypeControllerApi
     */
    public getBundleWidgetTypesInfosUsingGET(isSystem: string, bundleAlias: string, options?: any) {
        return WidgetTypeControllerApiFp(this.configuration).getBundleWidgetTypesInfosUsingGET(isSystem, bundleAlias, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getBundleWidgetTypes
     * @param {string} isSystem isSystem
     * @param {string} bundleAlias bundleAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetTypeControllerApi
     */
    public getBundleWidgetTypesUsingGET(isSystem: string, bundleAlias: string, options?: any) {
        return WidgetTypeControllerApiFp(this.configuration).getBundleWidgetTypesUsingGET(isSystem, bundleAlias, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getWidgetTypeById
     * @param {string} widgetTypeId widgetTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetTypeControllerApi
     */
    public getWidgetTypeByIdUsingGET(widgetTypeId: string, options?: any) {
        return WidgetTypeControllerApiFp(this.configuration).getWidgetTypeByIdUsingGET(widgetTypeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getWidgetType
     * @param {string} isSystem isSystem
     * @param {string} bundleAlias bundleAlias
     * @param {string} alias alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetTypeControllerApi
     */
    public getWidgetTypeUsingGET(isSystem: string, bundleAlias: string, alias: string, options?: any) {
        return WidgetTypeControllerApiFp(this.configuration).getWidgetTypeUsingGET(isSystem, bundleAlias, alias, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveWidgetType
     * @param {WidgetTypeDetails} widgetTypeDetails widgetTypeDetails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetTypeControllerApi
     */
    public saveWidgetTypeUsingPOST(widgetTypeDetails: WidgetTypeDetails, options?: any) {
        return WidgetTypeControllerApiFp(this.configuration).saveWidgetTypeUsingPOST(widgetTypeDetails, options)(this.fetch, this.basePath);
    }

}

/**
 * WidgetsBundleControllerApi - fetch parameter creator
 * @export
 */
export const WidgetsBundleControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteWidgetsBundle
         * @param {string} widgetsBundleId widgetsBundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWidgetsBundleUsingDELETE(widgetsBundleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'widgetsBundleId' is not null or undefined
            if (widgetsBundleId === null || widgetsBundleId === undefined) {
                throw new RequiredError('widgetsBundleId','Required parameter widgetsBundleId was null or undefined when calling deleteWidgetsBundleUsingDELETE.');
            }
            const localVarPath = `/api/widgetsBundle/{widgetsBundleId}`
                .replace(`{${"widgetsBundleId"}}`, encodeURIComponent(String(widgetsBundleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWidgetsBundleById
         * @param {string} widgetsBundleId widgetsBundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetsBundleByIdUsingGET(widgetsBundleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'widgetsBundleId' is not null or undefined
            if (widgetsBundleId === null || widgetsBundleId === undefined) {
                throw new RequiredError('widgetsBundleId','Required parameter widgetsBundleId was null or undefined when calling getWidgetsBundleByIdUsingGET.');
            }
            const localVarPath = `/api/widgetsBundle/{widgetsBundleId}`
                .replace(`{${"widgetsBundleId"}}`, encodeURIComponent(String(widgetsBundleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWidgetsBundles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetsBundlesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getWidgetsBundlesUsingGET.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getWidgetsBundlesUsingGET.');
            }
            const localVarPath = `/api/widgetsBundles{?textSearch,sortProperty,sortOrder,pageSize,page}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (sortProperty !== undefined) {
                localVarQueryParameter['sortProperty'] = sortProperty;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWidgetsBundles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetsBundlesUsingGET1(options: any = {}): FetchArgs {
            const localVarPath = `/api/widgetsBundles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveWidgetsBundle
         * @param {WidgetsBundle} widgetsBundle widgetsBundle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWidgetsBundleUsingPOST(widgetsBundle: WidgetsBundle, options: any = {}): FetchArgs {
            // verify required parameter 'widgetsBundle' is not null or undefined
            if (widgetsBundle === null || widgetsBundle === undefined) {
                throw new RequiredError('widgetsBundle','Required parameter widgetsBundle was null or undefined when calling saveWidgetsBundleUsingPOST.');
            }
            const localVarPath = `/api/widgetsBundle`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WidgetsBundle" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(widgetsBundle || {}) : (widgetsBundle || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WidgetsBundleControllerApi - functional programming interface
 * @export
 */
export const WidgetsBundleControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteWidgetsBundle
         * @param {string} widgetsBundleId widgetsBundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWidgetsBundleUsingDELETE(widgetsBundleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WidgetsBundleControllerApiFetchParamCreator(configuration).deleteWidgetsBundleUsingDELETE(widgetsBundleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getWidgetsBundleById
         * @param {string} widgetsBundleId widgetsBundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetsBundleByIdUsingGET(widgetsBundleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WidgetsBundle> {
            const localVarFetchArgs = WidgetsBundleControllerApiFetchParamCreator(configuration).getWidgetsBundleByIdUsingGET(widgetsBundleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getWidgetsBundles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetsBundlesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageDataWidgetsBundle> {
            const localVarFetchArgs = WidgetsBundleControllerApiFetchParamCreator(configuration).getWidgetsBundlesUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getWidgetsBundles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetsBundlesUsingGET1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WidgetsBundle>> {
            const localVarFetchArgs = WidgetsBundleControllerApiFetchParamCreator(configuration).getWidgetsBundlesUsingGET1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveWidgetsBundle
         * @param {WidgetsBundle} widgetsBundle widgetsBundle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWidgetsBundleUsingPOST(widgetsBundle: WidgetsBundle, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WidgetsBundle> {
            const localVarFetchArgs = WidgetsBundleControllerApiFetchParamCreator(configuration).saveWidgetsBundleUsingPOST(widgetsBundle, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WidgetsBundleControllerApi - factory interface
 * @export
 */
export const WidgetsBundleControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteWidgetsBundle
         * @param {string} widgetsBundleId widgetsBundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWidgetsBundleUsingDELETE(widgetsBundleId: string, options?: any) {
            return WidgetsBundleControllerApiFp(configuration).deleteWidgetsBundleUsingDELETE(widgetsBundleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getWidgetsBundleById
         * @param {string} widgetsBundleId widgetsBundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetsBundleByIdUsingGET(widgetsBundleId: string, options?: any) {
            return WidgetsBundleControllerApiFp(configuration).getWidgetsBundleByIdUsingGET(widgetsBundleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getWidgetsBundles
         * @param {string} pageSize pageSize
         * @param {string} page page
         * @param {string} [textSearch] textSearch
         * @param {string} [sortProperty] sortProperty
         * @param {string} [sortOrder] sortOrder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetsBundlesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
            return WidgetsBundleControllerApiFp(configuration).getWidgetsBundlesUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getWidgetsBundles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetsBundlesUsingGET1(options?: any) {
            return WidgetsBundleControllerApiFp(configuration).getWidgetsBundlesUsingGET1(options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveWidgetsBundle
         * @param {WidgetsBundle} widgetsBundle widgetsBundle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWidgetsBundleUsingPOST(widgetsBundle: WidgetsBundle, options?: any) {
            return WidgetsBundleControllerApiFp(configuration).saveWidgetsBundleUsingPOST(widgetsBundle, options)(fetch, basePath);
        },
    };
};

/**
 * WidgetsBundleControllerApi - object-oriented interface
 * @export
 * @class WidgetsBundleControllerApi
 * @extends {BaseAPI}
 */
export class WidgetsBundleControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteWidgetsBundle
     * @param {string} widgetsBundleId widgetsBundleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetsBundleControllerApi
     */
    public deleteWidgetsBundleUsingDELETE(widgetsBundleId: string, options?: any) {
        return WidgetsBundleControllerApiFp(this.configuration).deleteWidgetsBundleUsingDELETE(widgetsBundleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getWidgetsBundleById
     * @param {string} widgetsBundleId widgetsBundleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetsBundleControllerApi
     */
    public getWidgetsBundleByIdUsingGET(widgetsBundleId: string, options?: any) {
        return WidgetsBundleControllerApiFp(this.configuration).getWidgetsBundleByIdUsingGET(widgetsBundleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getWidgetsBundles
     * @param {string} pageSize pageSize
     * @param {string} page page
     * @param {string} [textSearch] textSearch
     * @param {string} [sortProperty] sortProperty
     * @param {string} [sortOrder] sortOrder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetsBundleControllerApi
     */
    public getWidgetsBundlesUsingGET(pageSize: string, page: string, textSearch?: string, sortProperty?: string, sortOrder?: string, options?: any) {
        return WidgetsBundleControllerApiFp(this.configuration).getWidgetsBundlesUsingGET(pageSize, page, textSearch, sortProperty, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getWidgetsBundles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetsBundleControllerApi
     */
    public getWidgetsBundlesUsingGET1(options?: any) {
        return WidgetsBundleControllerApiFp(this.configuration).getWidgetsBundlesUsingGET1(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveWidgetsBundle
     * @param {WidgetsBundle} widgetsBundle widgetsBundle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetsBundleControllerApi
     */
    public saveWidgetsBundleUsingPOST(widgetsBundle: WidgetsBundle, options?: any) {
        return WidgetsBundleControllerApiFp(this.configuration).saveWidgetsBundleUsingPOST(widgetsBundle, options)(this.fetch, this.basePath);
    }

}

